#!/usr/bin/env python

# This script is used to generate Makefile.qemu2-sources.mk from
# the build output of build-qemu-android.sh. To use it:
#
#  rm -rf /tmp/qemu2-build
#  external/qemu/android/scripts/build-qemu-android.sh \
#      --darwin-ssh=<hostname> \
#      --install-dir=/tmp/qemu2-build
#
#  external/qemu/android-qemu2-glue/scripts/gen-qemu2-sources-mk.py \
#      /tmp/qemu2-build \
#      > external/qemu/android-qemu2-glue/build/Makefile.qemu2-sources.mk
#
from __future__ import print_function
import argparse
import logging
import os
import random
import sys
import shutil
import subprocess


class SetLikeList(list):
  """A set like list has set operations defined on a standard list.

  This means that every object only occurs once, and you can do the usual
  set operations on this list.

  Note that this thing is super expensive, and should only be used if
  insertion order is important.
  """

  def add(self, item):
    if item not in self:
      self.append(item)

  def __sub__(self, other):
    for idx in xrange(len(self) - 1, 0, -1):
      if self[idx] in other:
        del self[idx]
    return self

  def __and__(self, other):
    for idx in xrange(len(self) - 1, 0, -1):
      if self[idx] not in other:
        del self[idx]
    return self

  # def __or__(self, other):
  #   for item in other:
  #     self.add(item)


TARGET_SUFFIX = '-softmmu'

EXPECTED_HOSTS = set(
    ['linux-x86_64', 'windows-x86', 'windows-x86_64', 'darwin-x86_64'])

LINK_QEMU_PREFIX = 'LINK-qemu-system-'
IGNORED_OBJECTS = [
    '../audio/sdlaudio.o',
    'gdbstub-xml.o',
    'hax-stub.o',
    'hw/i386/acpi-build.o',
    'hw/i386/pc_piix.o',
    '../hw/smbios/smbios_type_38-stub.o',

    # these aren't used in the emulator but add 1MB+ to binary size
    '../hw/net/e1000.o',
    '../hw/net/e1000e.o',
    '../hw/net/e1000e_core.o',
    '../hw/net/e1000x_common.o',
    '../ui/sdl_zoom.o',
    '../ui/sdl.o',
    '../ui/sdl2.o',
    '../ui/sdl2-2d.o',
    '../ui/sdl2-input.o',
    '../vl.o',
    'trace-root.o',
    'trace/generated-helpers.o',
    '/version.o',  # something from the Windows build
    # A lot of stubs are not used..
]

CC_OBJECTS = [
    '../disas/arm-a64.o',
    '../disas/libvixl/vixl/a64/decoder-a64.o',
    '../disas/libvixl/vixl/a64/disasm-a64.o',
    '../disas/libvixl/vixl/a64/instructions-a64.o',
    '../disas/libvixl/vixl/compiler-intrinsics.o',
    '../disas/libvixl/vixl/utils.o',
]

REMARKS = [
    "Really, just don't do it",
    'Puppies and kittens die when you change this manually',
    "I've been autogenerated, don't mess with me",
    'Please, please do not change this manually',
    'There is a better way than modifying this file',
    "I know this looks like the easy way out, but don't touch this file!",
    'Git blame will find you, and you get to merge the next qemu release when '
    'you change this!',
]

HEADER = ('# This file is auto generated! Do not edit it!\n'
          '# Even the order matters, so do not change manually!')

qemu_files = []


def find_target_lists(build_path, hosts):
  """Return a set of QEMU cpu architectures targetted by the binaries
       found under |build_path|. |hosts| is a set of hosts to probe for"""
  result = set()
  for host in hosts:
    for _, _, files in os.walk(os.path.join(build_path, host)):
      for efile in files:
        if efile.startswith(LINK_QEMU_PREFIX):
          arch = efile[len(LINK_QEMU_PREFIX):]
          if arch[-5:] == 'w.exe':
            arch = arch[:-5]
          result.add(arch)
  return sorted(result)


def read_link_file(link_file):
  """Parses the link file, returning all the .o entries."""
  result = SetLikeList()
  with open(link_file) as lfile:
    content = lfile.readlines()
    for obj in content:
      obj = obj.strip()
      if (obj[-2:] in ['.o', '.a'] and obj not in IGNORED_OBJECTS):
        result.add(obj)
  return result


def find_link_files(build_path, host):
  """Return a map of target arch, lib -> set of object files names
     as they occur in LINK-.... files |build_path| is the
       top-level build path, and |host| is the host to probe."""
  result = {}
  build_path = os.path.join(build_path, host)
  link_prefix = 'LINK-'
  for subdir, _, files in os.walk(build_path):
    for efile in files:
      if efile.startswith(link_prefix):
        target = efile[efile.rfind('-') + 1:]
        # Remove w.exe suffix for Windows binaries.
        if target[-5:] == 'w.exe':
          target = target[:-5]
        logging.info('Discovered: %s', target)
        result[target] = read_link_file(os.path.join(subdir, efile))

  return result


def is_generated(fname):
  """Returns true if the fname is generated, ie. not found in the qemu root."""
  return fname not in qemu_files


def list_files(name, files, output):
  idx = 0
  output.write('%s := \\\n' % name)

  for f in source_list_from_objects(files):
    idx += 1
    output.write('    %s \\\n' % f)
    if idx % 15 == 0:
      output.write('\n%s\n# %s\n' % (HEADER, REMARKS[idx % len(REMARKS)]))
      output.write('%s += \\\n' % name)

  output.write('\n')


def normalize(obj):
  if obj.startswith('../'):
    obj = obj[3:]
  return obj


def source_list_from_objects(objects):
  result = SetLikeList()
  for obj in objects:
    if obj[-2:] == '.a':
      continue

    if obj in CC_OBJECTS:
      obj = obj[:-2] + '.cc'
    else:
      obj = obj[:-2] + '.c'

    if obj.startswith('../'):
      obj = obj[3:]

    if (is_generated(obj)):
      obj = '$(QEMU2_AUTO_GENERATED_DIR)/' + obj
    result.add(obj)
  return result


def copy_config(source_dir, host, qemu_root):
  shutil.copyfile(
      os.path.join(source_dir, host, 'config-host.h'),
      os.path.join(qemu_root, 'android-qemu2-glue', 'config', host,
                   'config-host.h'))


def main(argv):
  parser = argparse.ArgumentParser(description='Generate the sub-Makefiles '
                                   'describing the common and '
                                   'target-specific sources for the QEMU2 '
                                   'build performed with the emulator\'s '
                                   'build system. This is done by looking at '
                                   'the output of a regular QEMU2 build, and '
                                   'finding which files were built and '
                                   'where.')

  parser.add_argument(
      '-i',
      '--input',
      dest='inputs',
      type=str,
      required=True,
      help='The input directory containing all the '
      'build binaries.')
  parser.add_argument(
      '-r',
      '--root',
      dest='root',
      type=str,
      required=True,
      default='.',
      help='The qemu root directory')
  parser.add_argument(
      '-o',
      '--output',
      dest='output',
      help='the output file to write the resulting '
      'makefile to')
  parser.add_argument(
      '-s',
      '--host_set',
      dest='hosts',
      action='append',
      help='Restrict the generated sources only to this host set. '
      'DO NOT USE, ONLY USED FOR MAKING MERGES EASIER"')
  parser.add_argument(
      '-v',
      '--verbose',
      action='store_const',
      dest='loglevel',
      const=logging.INFO,
      help='Be more verbose')
  args = parser.parse_args()

  if not args.hosts:
    args.hosts = EXPECTED_HOSTS

  if args.output is None:
    output = sys.stdout
  else:
    output = open(args.output, 'w')

  logging.basicConfig(level=args.loglevel)
  global qemu_files
  qemu_files = subprocess.check_output(
      ['git', 'ls-files'], cwd=args.root).split('\n')

  # First copy the configs over
  for host in args.hosts:
    copy_config(args.inputs, host, args.root)

  build_dir = args.inputs

  output.write(
      '# Auto-generated by %s - DO NOT EDIT !!\n' % os.path.basename(argv[0]))
  output.write(
      '# Modify the qemu makefiles instead and regenerate this file!\n')
  output.write('\n')

  target_list = find_target_lists(build_dir, args.hosts)
  logging.info('Found targets: %s', repr(target_list))

  all_dependencies = {}
  for host in args.hosts:
    all_dependencies[host] = find_link_files(build_dir, host)

  host_link_map = {}
  host_lib_map = {}
  for host in args.hosts:
    host_link_map[host] = {}
    host_lib_map[host] = {}
    for target in target_list:
      needed = all_dependencies[host][target]
      depends_on = [x[3:] for x in needed if x[-2:] == '.a']
      logging.info('Host: %s, target %s depends on %s', host, target,
                   depends_on)
      host_link_map[host][target] = needed
      for lib in depends_on:
        host_lib_map[host][lib] = all_dependencies[host][lib]

  # Remove all duplicates that could have come in from libs.
  for host in args.hosts:
    for lib in host_lib_map[host]:
      for target in host_link_map[host]:
        host_link_map[host][target] = set([
            x for x in host_link_map[host][target]
            if normalize(x) not in host_lib_map[host][lib]
        ])

  host_list = sorted(host_link_map.keys())

  # The set of all objects, both for targets as well as libraries.
  all_objects = set()
  for host in host_list:
    for target in host_link_map[host]:
      all_objects |= host_link_map[host][target]

  # First construct all the lib dependencies
  for host in host_list:
    for lib in host_lib_map[host]:
      lib_name = lib[3:-2]
      list_files('QEMU2_LIB_%s_%s' % (lib_name, host), host_lib_map[host][lib],
                 output)

  left = all_objects.copy()
  # The set of all objects whose path begins with ../
  # this corresponds to objects that will end up in the qemu2_common
  # static library.
  common_all_objects = set([x for x in all_objects if x.startswith('../')])

  # move the forced target object out of common
  common_all_objects -= set(CC_OBJECTS)

  # The set of common objects that are shared by all hosts.
  common_objects = common_all_objects.copy()
  for host in host_list:
    for target in host_link_map[host]:
      common_objects &= host_link_map[host][target]

  list_files('QEMU2_COMMON_SOURCES', common_objects, output)
  left -= common_objects

  # For each host, the specific common objects that are not shared with
  # all other hosts, but still shared by all targets.
  host_common_map = {}
  for host in host_list:
    host_common_map[host] = common_all_objects - common_objects
    for target in host_link_map[host]:
      host_common_map[host] &= host_link_map[host][target]
    list_files('QEMU2_COMMON_SOURCES_%s' % host, host_common_map[host], output)
    left -= host_common_map[host]

  # The set of all target-specifc objects.
  all_target_objects = all_objects - common_objects
  for host in host_list:
    all_target_objects -= host_common_map[host]

  # Find the list of target files that are shared by all targets and all
  # hosts at the same time.
  target_common_map = {}
  for target in target_list:
    target_common_map[target] = all_target_objects.copy()
    for host in host_list:
      if (target in host_link_map[host]):
        target_common_map[target] &= host_link_map[host][target]

  target_common_objects = all_target_objects.copy()
  for target in target_common_map:
    target_common_objects &= target_common_map[target]

  list_files('QEMU2_TARGET_SOURCES', target_common_objects, output)
  left -= target_common_objects

  # For each target, find the files shared by all hosts, that only
  # belong to this target.
  for target in target_list:
    target_objects = target_common_map[target] - target_common_objects
    list_files('QEMU2_TARGET_%s_SOURCES' % target, target_objects, output)
    left -= target_objects

  # Finally, the target- and host- specific objects.
  for target in target_list:
    for host in host_list:
      if target in host_link_map[host]:
        objects = (
            host_link_map[host][target] - target_common_map[target] -
            target_common_objects - common_all_objects)
        list_files('QEMU2_TARGET_%s_SOURCES_%s' % (target, host), objects,
                   output)
        left -= objects

  if left:
    logging.error('There are %s, objects left! This shouldn\'t happen', left)


if __name__ == '__main__':
  main(sys.argv)
