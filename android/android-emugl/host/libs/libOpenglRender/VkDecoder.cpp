// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"

#include "android/base/system/System.h"

#include "IOStream.h"
#include "emugl/common/logging.h"

#include "VkDecoderGlobalState.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>





using emugl::vkDispatch;

using namespace goldfish_vk;

using android::base::System;

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(System::get()->envGet("ANDROID_EMU_VK_LOG_CALLS") == "1"), m_vk(vkDispatch()), m_state(VkDecoderGlobalState::get()) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    size_t decode(void* buf, size_t bufsize, IOStream* stream);

private:
    bool m_logCalls;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()) { }

VkDecoder::~VkDecoder() = default;

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* stream) {
    return mImpl->decode(buf, bufsize, stream);
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream)
{
    if (len < 8) return 0;;
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                VkInstanceCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                unmarshal_VkInstanceCreateInfo(vkReadStream, (VkInstanceCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                vkReadStream->read((VkInstance*)pInstance, sizeof(VkInstance));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateInstance\n");;
                }
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_vk->vkCreateInstance(pCreateInfo, pAllocator, pInstance);
                vkStream->write((VkInstance*)pInstance, sizeof(VkInstance));
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyInstance:
            {
                VkInstance instance;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyInstance\n");;
                }
                m_vk->vkDestroyInstance(instance, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((uint32_t**)&pPhysicalDeviceCount, sizeof(uint32_t*));
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkPhysicalDevice**)&pPhysicalDevices, sizeof(VkPhysicalDevice*));
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    vkReadStream->read((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDevices\n");;
                }
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_vk->vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
                vkStream->write((uint32_t**)&pPhysicalDeviceCount, sizeof(uint32_t*));
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                vkStream->write((VkPhysicalDevice**)&pPhysicalDevices, sizeof(VkPhysicalDevice*));
                if (pPhysicalDevices)
                {
                    vkStream->write((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                unmarshal_VkPhysicalDeviceFeatures(vkReadStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures\n");;
                }
                m_vk->vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
                marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                unmarshal_VkFormatProperties(vkReadStream, (VkFormatProperties*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                unmarshal_VkImageFormatProperties(vkReadStream, (VkImageFormatProperties*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                unmarshal_VkPhysicalDeviceProperties(vkReadStream, (VkPhysicalDeviceProperties*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceProperties(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkQueueFamilyProperties**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties*));
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties(vkReadStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkQueueFamilyProperties**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties*));
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                unmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                VkInstance instance;
                char* pName;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetInstanceProcAddr\n");;
                }
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = m_vk->vkGetInstanceProcAddr(instance, pName);
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                VkDevice device;
                char* pName;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceProcAddr\n");;
                }
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = m_vk->vkGetDeviceProcAddr(device, pName);
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDevice:
            {
                VkPhysicalDevice physicalDevice;
                VkDeviceCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                unmarshal_VkDeviceCreateInfo(vkReadStream, (VkDeviceCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                vkReadStream->read((VkDevice*)pDevice, sizeof(VkDevice));
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
                vkStream->write((VkDevice*)pDevice, sizeof(VkDevice));
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDevice:
            {
                VkDevice device;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyDevice(device, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceExtensionProperties\n");;
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = m_vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                VkPhysicalDevice physicalDevice;
                char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateDeviceExtensionProperties\n");;
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = m_vk->vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceLayerProperties\n");;
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = m_vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateDeviceLayerProperties\n");;
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = m_vk->vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queueIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                vkReadStream->read((VkQueue*)pQueue, sizeof(VkQueue));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceQueue\n");;
                }
                m_vk->vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
                vkStream->write((VkQueue*)pQueue, sizeof(VkQueue));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueSubmit:
            {
                VkQueue queue;
                uint32_t submitCount;
                VkSubmitInfo* pSubmits;
                VkFence fence;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->read((uint32_t*)&submitCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    unmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i));
                }
                vkReadStream->read((VkFence*)&fence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueSubmit\n");;
                }
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_vk->vkQueueSubmit(queue, submitCount, pSubmits, fence);
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                VkQueue queue;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueWaitIdle\n");;
                }
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = m_vk->vkQueueWaitIdle(queue);
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                VkDevice device;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDeviceWaitIdle\n");;
                }
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = m_vk->vkDeviceWaitIdle(device);
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateMemory:
            {
                VkDevice device;
                VkMemoryAllocateInfo* pAllocateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                unmarshal_VkMemoryAllocateInfo(vkReadStream, (VkMemoryAllocateInfo*)(pAllocateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
                vkStream->write((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkFreeMemory(device, memory, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMapMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
                vkReadStream->read((void***)&ppData, sizeof(void**));
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    vkReadStream->read((void**)ppData, sizeof(void*));
                }
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(device, memory, offset, size, flags, ppData);
                vkStream->write((void***)&ppData, sizeof(void**));
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUnmapMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                m_state->on_vkUnmapMemory(device, memory);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                VkDevice device;
                uint32_t memoryRangeCount;
                VkMappedMemoryRange* pMemoryRanges;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                for (uint32_t i = 0; i < memoryRangeCount; ++i)
                {
                    auto range = pMemoryRanges[i];
                    auto memory = pMemoryRanges[i].memory;
                    auto size = pMemoryRanges[i].size;
                    auto offset = pMemoryRanges[i].offset;
                    size_t readStream = 0;
                    vkReadStream->read(&readStream, sizeof(size_t));
                    auto hostPtr = m_state->getMappedHostPointer(memory);
                    if (!hostPtr && readStream > 0) abort();
                    if (!hostPtr) continue;
                    uint8_t* targetRange = hostPtr + offset;
                    vkReadStream->read(targetRange, readStream);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFlushMappedMemoryRanges\n");;
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = m_vk->vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                VkDevice device;
                uint32_t memoryRangeCount;
                VkMappedMemoryRange* pMemoryRanges;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkInvalidateMappedMemoryRanges\n");;
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = m_vk->vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                for (uint32_t i = 0; i < memoryRangeCount; ++i)
                {
                    auto range = pMemoryRanges[i];
                    auto memory = range.memory;
                    auto size = range.size;
                    auto offset = range.offset;
                    auto hostPtr = m_state->getMappedHostPointer(memory);
                    auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                    size_t writeStream = 0;
                    if (!hostPtr) { vkStream->write(&writeStream, sizeof(size_t)); continue; };
                    uint8_t* targetRange = hostPtr + offset;
                    writeStream = actualSize;
                    vkStream->write(&writeStream, sizeof(size_t));
                    vkStream->write(targetRange, actualSize);
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceMemoryCommitment\n");;
                }
                m_vk->vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindBufferMemory:
            {
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory\n");;
                }
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_vk->vkBindBufferMemory(device, buffer, memory, memoryOffset);
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory:
            {
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory\n");;
                }
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_vk->vkBindImageMemory(device, image, memory, memoryOffset);
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements\n");;
                }
                m_vk->vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements\n");;
                }
                m_vk->vkGetImageMemoryRequirements(device, image, pMemoryRequirements);
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->read((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements*));
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements(vkReadStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements*));
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageFormatProperties**)&pProperties, sizeof(VkSparseImageFormatProperties*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties(vkReadStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageFormatProperties**)&pProperties, sizeof(VkSparseImageFormatProperties*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueBindSparse:
            {
                VkQueue queue;
                uint32_t bindInfoCount;
                VkBindSparseInfo* pBindInfo;
                VkFence fence;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i));
                }
                vkReadStream->read((VkFence*)&fence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueBindSparse\n");;
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = m_vk->vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateFence:
            {
                VkDevice device;
                VkFenceCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                unmarshal_VkFenceCreateInfo(vkReadStream, (VkFenceCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                vkReadStream->read((VkFence*)pFence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateFence\n");;
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = m_vk->vkCreateFence(device, pCreateInfo, pAllocator, pFence);
                vkStream->write((VkFence*)pFence, sizeof(VkFence));
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyFence:
            {
                VkDevice device;
                VkFence fence;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkFence*)&fence, sizeof(VkFence));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyFence\n");;
                }
                m_vk->vkDestroyFence(device, fence, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                VkFence* pFences;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                vkReadStream->read((VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetFences\n");;
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = m_vk->vkResetFences(device, fenceCount, pFences);
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceStatus:
            {
                VkDevice device;
                VkFence fence;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkFence*)&fence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceStatus\n");;
                }
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = m_vk->vkGetFenceStatus(device, fence);
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkWaitForFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                vkReadStream->read((VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
                vkReadStream->read((VkBool32*)&waitAll, sizeof(VkBool32));
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkWaitForFences\n");;
                }
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = m_vk->vkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSemaphore:
            {
                VkDevice device;
                VkSemaphoreCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                unmarshal_VkSemaphoreCreateInfo(vkReadStream, (VkSemaphoreCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                vkReadStream->read((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSemaphore\n");;
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_vk->vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
                vkStream->write((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySemaphore:
            {
                VkDevice device;
                VkSemaphore semaphore;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySemaphore\n");;
                }
                m_vk->vkDestroySemaphore(device, semaphore, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateEvent:
            {
                VkDevice device;
                VkEventCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                unmarshal_VkEventCreateInfo(vkReadStream, (VkEventCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                vkReadStream->read((VkEvent*)pEvent, sizeof(VkEvent));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateEvent\n");;
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = m_vk->vkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
                vkStream->write((VkEvent*)pEvent, sizeof(VkEvent));
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyEvent:
            {
                VkDevice device;
                VkEvent event;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyEvent\n");;
                }
                m_vk->vkDestroyEvent(device, event, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetEventStatus:
            {
                VkDevice device;
                VkEvent event;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetEventStatus\n");;
                }
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = m_vk->vkGetEventStatus(device, event);
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSetEvent:
            {
                VkDevice device;
                VkEvent event;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetEvent\n");;
                }
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = m_vk->vkSetEvent(device, event);
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetEvent:
            {
                VkDevice device;
                VkEvent event;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetEvent\n");;
                }
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = m_vk->vkResetEvent(device, event);
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateQueryPool:
            {
                VkDevice device;
                VkQueryPoolCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                unmarshal_VkQueryPoolCreateInfo(vkReadStream, (VkQueryPoolCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                vkReadStream->read((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateQueryPool\n");;
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = m_vk->vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
                vkStream->write((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                VkDevice device;
                VkQueryPool queryPool;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyQueryPool\n");;
                }
                m_vk->vkDestroyQueryPool(device, queryPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                vkReadStream->read((size_t*)&dataSize, sizeof(size_t));
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetQueryPoolResults\n");;
                }
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = m_vk->vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateBuffer:
            {
                VkDevice device;
                VkBufferCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                unmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkBuffer*)pBuffer, sizeof(VkBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateBuffer\n");;
                }
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_vk->vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
                vkStream->write((VkBuffer*)pBuffer, sizeof(VkBuffer));
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyBuffer:
            {
                VkDevice device;
                VkBuffer buffer;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyBuffer\n");;
                }
                m_vk->vkDestroyBuffer(device, buffer, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateBufferView:
            {
                VkDevice device;
                VkBufferViewCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                unmarshal_VkBufferViewCreateInfo(vkReadStream, (VkBufferViewCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                vkReadStream->read((VkBufferView*)pView, sizeof(VkBufferView));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateBufferView\n");;
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = m_vk->vkCreateBufferView(device, pCreateInfo, pAllocator, pView);
                vkStream->write((VkBufferView*)pView, sizeof(VkBufferView));
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyBufferView:
            {
                VkDevice device;
                VkBufferView bufferView;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkBufferView*)&bufferView, sizeof(VkBufferView));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyBufferView\n");;
                }
                m_vk->vkDestroyBufferView(device, bufferView, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateImage:
            {
                VkDevice device;
                VkImageCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                unmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                vkReadStream->read((VkImage*)pImage, sizeof(VkImage));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImage\n");;
                }
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_vk->vkCreateImage(device, pCreateInfo, pAllocator, pImage);
                vkStream->write((VkImage*)pImage, sizeof(VkImage));
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyImage:
            {
                VkDevice device;
                VkImage image;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImage\n");;
                }
                m_vk->vkDestroyImage(device, image, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                VkDevice device;
                VkImage image;
                VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                unmarshal_VkImageSubresource(vkReadStream, (VkImageSubresource*)(pSubresource));
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                unmarshal_VkSubresourceLayout(vkReadStream, (VkSubresourceLayout*)(pLayout));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSubresourceLayout\n");;
                }
                m_vk->vkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
                marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateImageView:
            {
                VkDevice device;
                VkImageViewCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                unmarshal_VkImageViewCreateInfo(vkReadStream, (VkImageViewCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                vkReadStream->read((VkImageView*)pView, sizeof(VkImageView));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImageView\n");;
                }
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_vk->vkCreateImageView(device, pCreateInfo, pAllocator, pView);
                vkStream->write((VkImageView*)pView, sizeof(VkImageView));
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyImageView:
            {
                VkDevice device;
                VkImageView imageView;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkImageView*)&imageView, sizeof(VkImageView));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImageView\n");;
                }
                m_vk->vkDestroyImageView(device, imageView, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateShaderModule:
            {
                VkDevice device;
                VkShaderModuleCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                unmarshal_VkShaderModuleCreateInfo(vkReadStream, (VkShaderModuleCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                vkReadStream->read((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateShaderModule\n");;
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = m_vk->vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
                vkStream->write((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                VkDevice device;
                VkShaderModule shaderModule;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkShaderModule*)&shaderModule, sizeof(VkShaderModule));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyShaderModule\n");;
                }
                m_vk->vkDestroyShaderModule(device, shaderModule, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                VkDevice device;
                VkPipelineCacheCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                unmarshal_VkPipelineCacheCreateInfo(vkReadStream, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                vkReadStream->read((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreatePipelineCache\n");;
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = m_vk->vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
                vkStream->write((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipelineCache\n");;
                }
                m_vk->vkDestroyPipelineCache(device, pipelineCache, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
                vkReadStream->read((size_t**)&pDataSize, sizeof(size_t*));
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    vkReadStream->read((size_t*)pDataSize, sizeof(size_t));
                }
                vkReadStream->read((void**)&pData, sizeof(void*));
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPipelineCacheData\n");;
                }
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = m_vk->vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
                vkStream->write((size_t**)&pDataSize, sizeof(size_t*));
                if (pDataSize)
                {
                    vkStream->write((size_t*)pDataSize, sizeof(size_t));
                }
                vkStream->write((void**)&pData, sizeof(void*));
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                VkPipelineCache* pSrcCaches;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineCache*)&dstCache, sizeof(VkPipelineCache));
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                vkReadStream->read((VkPipelineCache*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMergePipelineCaches\n");;
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = m_vk->vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                VkGraphicsPipelineCreateInfo* pCreateInfos;
                VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                }
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                vkReadStream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateGraphicsPipelines\n");;
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = m_vk->vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                VkComputePipelineCreateInfo* pCreateInfos;
                VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkComputePipelineCreateInfo(vkReadStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                }
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                vkReadStream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateComputePipelines\n");;
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = m_vk->vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipeline:
            {
                VkDevice device;
                VkPipeline pipeline;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipeline\n");;
                }
                m_vk->vkDestroyPipeline(device, pipeline, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                VkDevice device;
                VkPipelineLayoutCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                unmarshal_VkPipelineLayoutCreateInfo(vkReadStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                vkReadStream->read((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreatePipelineLayout\n");;
                }
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = m_vk->vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
                vkStream->write((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipelineLayout*)&pipelineLayout, sizeof(VkPipelineLayout));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipelineLayout\n");;
                }
                m_vk->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSampler:
            {
                VkDevice device;
                VkSamplerCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                unmarshal_VkSamplerCreateInfo(vkReadStream, (VkSamplerCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                vkReadStream->read((VkSampler*)pSampler, sizeof(VkSampler));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSampler\n");;
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_vk->vkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
                vkStream->write((VkSampler*)pSampler, sizeof(VkSampler));
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySampler:
            {
                VkDevice device;
                VkSampler sampler;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSampler*)&sampler, sizeof(VkSampler));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySampler\n");;
                }
                m_vk->vkDestroySampler(device, sampler, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                VkDevice device;
                VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                vkReadStream->read((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorSetLayout\n");;
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = m_vk->vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
                vkStream->write((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorSetLayout*)&descriptorSetLayout, sizeof(VkDescriptorSetLayout));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorSetLayout\n");;
                }
                m_vk->vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPoolCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                unmarshal_VkDescriptorPoolCreateInfo(vkReadStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                vkReadStream->read((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorPool\n");;
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = m_vk->vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
                vkStream->write((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorPool\n");;
                }
                m_vk->vkDestroyDescriptorPool(device, descriptorPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
                vkReadStream->read((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetDescriptorPool\n");;
                }
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = m_vk->vkResetDescriptorPool(device, descriptorPool, flags);
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                VkDevice device;
                VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                unmarshal_VkDescriptorSetAllocateInfo(vkReadStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                vkReadStream->read((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateDescriptorSets\n");;
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = m_vk->vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
                vkStream->write((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                VkDescriptorSet* pDescriptorSets;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                vkReadStream->read((VkDescriptorSet**)&pDescriptorSets, sizeof(const VkDescriptorSet*));
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    vkReadStream->read((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeDescriptorSets\n");;
                }
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = m_vk->vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                VkDevice device;
                uint32_t descriptorWriteCount;
                VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                VkCopyDescriptorSet* pDescriptorCopies;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                vkReadStream->read((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    unmarshal_VkCopyDescriptorSet(vkReadStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSets\n");;
                }
                m_vk->vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                VkDevice device;
                VkFramebufferCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                unmarshal_VkFramebufferCreateInfo(vkReadStream, (VkFramebufferCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                vkReadStream->read((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateFramebuffer\n");;
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = m_vk->vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
                vkStream->write((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                VkDevice device;
                VkFramebuffer framebuffer;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkFramebuffer*)&framebuffer, sizeof(VkFramebuffer));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyFramebuffer\n");;
                }
                m_vk->vkDestroyFramebuffer(device, framebuffer, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateRenderPass:
            {
                VkDevice device;
                VkRenderPassCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                unmarshal_VkRenderPassCreateInfo(vkReadStream, (VkRenderPassCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                vkReadStream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateRenderPass\n");;
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = m_vk->vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                VkDevice device;
                VkRenderPass renderPass;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyRenderPass\n");;
                }
                m_vk->vkDestroyRenderPass(device, renderPass, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                unmarshal_VkExtent2D(vkReadStream, (VkExtent2D*)(pGranularity));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRenderAreaGranularity\n");;
                }
                m_vk->vkGetRenderAreaGranularity(device, renderPass, pGranularity);
                marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateCommandPool:
            {
                VkDevice device;
                VkCommandPoolCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                unmarshal_VkCommandPoolCreateInfo(vkReadStream, (VkCommandPoolCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                vkReadStream->read((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateCommandPool\n");;
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_vk->vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
                vkStream->write((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyCommandPool\n");;
                }
                m_vk->vkDestroyCommandPool(device, commandPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
                vkReadStream->read((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandPool\n");;
                }
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_vk->vkResetCommandPool(device, commandPool, flags);
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                VkDevice device;
                VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                unmarshal_VkCommandBufferAllocateInfo(vkReadStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                vkReadStream->read((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateCommandBuffers\n");;
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_vk->vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
                vkStream->write((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                VkCommandBuffer* pCommandBuffers;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                vkReadStream->read((VkCommandBuffer**)&pCommandBuffers, sizeof(const VkCommandBuffer*));
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    vkReadStream->read((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeCommandBuffers\n");;
                }
                m_vk->vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkCommandBufferBeginInfo* pBeginInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBeginCommandBuffer\n");;
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_vk->vkBeginCommandBuffer(commandBuffer, pBeginInfo);
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEndCommandBuffer\n");;
                }
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = m_vk->vkEndCommandBuffer(commandBuffer);
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandBuffer\n");;
                }
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = m_vk->vkResetCommandBuffer(commandBuffer, flags);
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                vkReadStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindPipeline\n");;
                }
                m_vk->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetViewport:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                VkViewport* pViewports;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewport(vkReadStream, (VkViewport*)(pViewports + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetViewport\n");;
                }
                m_vk->vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetScissor:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                VkRect2D* pScissors;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&firstScissor, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&scissorCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pScissors + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetScissor\n");;
                }
                m_vk->vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                VkCommandBuffer commandBuffer;
                float lineWidth;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((float*)&lineWidth, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetLineWidth\n");;
                }
                m_vk->vkCmdSetLineWidth(commandBuffer, lineWidth);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((float*)&depthBiasConstantFactor, sizeof(float));
                vkReadStream->read((float*)&depthBiasClamp, sizeof(float));
                vkReadStream->read((float*)&depthBiasSlopeFactor, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDepthBias\n");;
                }
                m_vk->vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((float*)&blendConstants, 4 * sizeof(const float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetBlendConstants\n");;
                }
                m_vk->vkCmdSetBlendConstants(commandBuffer, blendConstants);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((float*)&minDepthBounds, sizeof(float));
                vkReadStream->read((float*)&maxDepthBounds, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDepthBounds\n");;
                }
                m_vk->vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&compareMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilCompareMask\n");;
                }
                m_vk->vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&writeMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilWriteMask\n");;
                }
                m_vk->vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&reference, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilReference\n");;
                }
                m_vk->vkCmdSetStencilReference(commandBuffer, faceMask, reference);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                uint32_t* pDynamicOffsets;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                vkReadStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
                vkReadStream->read((uint32_t*)&firstSet, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                vkReadStream->read((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                vkReadStream->read((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindDescriptorSets\n");;
                }
                m_vk->vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkIndexType*)&indexType, sizeof(VkIndexType));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindIndexBuffer\n");;
                }
                m_vk->vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                VkBuffer* pBuffers;
                VkDeviceSize* pOffsets;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&firstBinding, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bindingCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                vkReadStream->read((VkBuffer*)pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindVertexBuffers\n");;
                }
                m_vk->vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDraw:
            {
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&vertexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstVertex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDraw\n");;
                }
                m_vk->vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&indexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstIndex, sizeof(uint32_t));
                vkReadStream->read((int32_t*)&vertexOffset, sizeof(int32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexed\n");;
                }
                m_vk->vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirect\n");;
                }
                m_vk->vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirect\n");;
                }
                m_vk->vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatch:
            {
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatch\n");;
                }
                m_vk->vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchIndirect\n");;
                }
                m_vk->vkCmdDispatchIndirect(commandBuffer, buffer, offset);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                VkBufferCopy* pRegions;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferCopy(vkReadStream, (VkBufferCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyBuffer\n");;
                }
                m_vk->vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                VkImageCopy* pRegions;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&srcImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((VkImage*)&dstImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageCopy(vkReadStream, (VkImageCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyImage\n");;
                }
                m_vk->vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBlitImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                VkImageBlit* pRegions;
                VkFilter filter;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&srcImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((VkImage*)&dstImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageBlit(vkReadStream, (VkImageBlit*)(pRegions + i));
                }
                vkReadStream->read((VkFilter*)&filter, sizeof(VkFilter));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBlitImage\n");;
                }
                m_vk->vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                VkBufferImageCopy* pRegions;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkImage*)&dstImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyBufferToImage\n");;
                }
                m_vk->vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                VkBufferImageCopy* pRegions;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&srcImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyImageToBuffer\n");;
                }
                m_vk->vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                void* pData;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdUpdateBuffer\n");;
                }
                m_vk->vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&data, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdFillBuffer\n");;
                }
                m_vk->vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                VkClearColorValue* pColor;
                uint32_t rangeCount;
                VkImageSubresourceRange* pRanges;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                unmarshal_VkClearColorValue(vkReadStream, (VkClearColorValue*)(pColor));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearColorImage\n");;
                }
                m_vk->vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                VkImageSubresourceRange* pRanges;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&image, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                unmarshal_VkClearDepthStencilValue(vkReadStream, (VkClearDepthStencilValue*)(pDepthStencil));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearDepthStencilImage\n");;
                }
                m_vk->vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                VkClearAttachment* pAttachments;
                uint32_t rectCount;
                VkClearRect* pRects;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&attachmentCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    unmarshal_VkClearAttachment(vkReadStream, (VkClearAttachment*)(pAttachments + i));
                }
                vkReadStream->read((uint32_t*)&rectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    unmarshal_VkClearRect(vkReadStream, (VkClearRect*)(pRects + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearAttachments\n");;
                }
                m_vk->vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResolveImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                VkImageResolve* pRegions;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkImage*)&srcImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((VkImage*)&dstImage, sizeof(VkImage));
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageResolve(vkReadStream, (VkImageResolve*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResolveImage\n");;
                }
                m_vk->vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetEvent\n");;
                }
                m_vk->vkCmdSetEvent(commandBuffer, event, stageMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkEvent*)&event, sizeof(VkEvent));
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResetEvent\n");;
                }
                m_vk->vkCmdResetEvent(commandBuffer, event, stageMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                VkImageMemoryBarrier* pImageMemoryBarriers;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&eventCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                vkReadStream->read((VkEvent*)pEvents, ((eventCount)) * sizeof(const VkEvent));
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWaitEvents\n");;
                }
                m_vk->vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                VkImageMemoryBarrier* pImageMemoryBarriers;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPipelineBarrier\n");;
                }
                m_vk->vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vkReadStream->read((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginQuery\n");;
                }
                m_vk->vkCmdBeginQuery(commandBuffer, queryPool, query, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndQuery\n");;
                }
                m_vk->vkCmdEndQuery(commandBuffer, queryPool, query);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResetQueryPool\n");;
                }
                m_vk->vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWriteTimestamp\n");;
                }
                m_vk->vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyQueryPoolResults\n");;
                }
                m_vk->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPushConstants:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                void* pValues;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
                vkReadStream->read((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
                vkReadStream->read((uint32_t*)&offset, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&size, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pValues, ((size)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushConstants\n");;
                }
                m_vk->vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                VkCommandBuffer commandBuffer;
                VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginRenderPass\n");;
                }
                m_vk->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdNextSubpass\n");;
                }
                m_vk->vkCmdNextSubpass(commandBuffer, contents);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                VkCommandBuffer commandBuffer;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndRenderPass\n");;
                }
                m_vk->vkCmdEndRenderPass(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                VkCommandBuffer* pCommandBuffers;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                vkReadStream->read((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdExecuteCommands\n");;
                }
                m_vk->vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                uint32_t* pApiVersion;
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceVersion\n");;
                }
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_vk->vkEnumerateInstanceVersion(pApiVersion);
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                VkBindBufferMemoryInfo* pBindInfos;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2\n");;
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_vk->vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                VkBindImageMemoryInfo* pBindInfos;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory2\n");;
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = m_vk->vkBindImageMemory2(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPeerMemoryFeatures\n");;
                }
                m_vk->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDeviceMask\n");;
                }
                m_vk->vkCmdSetDeviceMask(commandBuffer, deviceMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchBase\n");;
                }
                m_vk->vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDeviceGroups\n");;
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = m_vk->vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkStream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                VkDevice device;
                VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2\n");;
                }
                m_vk->vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                VkDevice device;
                VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements2\n");;
                }
                m_vk->vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                VkDevice device;
                VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->read((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements2\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2\n");;
                }
                m_vk->vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkTrimCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkTrimCommandPool\n");;
                }
                m_vk->vkTrimCommandPool(device, commandPool, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                VkDevice device;
                VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                unmarshal_VkDeviceQueueInfo2(vkReadStream, (VkDeviceQueueInfo2*)(pQueueInfo));
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                vkReadStream->read((VkQueue*)pQueue, sizeof(VkQueue));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceQueue2\n");;
                }
                m_vk->vkGetDeviceQueue2(device, pQueueInfo, pQueue);
                vkStream->write((VkQueue*)pQueue, sizeof(VkQueue));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                VkDevice device;
                VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkReadStream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSamplerYcbcrConversion\n");;
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = m_vk->vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySamplerYcbcrConversion\n");;
                }
                m_vk->vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                VkDevice device;
                VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplate\n");;
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_vk->vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplate\n");;
                }
                m_vk->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                void* pData;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
                vkReadStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((void**)&pData, sizeof(const void*));
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSetWithTemplate\n");;
                }
                m_vk->vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalBufferProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalFenceProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphoreProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                VkDevice device;
                VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDescriptorSetLayoutSupport\n");;
                }
                m_vk->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                VkInstance instance;
                VkSurfaceKHR surface;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySurfaceKHR\n");;
                }
                m_vk->vkDestroySurfaceKHR(instance, surface, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                vkReadStream->read((VkBool32*)pSupported, sizeof(VkBool32));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceSupportKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                unmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilitiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->read((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSurfaceFormatKHR**)&pSurfaceFormats, sizeof(VkSurfaceFormatKHR*));
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormatKHR(vkReadStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceFormatsKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkStream->write((VkSurfaceFormatKHR**)&pSurfaceFormats, sizeof(VkSurfaceFormatKHR*));
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->read((uint32_t**)&pPresentModeCount, sizeof(uint32_t*));
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkPresentModeKHR**)&pPresentModes, sizeof(VkPresentModeKHR*));
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    vkReadStream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfacePresentModesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
                vkStream->write((uint32_t**)&pPresentModeCount, sizeof(uint32_t*));
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                vkStream->write((VkPresentModeKHR**)&pPresentModes, sizeof(VkPresentModeKHR*));
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                VkDevice device;
                VkSwapchainCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSwapchainKHR\n");;
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = m_vk->vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
                vkStream->write((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySwapchainKHR\n");;
                }
                m_vk->vkDestroySwapchainKHR(device, swapchain, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((uint32_t**)&pSwapchainImageCount, sizeof(uint32_t*));
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkImage**)&pSwapchainImages, sizeof(VkImage*));
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    vkReadStream->read((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainImagesKHR\n");;
                }
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = m_vk->vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
                vkStream->write((uint32_t**)&pSwapchainImageCount, sizeof(uint32_t*));
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                vkStream->write((VkImage**)&pSwapchainImages, sizeof(VkImage*));
                if (pSwapchainImages)
                {
                    vkStream->write((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                vkReadStream->read((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
                vkReadStream->read((VkFence*)&fence, sizeof(VkFence));
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireNextImageKHR\n");;
                }
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = m_vk->vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                VkQueue queue;
                VkPresentInfoKHR* pPresentInfo;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                unmarshal_VkPresentInfoKHR(vkReadStream, (VkPresentInfoKHR*)(pPresentInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueuePresentKHR\n");;
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = m_vk->vkQueuePresentKHR(queue, pPresentInfo);
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                unmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPresentCapabilitiesKHR\n");;
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = m_vk->vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkDeviceGroupPresentModeFlagsKHR**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR*));
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    vkReadStream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupSurfacePresentModesKHR\n");;
                }
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = m_vk->vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
                vkStream->write((VkDeviceGroupPresentModeFlagsKHR**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR*));
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->read((uint32_t**)&pRectCount, sizeof(uint32_t*));
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkRect2D**)&pRects, sizeof(VkRect2D*));
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDevicePresentRectanglesKHR\n");;
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = m_vk->vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
                vkStream->write((uint32_t**)&pRectCount, sizeof(uint32_t*));
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                vkStream->write((VkRect2D**)&pRects, sizeof(VkRect2D*));
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                VkDevice device;
                VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                unmarshal_VkAcquireNextImageInfoKHR(vkReadStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireNextImage2KHR\n");;
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = m_vk->vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayPropertiesKHR**)&pProperties, sizeof(VkDisplayPropertiesKHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPropertiesKHR(vkReadStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPropertiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayPropertiesKHR**)&pProperties, sizeof(VkDisplayPropertiesKHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayPlanePropertiesKHR**)&pProperties, sizeof(VkDisplayPlanePropertiesKHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPlanePropertiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayPlanePropertiesKHR**)&pProperties, sizeof(VkDisplayPlanePropertiesKHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t**)&pDisplayCount, sizeof(uint32_t*));
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayKHR**)&pDisplays, sizeof(VkDisplayKHR*));
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    vkReadStream->read((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneSupportedDisplaysKHR\n");;
                }
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = m_vk->vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
                vkStream->write((uint32_t**)&pDisplayCount, sizeof(uint32_t*));
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayKHR**)&pDisplays, sizeof(VkDisplayKHR*));
                if (pDisplays)
                {
                    vkStream->write((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayModePropertiesKHR**)&pProperties, sizeof(VkDisplayModePropertiesKHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModePropertiesKHR(vkReadStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayModePropertiesKHR\n");;
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = m_vk->vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayModePropertiesKHR**)&pProperties, sizeof(VkDisplayModePropertiesKHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                VkDisplayModeCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                unmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                vkReadStream->read((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDisplayModeKHR\n");;
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = m_vk->vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
                vkStream->write((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkDisplayModeKHR*)&mode, sizeof(VkDisplayModeKHR));
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                unmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneCapabilitiesKHR\n");;
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = m_vk->vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                VkInstance instance;
                VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                unmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDisplayPlaneSurfaceKHR\n");;
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = m_vk->vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                VkDevice device;
                uint32_t swapchainCount;
                VkSwapchainCreateInfoKHR* pCreateInfos;
                VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                }
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                vkReadStream->read((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSharedSwapchainsKHR\n");;
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = m_vk->vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                vkStream->write((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                VkInstance instance;
                VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                unmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateXlibSurfaceKHR\n");;
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = m_vk->vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->read((VisualID*)&visualID, sizeof(VisualID));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceXlibPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                VkInstance instance;
                VkXcbSurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
                unmarshal_VkXcbSurfaceCreateInfoKHR(vkReadStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateXcbSurfaceKHR\n");;
                }
                VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXcbSurfaceKHR_VkResult_return = m_vk->vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                xcb_connection_t* connection;
                xcb_visualid_t visual_id;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceXcbPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
                vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkStream->write(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                VkInstance instance;
                VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                unmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateWaylandSurfaceKHR\n");;
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = m_vk->vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                vkReadStream->read((wl_display*)display, sizeof(wl_display));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceWaylandPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_mir_surface
            case OP_vkCreateMirSurfaceKHR:
            {
                VkInstance instance;
                VkMirSurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
                unmarshal_VkMirSurfaceCreateInfoKHR(vkReadStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateMirSurfaceKHR\n");;
                }
                VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateMirSurfaceKHR_VkResult_return = m_vk->vkCreateMirSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMirPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                MirConnection* connection;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&connection, sizeof(MirConnection));
                vkReadStream->read((MirConnection*)connection, sizeof(MirConnection));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMirPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceMirPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection);
                vkStream->write((MirConnection*)connection, sizeof(MirConnection));
                vkStream->write(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                VkInstance instance;
                VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                unmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateAndroidSurfaceKHR\n");;
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = m_vk->vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                VkInstance instance;
                VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                unmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateWin32SurfaceKHR\n");;
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = m_vk->vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceWin32PresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPeerMemoryFeaturesKHR\n");;
                }
                m_vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDeviceMaskKHR\n");;
                }
                m_vk->vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchBaseKHR\n");;
                }
                m_vk->vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkTrimCommandPoolKHR\n");;
                }
                m_vk->vkTrimCommandPoolKHR(device, commandPool, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDeviceGroupsKHR\n");;
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = m_vk->vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkStream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalBufferPropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                VkDevice device;
                VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                unmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandleKHR\n");;
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = m_vk->vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((HANDLE*)&handle, sizeof(HANDLE));
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                unmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandlePropertiesKHR\n");;
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = m_vk->vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                VkDevice device;
                VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                unmarshal_VkMemoryGetFdInfoKHR(vkReadStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryFdKHR\n");;
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = m_vk->vkGetMemoryFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((int*)&fd, sizeof(int));
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                unmarshal_VkMemoryFdPropertiesKHR(vkReadStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryFdPropertiesKHR\n");;
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = m_vk->vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
                marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                unmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportSemaphoreWin32HandleKHR\n");;
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = m_vk->vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                unmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSemaphoreWin32HandleKHR\n");;
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = m_vk->vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                VkDevice device;
                VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                unmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportSemaphoreFdKHR\n");;
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_vk->vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                VkDevice device;
                VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                unmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSemaphoreFdKHR\n");;
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_vk->vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                VkWriteDescriptorSet* pDescriptorWrites;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                vkReadStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushDescriptorSetKHR\n");;
                }
                m_vk->vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                void* pData;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                vkReadStream->read((void**)&pData, sizeof(const void*));
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushDescriptorSetWithTemplateKHR\n");;
                }
                m_vk->vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplateKHR\n");;
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_vk->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplateKHR\n");;
                }
                m_vk->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                void* pData;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
                vkReadStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                vkReadStream->read((void**)&pData, sizeof(const void*));
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSetWithTemplateKHR\n");;
                }
                m_vk->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                VkDevice device;
                VkRenderPassCreateInfo2KHR* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
                unmarshal_VkRenderPassCreateInfo2KHR(vkReadStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                vkReadStream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateRenderPass2KHR\n");;
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = m_vk->vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginRenderPass2KHR\n");;
                }
                m_vk->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                VkSubpassEndInfoKHR* pSubpassEndInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdNextSubpass2KHR\n");;
                }
                m_vk->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassEndInfoKHR* pSubpassEndInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndRenderPass2KHR\n");;
                }
                m_vk->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainStatusKHR\n");;
                }
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = m_vk->vkGetSwapchainStatusKHR(device, swapchain);
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalFencePropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                VkDevice device;
                VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                unmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportFenceWin32HandleKHR\n");;
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = m_vk->vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                VkDevice device;
                VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                unmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceWin32HandleKHR\n");;
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = m_vk->vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                VkDevice device;
                VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                unmarshal_VkImportFenceFdInfoKHR(vkReadStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportFenceFdKHR\n");;
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = m_vk->vkImportFenceFdKHR(device, pImportFenceFdInfo);
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                VkDevice device;
                VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                unmarshal_VkFenceGetFdInfoKHR(vkReadStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceFdKHR\n");;
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = m_vk->vkGetFenceFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                unmarshal_VkSurfaceCapabilities2KHR(vkReadStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilities2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                vkReadStream->read((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSurfaceFormat2KHR**)&pSurfaceFormats, sizeof(VkSurfaceFormat2KHR*));
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormat2KHR(vkReadStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceFormats2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkStream->write((VkSurfaceFormat2KHR**)&pSurfaceFormats, sizeof(VkSurfaceFormat2KHR*));
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayProperties2KHR**)&pProperties, sizeof(VkDisplayProperties2KHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayProperties2KHR(vkReadStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayProperties2KHR**)&pProperties, sizeof(VkDisplayProperties2KHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayPlaneProperties2KHR**)&pProperties, sizeof(VkDisplayPlaneProperties2KHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPlaneProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayPlaneProperties2KHR**)&pProperties, sizeof(VkDisplayPlaneProperties2KHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                vkReadStream->read((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkDisplayModeProperties2KHR**)&pProperties, sizeof(VkDisplayModeProperties2KHR*));
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModeProperties2KHR(vkReadStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayModeProperties2KHR\n");;
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = m_vk->vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
                vkStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkStream->write((VkDisplayModeProperties2KHR**)&pProperties, sizeof(VkDisplayModeProperties2KHR*));
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                unmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                unmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneCapabilities2KHR\n");;
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = m_vk->vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                VkDevice device;
                VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                VkDevice device;
                VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                VkDevice device;
                VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->read((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkStream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                VkDevice device;
                VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkReadStream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSamplerYcbcrConversionKHR\n");;
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = m_vk->vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySamplerYcbcrConversionKHR\n");;
                }
                m_vk->vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                VkBindBufferMemoryInfo* pBindInfos;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2KHR\n");;
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_vk->vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                VkBindImageMemoryInfo* pBindInfos;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory2KHR\n");;
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = m_vk->vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                VkDevice device;
                VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDescriptorSetLayoutSupportKHR\n");;
                }
                m_vk->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirectCountKHR\n");;
                }
                m_vk->vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirectCountKHR\n");;
                }
                m_vk->vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                VkInstance instance;
                VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                unmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                vkReadStream->read((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDebugReportCallbackEXT\n");;
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = m_vk->vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
                vkStream->write((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkDebugReportCallbackEXT*)&callback, sizeof(VkDebugReportCallbackEXT));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDebugReportCallbackEXT\n");;
                }
                m_vk->vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                char* pLayerPrefix;
                char* pMessage;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
                vkReadStream->read((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
                vkReadStream->read((uint64_t*)&object, sizeof(uint64_t));
                vkReadStream->read((size_t*)&location, sizeof(size_t));
                vkReadStream->read((int32_t*)&messageCode, sizeof(int32_t));
                vkReadStream->loadStringInPlace((char**)&pLayerPrefix);
                vkReadStream->loadStringInPlace((char**)&pMessage);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugReportMessageEXT\n");;
                }
                m_vk->vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                VkDevice device;
                VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                unmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugMarkerSetObjectTagEXT\n");;
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = m_vk->vkDebugMarkerSetObjectTagEXT(device, pTagInfo);
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                VkDevice device;
                VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                unmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugMarkerSetObjectNameEXT\n");;
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = m_vk->vkDebugMarkerSetObjectNameEXT(device, pNameInfo);
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                VkCommandBuffer commandBuffer;
                VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerBeginEXT\n");;
                }
                m_vk->vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                VkCommandBuffer commandBuffer;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerEndEXT\n");;
                }
                m_vk->vkCmdDebugMarkerEndEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                VkCommandBuffer commandBuffer;
                VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerInsertEXT\n");;
                }
                m_vk->vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirectCountAMD\n");;
                }
                m_vk->vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirectCountAMD\n");;
                }
                m_vk->vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
                vkReadStream->read((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
                vkReadStream->read((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
                vkReadStream->read((size_t**)&pInfoSize, sizeof(size_t*));
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    vkReadStream->read((size_t*)pInfoSize, sizeof(size_t));
                }
                vkReadStream->read((void**)&pInfo, sizeof(void*));
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetShaderInfoAMD\n");;
                }
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = m_vk->vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                vkStream->write((size_t**)&pInfoSize, sizeof(size_t*));
                if (pInfoSize)
                {
                    vkStream->write((size_t*)pInfoSize, sizeof(size_t));
                }
                vkStream->write((void**)&pInfo, sizeof(void*));
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                unmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalImageFormatPropertiesNV\n");;
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = m_vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandleNV\n");;
                }
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = m_vk->vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                VkInstance instance;
                VkViSurfaceCreateInfoNN* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                unmarshal_VkViSurfaceCreateInfoNN(vkReadStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateViSurfaceNN\n");;
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = m_vk->vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                unmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginConditionalRenderingEXT\n");;
                }
                m_vk->vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndConditionalRenderingEXT\n");;
                }
                m_vk->vkCmdEndConditionalRenderingEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NVX_device_generated_commands
            case OP_vkCmdProcessCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
                unmarshal_VkCmdProcessCommandsInfoNVX(vkReadStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdProcessCommandsNVX\n");;
                }
                m_vk->vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdReserveSpaceForCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
                unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkReadStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdReserveSpaceForCommandsNVX\n");;
                }
                m_vk->vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
                unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkReadStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                vkReadStream->read((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateIndirectCommandsLayoutNVX\n");;
                }
                VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNVX_VkResult_return = m_vk->vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                vkStream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                vkStream->write(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                VkIndirectCommandsLayoutNVX indirectCommandsLayout;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyIndirectCommandsLayoutNVX\n");;
                }
                m_vk->vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateObjectTableNVX:
            {
                VkDevice device;
                VkObjectTableCreateInfoNVX* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkObjectTableNVX* pObjectTable;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
                unmarshal_VkObjectTableCreateInfoNVX(vkReadStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pObjectTable, sizeof(VkObjectTableNVX));
                vkReadStream->read((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateObjectTableNVX\n");;
                }
                VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
                vkCreateObjectTableNVX_VkResult_return = m_vk->vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable);
                vkStream->write((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
                vkStream->write(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyObjectTableNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyObjectTableNVX\n");;
                }
                m_vk->vkDestroyObjectTableNVX(device, objectTable, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                VkObjectTableEntryNVX** ppObjectTableEntries;
                uint32_t* pObjectIndices;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterObjectsNVX\n");;
                }
                VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
                vkRegisterObjectsNVX_VkResult_return = m_vk->vkRegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                vkStream->write(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUnregisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                VkObjectEntryTypeNVX* pObjectEntryTypes;
                uint32_t* pObjectIndices;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->read((VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUnregisterObjectsNVX\n");;
                }
                VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
                vkUnregisterObjectsNVX_VkResult_return = m_vk->vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                vkStream->write(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX:
            {
                VkPhysicalDevice physicalDevice;
                VkDeviceGeneratedCommandsFeaturesNVX* pFeatures;
                VkDeviceGeneratedCommandsLimitsNVX* pLimits;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
                unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkReadStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                vkReadStream->alloc((void**)&pLimits, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
                unmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkReadStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX\n");;
                }
                m_vk->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits);
                marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                VkViewportWScalingNV* pViewportWScalings;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewportWScalingNV(vkReadStream, (VkViewportWScalingNV*)(pViewportWScalings + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetViewportWScalingNV\n");;
                }
                m_vk->vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkReleaseDisplayEXT\n");;
                }
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = m_vk->vkReleaseDisplayEXT(physicalDevice, display);
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireXlibDisplayEXT\n");;
                }
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = m_vk->vkAcquireXlibDisplayEXT(physicalDevice, dpy, display);
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->read((RROutput*)&rrOutput, sizeof(RROutput));
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                vkReadStream->read((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRandROutputDisplayEXT\n");;
                }
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = m_vk->vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                unmarshal_VkSurfaceCapabilities2EXT(vkReadStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilities2EXT\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                unmarshal_VkDisplayPowerInfoEXT(vkReadStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDisplayPowerControlEXT\n");;
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = m_vk->vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                VkDevice device;
                VkDeviceEventInfoEXT* pDeviceEventInfo;
                VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                unmarshal_VkDeviceEventInfoEXT(vkReadStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                vkReadStream->read((VkFence*)pFence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterDeviceEventEXT\n");;
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = m_vk->vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
                vkStream->write((VkFence*)pFence, sizeof(VkFence));
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                VkDisplayEventInfoEXT* pDisplayEventInfo;
                VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                unmarshal_VkDisplayEventInfoEXT(vkReadStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                vkReadStream->read((VkFence*)pFence, sizeof(VkFence));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterDisplayEventEXT\n");;
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = m_vk->vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
                vkStream->write((VkFence*)pFence, sizeof(VkFence));
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                vkReadStream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainCounterEXT\n");;
                }
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = m_vk->vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                unmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRefreshCycleDurationGOOGLE\n");;
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = m_vk->vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
                vkReadStream->read((uint32_t**)&pPresentationTimingCount, sizeof(uint32_t*));
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, sizeof(VkPastPresentationTimingGOOGLE*));
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        unmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPastPresentationTimingGOOGLE\n");;
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = m_vk->vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
                vkStream->write((uint32_t**)&pPresentationTimingCount, sizeof(uint32_t*));
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                vkStream->write((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, sizeof(VkPastPresentationTimingGOOGLE*));
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                VkRect2D* pDiscardRectangles;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pDiscardRectangles + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDiscardRectangleEXT\n");;
                }
                m_vk->vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                VkDevice device;
                uint32_t swapchainCount;
                VkSwapchainKHR* pSwapchains;
                VkHdrMetadataEXT* pMetadata;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                vkReadStream->read((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkHdrMetadataEXT(vkReadStream, (VkHdrMetadataEXT*)(pMetadata + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetHdrMetadataEXT\n");;
                }
                m_vk->vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                VkInstance instance;
                VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                unmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateIOSSurfaceMVK\n");;
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = m_vk->vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                VkInstance instance;
                VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                unmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                vkReadStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateMacOSSurfaceMVK\n");;
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = m_vk->vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
                vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                VkDevice device;
                VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                unmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetDebugUtilsObjectNameEXT\n");;
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = m_vk->vkSetDebugUtilsObjectNameEXT(device, pNameInfo);
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                VkDevice device;
                VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                unmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetDebugUtilsObjectTagEXT\n");;
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = m_vk->vkSetDebugUtilsObjectTagEXT(device, pTagInfo);
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                VkQueue queue;
                VkDebugUtilsLabelEXT* pLabelInfo;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueBeginDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                VkQueue queue;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueEndDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueEndDebugUtilsLabelEXT(queue);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                VkQueue queue;
                VkDebugUtilsLabelEXT* pLabelInfo;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueInsertDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                VkDebugUtilsLabelEXT* pLabelInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdEndDebugUtilsLabelEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                VkDebugUtilsLabelEXT* pLabelInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdInsertDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                vkReadStream->read((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDebugUtilsMessengerEXT\n");;
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = m_vk->vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
                vkStream->write((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkDebugUtilsMessengerEXT*)&messenger, sizeof(VkDebugUtilsMessengerEXT));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDebugUtilsMessengerEXT\n");;
                }
                m_vk->vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                vkReadStream->read((VkInstance*)&instance, sizeof(VkInstance));
                vkReadStream->read((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                vkReadStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                unmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSubmitDebugUtilsMessageEXT\n");;
                }
                m_vk->vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                VkDevice device;
                AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                vkReadStream->read((AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                unmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetAndroidHardwareBufferPropertiesANDROID\n");;
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = m_vk->vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                VkDevice device;
                VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryAndroidHardwareBufferANDROID\n");;
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = m_vk->vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                VkCommandBuffer commandBuffer;
                VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                unmarshal_VkSampleLocationsInfoEXT(vkReadStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetSampleLocationsEXT\n");;
                }
                m_vk->vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                vkReadStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                unmarshal_VkMultisamplePropertiesEXT(vkReadStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMultisamplePropertiesEXT\n");;
                }
                m_vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
                marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                VkDevice device;
                VkValidationCacheCreateInfoEXT* pCreateInfo;
                VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                unmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                vkReadStream->read((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateValidationCacheEXT\n");;
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = m_vk->vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
                vkStream->write((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                VkAllocationCallbacks* pAllocator;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
                vkReadStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyValidationCacheEXT\n");;
                }
                m_vk->vkDestroyValidationCacheEXT(device, validationCache, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                VkValidationCacheEXT* pSrcCaches;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkValidationCacheEXT*)&dstCache, sizeof(VkValidationCacheEXT));
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                vkReadStream->read((VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMergeValidationCachesEXT\n");;
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = m_vk->vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
                vkReadStream->read((size_t**)&pDataSize, sizeof(size_t*));
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    vkReadStream->read((size_t*)pDataSize, sizeof(size_t));
                }
                vkReadStream->read((void**)&pData, sizeof(void*));
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetValidationCacheDataEXT\n");;
                }
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = m_vk->vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
                vkStream->write((size_t**)&pDataSize, sizeof(size_t*));
                if (pDataSize)
                {
                    vkStream->write((size_t*)pDataSize, sizeof(size_t));
                }
                vkStream->write((void**)&pData, sizeof(void*));
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                vkReadStream->read((VkDevice*)&device, sizeof(VkDevice));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((void**)&pHostPointer, sizeof(const void*));
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    vkReadStream->read((void*)pHostPointer, sizeof(const uint8_t));
                }
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                unmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryHostPointerPropertiesEXT\n");;
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = m_vk->vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                vkReadStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&marker, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWriteBufferMarkerAMD\n");;
                }
                m_vk->vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                VkCommandBuffer commandBuffer;
                void* pCheckpointMarker;
                vkReadStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
                vkReadStream->read((void**)&pCheckpointMarker, sizeof(const void*));
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    vkReadStream->read((void*)pCheckpointMarker, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetCheckpointNV\n");;
                }
                m_vk->vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                vkReadStream->read((VkQueue*)&queue, sizeof(VkQueue));
                vkReadStream->read((uint32_t**)&pCheckpointDataCount, sizeof(uint32_t*));
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                vkReadStream->read((VkCheckpointDataNV**)&pCheckpointData, sizeof(VkCheckpointDataNV*));
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        unmarshal_VkCheckpointDataNV(vkReadStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetQueueCheckpointDataNV\n");;
                }
                m_vk->vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
                vkStream->write((uint32_t**)&pCheckpointDataCount, sizeof(uint32_t*));
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                vkStream->write((VkCheckpointDataNV**)&pCheckpointData, sizeof(VkCheckpointDataNV*));
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
            default:
            {
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    return ptr - (unsigned char*)buf;;
}


