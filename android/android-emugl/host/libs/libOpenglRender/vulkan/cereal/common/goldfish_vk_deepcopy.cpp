// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_deepcopy
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_deepcopy.h"



namespace goldfish_vk {

#ifdef VK_VERSION_1_0
void deepcopy_VkApplicationInfo(
    Pool* pool,
    const VkApplicationInfo* from,
    VkApplicationInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pApplicationName = nullptr;
    if (from->pApplicationName)
    {
        to->pApplicationName = pool->strDup(from->pApplicationName);
    }
    to->applicationVersion = from->applicationVersion;
    to->pEngineName = nullptr;
    if (from->pEngineName)
    {
        to->pEngineName = pool->strDup(from->pEngineName);
    }
    to->engineVersion = from->engineVersion;
    to->apiVersion = from->apiVersion;
}

void deepcopy_VkInstanceCreateInfo(
    Pool* pool,
    const VkInstanceCreateInfo* from,
    VkInstanceCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pApplicationInfo = nullptr;
    if (from->pApplicationInfo)
    {
        to->pApplicationInfo = (VkApplicationInfo*)pool->alloc(sizeof(const VkApplicationInfo));
        deepcopy_VkApplicationInfo(pool, from->pApplicationInfo, (VkApplicationInfo*)(to->pApplicationInfo));
    }
    to->enabledLayerCount = from->enabledLayerCount;
    to->ppEnabledLayerNames = nullptr;
    if (from->ppEnabledLayerNames && from->enabledLayerCount)
    {
        to->ppEnabledLayerNames = pool->strDupArray(from->ppEnabledLayerNames, from->enabledLayerCount);
    }
    to->enabledExtensionCount = from->enabledExtensionCount;
    to->ppEnabledExtensionNames = nullptr;
    if (from->ppEnabledExtensionNames && from->enabledExtensionCount)
    {
        to->ppEnabledExtensionNames = pool->strDupArray(from->ppEnabledExtensionNames, from->enabledExtensionCount);
    }
}

void deepcopy_VkAllocationCallbacks(
    Pool* pool,
    const VkAllocationCallbacks* from,
    VkAllocationCallbacks* to)
{
    to->pUserData = nullptr;
    if (from->pUserData)
    {
        to->pUserData = (void*)pool->dupArray(from->pUserData, sizeof(uint8_t));
    }
    to->pfnAllocation = from->pfnAllocation;
    to->pfnReallocation = from->pfnReallocation;
    to->pfnFree = from->pfnFree;
    to->pfnInternalAllocation = from->pfnInternalAllocation;
    to->pfnInternalFree = from->pfnInternalFree;
}

void deepcopy_VkPhysicalDeviceFeatures(
    Pool* pool,
    const VkPhysicalDeviceFeatures* from,
    VkPhysicalDeviceFeatures* to)
{
    to->robustBufferAccess = from->robustBufferAccess;
    to->fullDrawIndexUint32 = from->fullDrawIndexUint32;
    to->imageCubeArray = from->imageCubeArray;
    to->independentBlend = from->independentBlend;
    to->geometryShader = from->geometryShader;
    to->tessellationShader = from->tessellationShader;
    to->sampleRateShading = from->sampleRateShading;
    to->dualSrcBlend = from->dualSrcBlend;
    to->logicOp = from->logicOp;
    to->multiDrawIndirect = from->multiDrawIndirect;
    to->drawIndirectFirstInstance = from->drawIndirectFirstInstance;
    to->depthClamp = from->depthClamp;
    to->depthBiasClamp = from->depthBiasClamp;
    to->fillModeNonSolid = from->fillModeNonSolid;
    to->depthBounds = from->depthBounds;
    to->wideLines = from->wideLines;
    to->largePoints = from->largePoints;
    to->alphaToOne = from->alphaToOne;
    to->multiViewport = from->multiViewport;
    to->samplerAnisotropy = from->samplerAnisotropy;
    to->textureCompressionETC2 = from->textureCompressionETC2;
    to->textureCompressionASTC_LDR = from->textureCompressionASTC_LDR;
    to->textureCompressionBC = from->textureCompressionBC;
    to->occlusionQueryPrecise = from->occlusionQueryPrecise;
    to->pipelineStatisticsQuery = from->pipelineStatisticsQuery;
    to->vertexPipelineStoresAndAtomics = from->vertexPipelineStoresAndAtomics;
    to->fragmentStoresAndAtomics = from->fragmentStoresAndAtomics;
    to->shaderTessellationAndGeometryPointSize = from->shaderTessellationAndGeometryPointSize;
    to->shaderImageGatherExtended = from->shaderImageGatherExtended;
    to->shaderStorageImageExtendedFormats = from->shaderStorageImageExtendedFormats;
    to->shaderStorageImageMultisample = from->shaderStorageImageMultisample;
    to->shaderStorageImageReadWithoutFormat = from->shaderStorageImageReadWithoutFormat;
    to->shaderStorageImageWriteWithoutFormat = from->shaderStorageImageWriteWithoutFormat;
    to->shaderUniformBufferArrayDynamicIndexing = from->shaderUniformBufferArrayDynamicIndexing;
    to->shaderSampledImageArrayDynamicIndexing = from->shaderSampledImageArrayDynamicIndexing;
    to->shaderStorageBufferArrayDynamicIndexing = from->shaderStorageBufferArrayDynamicIndexing;
    to->shaderStorageImageArrayDynamicIndexing = from->shaderStorageImageArrayDynamicIndexing;
    to->shaderClipDistance = from->shaderClipDistance;
    to->shaderCullDistance = from->shaderCullDistance;
    to->shaderFloat64 = from->shaderFloat64;
    to->shaderInt64 = from->shaderInt64;
    to->shaderInt16 = from->shaderInt16;
    to->shaderResourceResidency = from->shaderResourceResidency;
    to->shaderResourceMinLod = from->shaderResourceMinLod;
    to->sparseBinding = from->sparseBinding;
    to->sparseResidencyBuffer = from->sparseResidencyBuffer;
    to->sparseResidencyImage2D = from->sparseResidencyImage2D;
    to->sparseResidencyImage3D = from->sparseResidencyImage3D;
    to->sparseResidency2Samples = from->sparseResidency2Samples;
    to->sparseResidency4Samples = from->sparseResidency4Samples;
    to->sparseResidency8Samples = from->sparseResidency8Samples;
    to->sparseResidency16Samples = from->sparseResidency16Samples;
    to->sparseResidencyAliased = from->sparseResidencyAliased;
    to->variableMultisampleRate = from->variableMultisampleRate;
    to->inheritedQueries = from->inheritedQueries;
}

void deepcopy_VkFormatProperties(
    Pool* pool,
    const VkFormatProperties* from,
    VkFormatProperties* to)
{
    to->linearTilingFeatures = from->linearTilingFeatures;
    to->optimalTilingFeatures = from->optimalTilingFeatures;
    to->bufferFeatures = from->bufferFeatures;
}

void deepcopy_VkExtent3D(
    Pool* pool,
    const VkExtent3D* from,
    VkExtent3D* to)
{
    to->width = from->width;
    to->height = from->height;
    to->depth = from->depth;
}

void deepcopy_VkImageFormatProperties(
    Pool* pool,
    const VkImageFormatProperties* from,
    VkImageFormatProperties* to)
{
    deepcopy_VkExtent3D(pool, &from->maxExtent, (VkExtent3D*)(&to->maxExtent));
    to->maxMipLevels = from->maxMipLevels;
    to->maxArrayLayers = from->maxArrayLayers;
    to->sampleCounts = from->sampleCounts;
    to->maxResourceSize = from->maxResourceSize;
}

void deepcopy_VkPhysicalDeviceLimits(
    Pool* pool,
    const VkPhysicalDeviceLimits* from,
    VkPhysicalDeviceLimits* to)
{
    to->maxImageDimension1D = from->maxImageDimension1D;
    to->maxImageDimension2D = from->maxImageDimension2D;
    to->maxImageDimension3D = from->maxImageDimension3D;
    to->maxImageDimensionCube = from->maxImageDimensionCube;
    to->maxImageArrayLayers = from->maxImageArrayLayers;
    to->maxTexelBufferElements = from->maxTexelBufferElements;
    to->maxUniformBufferRange = from->maxUniformBufferRange;
    to->maxStorageBufferRange = from->maxStorageBufferRange;
    to->maxPushConstantsSize = from->maxPushConstantsSize;
    to->maxMemoryAllocationCount = from->maxMemoryAllocationCount;
    to->maxSamplerAllocationCount = from->maxSamplerAllocationCount;
    to->bufferImageGranularity = from->bufferImageGranularity;
    to->sparseAddressSpaceSize = from->sparseAddressSpaceSize;
    to->maxBoundDescriptorSets = from->maxBoundDescriptorSets;
    to->maxPerStageDescriptorSamplers = from->maxPerStageDescriptorSamplers;
    to->maxPerStageDescriptorUniformBuffers = from->maxPerStageDescriptorUniformBuffers;
    to->maxPerStageDescriptorStorageBuffers = from->maxPerStageDescriptorStorageBuffers;
    to->maxPerStageDescriptorSampledImages = from->maxPerStageDescriptorSampledImages;
    to->maxPerStageDescriptorStorageImages = from->maxPerStageDescriptorStorageImages;
    to->maxPerStageDescriptorInputAttachments = from->maxPerStageDescriptorInputAttachments;
    to->maxPerStageResources = from->maxPerStageResources;
    to->maxDescriptorSetSamplers = from->maxDescriptorSetSamplers;
    to->maxDescriptorSetUniformBuffers = from->maxDescriptorSetUniformBuffers;
    to->maxDescriptorSetUniformBuffersDynamic = from->maxDescriptorSetUniformBuffersDynamic;
    to->maxDescriptorSetStorageBuffers = from->maxDescriptorSetStorageBuffers;
    to->maxDescriptorSetStorageBuffersDynamic = from->maxDescriptorSetStorageBuffersDynamic;
    to->maxDescriptorSetSampledImages = from->maxDescriptorSetSampledImages;
    to->maxDescriptorSetStorageImages = from->maxDescriptorSetStorageImages;
    to->maxDescriptorSetInputAttachments = from->maxDescriptorSetInputAttachments;
    to->maxVertexInputAttributes = from->maxVertexInputAttributes;
    to->maxVertexInputBindings = from->maxVertexInputBindings;
    to->maxVertexInputAttributeOffset = from->maxVertexInputAttributeOffset;
    to->maxVertexInputBindingStride = from->maxVertexInputBindingStride;
    to->maxVertexOutputComponents = from->maxVertexOutputComponents;
    to->maxTessellationGenerationLevel = from->maxTessellationGenerationLevel;
    to->maxTessellationPatchSize = from->maxTessellationPatchSize;
    to->maxTessellationControlPerVertexInputComponents = from->maxTessellationControlPerVertexInputComponents;
    to->maxTessellationControlPerVertexOutputComponents = from->maxTessellationControlPerVertexOutputComponents;
    to->maxTessellationControlPerPatchOutputComponents = from->maxTessellationControlPerPatchOutputComponents;
    to->maxTessellationControlTotalOutputComponents = from->maxTessellationControlTotalOutputComponents;
    to->maxTessellationEvaluationInputComponents = from->maxTessellationEvaluationInputComponents;
    to->maxTessellationEvaluationOutputComponents = from->maxTessellationEvaluationOutputComponents;
    to->maxGeometryShaderInvocations = from->maxGeometryShaderInvocations;
    to->maxGeometryInputComponents = from->maxGeometryInputComponents;
    to->maxGeometryOutputComponents = from->maxGeometryOutputComponents;
    to->maxGeometryOutputVertices = from->maxGeometryOutputVertices;
    to->maxGeometryTotalOutputComponents = from->maxGeometryTotalOutputComponents;
    to->maxFragmentInputComponents = from->maxFragmentInputComponents;
    to->maxFragmentOutputAttachments = from->maxFragmentOutputAttachments;
    to->maxFragmentDualSrcAttachments = from->maxFragmentDualSrcAttachments;
    to->maxFragmentCombinedOutputResources = from->maxFragmentCombinedOutputResources;
    to->maxComputeSharedMemorySize = from->maxComputeSharedMemorySize;
    memcpy(to->maxComputeWorkGroupCount, from->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    to->maxComputeWorkGroupInvocations = from->maxComputeWorkGroupInvocations;
    memcpy(to->maxComputeWorkGroupSize, from->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    to->subPixelPrecisionBits = from->subPixelPrecisionBits;
    to->subTexelPrecisionBits = from->subTexelPrecisionBits;
    to->mipmapPrecisionBits = from->mipmapPrecisionBits;
    to->maxDrawIndexedIndexValue = from->maxDrawIndexedIndexValue;
    to->maxDrawIndirectCount = from->maxDrawIndirectCount;
    to->maxSamplerLodBias = from->maxSamplerLodBias;
    to->maxSamplerAnisotropy = from->maxSamplerAnisotropy;
    to->maxViewports = from->maxViewports;
    memcpy(to->maxViewportDimensions, from->maxViewportDimensions, 2 * sizeof(uint32_t));
    memcpy(to->viewportBoundsRange, from->viewportBoundsRange, 2 * sizeof(float));
    to->viewportSubPixelBits = from->viewportSubPixelBits;
    to->minMemoryMapAlignment = from->minMemoryMapAlignment;
    to->minTexelBufferOffsetAlignment = from->minTexelBufferOffsetAlignment;
    to->minUniformBufferOffsetAlignment = from->minUniformBufferOffsetAlignment;
    to->minStorageBufferOffsetAlignment = from->minStorageBufferOffsetAlignment;
    to->minTexelOffset = from->minTexelOffset;
    to->maxTexelOffset = from->maxTexelOffset;
    to->minTexelGatherOffset = from->minTexelGatherOffset;
    to->maxTexelGatherOffset = from->maxTexelGatherOffset;
    to->minInterpolationOffset = from->minInterpolationOffset;
    to->maxInterpolationOffset = from->maxInterpolationOffset;
    to->subPixelInterpolationOffsetBits = from->subPixelInterpolationOffsetBits;
    to->maxFramebufferWidth = from->maxFramebufferWidth;
    to->maxFramebufferHeight = from->maxFramebufferHeight;
    to->maxFramebufferLayers = from->maxFramebufferLayers;
    to->framebufferColorSampleCounts = from->framebufferColorSampleCounts;
    to->framebufferDepthSampleCounts = from->framebufferDepthSampleCounts;
    to->framebufferStencilSampleCounts = from->framebufferStencilSampleCounts;
    to->framebufferNoAttachmentsSampleCounts = from->framebufferNoAttachmentsSampleCounts;
    to->maxColorAttachments = from->maxColorAttachments;
    to->sampledImageColorSampleCounts = from->sampledImageColorSampleCounts;
    to->sampledImageIntegerSampleCounts = from->sampledImageIntegerSampleCounts;
    to->sampledImageDepthSampleCounts = from->sampledImageDepthSampleCounts;
    to->sampledImageStencilSampleCounts = from->sampledImageStencilSampleCounts;
    to->storageImageSampleCounts = from->storageImageSampleCounts;
    to->maxSampleMaskWords = from->maxSampleMaskWords;
    to->timestampComputeAndGraphics = from->timestampComputeAndGraphics;
    to->timestampPeriod = from->timestampPeriod;
    to->maxClipDistances = from->maxClipDistances;
    to->maxCullDistances = from->maxCullDistances;
    to->maxCombinedClipAndCullDistances = from->maxCombinedClipAndCullDistances;
    to->discreteQueuePriorities = from->discreteQueuePriorities;
    memcpy(to->pointSizeRange, from->pointSizeRange, 2 * sizeof(float));
    memcpy(to->lineWidthRange, from->lineWidthRange, 2 * sizeof(float));
    to->pointSizeGranularity = from->pointSizeGranularity;
    to->lineWidthGranularity = from->lineWidthGranularity;
    to->strictLines = from->strictLines;
    to->standardSampleLocations = from->standardSampleLocations;
    to->optimalBufferCopyOffsetAlignment = from->optimalBufferCopyOffsetAlignment;
    to->optimalBufferCopyRowPitchAlignment = from->optimalBufferCopyRowPitchAlignment;
    to->nonCoherentAtomSize = from->nonCoherentAtomSize;
}

void deepcopy_VkPhysicalDeviceSparseProperties(
    Pool* pool,
    const VkPhysicalDeviceSparseProperties* from,
    VkPhysicalDeviceSparseProperties* to)
{
    to->residencyStandard2DBlockShape = from->residencyStandard2DBlockShape;
    to->residencyStandard2DMultisampleBlockShape = from->residencyStandard2DMultisampleBlockShape;
    to->residencyStandard3DBlockShape = from->residencyStandard3DBlockShape;
    to->residencyAlignedMipSize = from->residencyAlignedMipSize;
    to->residencyNonResidentStrict = from->residencyNonResidentStrict;
}

void deepcopy_VkPhysicalDeviceProperties(
    Pool* pool,
    const VkPhysicalDeviceProperties* from,
    VkPhysicalDeviceProperties* to)
{
    to->apiVersion = from->apiVersion;
    to->driverVersion = from->driverVersion;
    to->vendorID = from->vendorID;
    to->deviceID = from->deviceID;
    to->deviceType = from->deviceType;
    memcpy(to->deviceName, from->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    memcpy(to->pipelineCacheUUID, from->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    deepcopy_VkPhysicalDeviceLimits(pool, &from->limits, (VkPhysicalDeviceLimits*)(&to->limits));
    deepcopy_VkPhysicalDeviceSparseProperties(pool, &from->sparseProperties, (VkPhysicalDeviceSparseProperties*)(&to->sparseProperties));
}

void deepcopy_VkQueueFamilyProperties(
    Pool* pool,
    const VkQueueFamilyProperties* from,
    VkQueueFamilyProperties* to)
{
    to->queueFlags = from->queueFlags;
    to->queueCount = from->queueCount;
    to->timestampValidBits = from->timestampValidBits;
    deepcopy_VkExtent3D(pool, &from->minImageTransferGranularity, (VkExtent3D*)(&to->minImageTransferGranularity));
}

void deepcopy_VkMemoryType(
    Pool* pool,
    const VkMemoryType* from,
    VkMemoryType* to)
{
    to->propertyFlags = from->propertyFlags;
    to->heapIndex = from->heapIndex;
}

void deepcopy_VkMemoryHeap(
    Pool* pool,
    const VkMemoryHeap* from,
    VkMemoryHeap* to)
{
    to->size = from->size;
    to->flags = from->flags;
}

void deepcopy_VkPhysicalDeviceMemoryProperties(
    Pool* pool,
    const VkPhysicalDeviceMemoryProperties* from,
    VkPhysicalDeviceMemoryProperties* to)
{
    to->memoryTypeCount = from->memoryTypeCount;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        deepcopy_VkMemoryType(pool, from->memoryTypes + i, (VkMemoryType*)(to->memoryTypes + i));
    }
    to->memoryHeapCount = from->memoryHeapCount;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        deepcopy_VkMemoryHeap(pool, from->memoryHeaps + i, (VkMemoryHeap*)(to->memoryHeaps + i));
    }
}

void deepcopy_VkDeviceQueueCreateInfo(
    Pool* pool,
    const VkDeviceQueueCreateInfo* from,
    VkDeviceQueueCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->queueFamilyIndex = from->queueFamilyIndex;
    to->queueCount = from->queueCount;
    to->pQueuePriorities = nullptr;
    if (from->pQueuePriorities)
    {
        to->pQueuePriorities = (float*)pool->dupArray(from->pQueuePriorities, from->queueCount * sizeof(const float));
    }
}

void deepcopy_VkDeviceCreateInfo(
    Pool* pool,
    const VkDeviceCreateInfo* from,
    VkDeviceCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->queueCreateInfoCount = from->queueCreateInfoCount;
    to->pQueueCreateInfos = nullptr;
    if (from->pQueueCreateInfos)
    {
        to->pQueueCreateInfos = (VkDeviceQueueCreateInfo*)pool->alloc(from->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
        to->queueCreateInfoCount = from->queueCreateInfoCount;
        for (uint32_t i = 0; i < (uint32_t)from->queueCreateInfoCount; ++i)
        {
            deepcopy_VkDeviceQueueCreateInfo(pool, from->pQueueCreateInfos + i, (VkDeviceQueueCreateInfo*)(to->pQueueCreateInfos + i));
        }
    }
    to->enabledLayerCount = from->enabledLayerCount;
    to->ppEnabledLayerNames = nullptr;
    if (from->ppEnabledLayerNames && from->enabledLayerCount)
    {
        to->ppEnabledLayerNames = pool->strDupArray(from->ppEnabledLayerNames, from->enabledLayerCount);
    }
    to->enabledExtensionCount = from->enabledExtensionCount;
    to->ppEnabledExtensionNames = nullptr;
    if (from->ppEnabledExtensionNames && from->enabledExtensionCount)
    {
        to->ppEnabledExtensionNames = pool->strDupArray(from->ppEnabledExtensionNames, from->enabledExtensionCount);
    }
    to->pEnabledFeatures = nullptr;
    if (from->pEnabledFeatures)
    {
        to->pEnabledFeatures = (VkPhysicalDeviceFeatures*)pool->alloc(sizeof(const VkPhysicalDeviceFeatures));
        deepcopy_VkPhysicalDeviceFeatures(pool, from->pEnabledFeatures, (VkPhysicalDeviceFeatures*)(to->pEnabledFeatures));
    }
}

void deepcopy_VkExtensionProperties(
    Pool* pool,
    const VkExtensionProperties* from,
    VkExtensionProperties* to)
{
    memcpy(to->extensionName, from->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    to->specVersion = from->specVersion;
}

void deepcopy_VkLayerProperties(
    Pool* pool,
    const VkLayerProperties* from,
    VkLayerProperties* to)
{
    memcpy(to->layerName, from->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    to->specVersion = from->specVersion;
    to->implementationVersion = from->implementationVersion;
    memcpy(to->description, from->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void deepcopy_VkSubmitInfo(
    Pool* pool,
    const VkSubmitInfo* from,
    VkSubmitInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->waitSemaphoreCount = from->waitSemaphoreCount;
    to->pWaitSemaphores = nullptr;
    if (from->pWaitSemaphores)
    {
        to->pWaitSemaphores = (VkSemaphore*)pool->dupArray(from->pWaitSemaphores, from->waitSemaphoreCount * sizeof(const VkSemaphore));
    }
    to->pWaitDstStageMask = nullptr;
    if (from->pWaitDstStageMask)
    {
        to->pWaitDstStageMask = (VkPipelineStageFlags*)pool->dupArray(from->pWaitDstStageMask, from->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    }
    to->commandBufferCount = from->commandBufferCount;
    to->pCommandBuffers = nullptr;
    if (from->pCommandBuffers)
    {
        to->pCommandBuffers = (VkCommandBuffer*)pool->dupArray(from->pCommandBuffers, from->commandBufferCount * sizeof(const VkCommandBuffer));
    }
    to->signalSemaphoreCount = from->signalSemaphoreCount;
    to->pSignalSemaphores = nullptr;
    if (from->pSignalSemaphores)
    {
        to->pSignalSemaphores = (VkSemaphore*)pool->dupArray(from->pSignalSemaphores, from->signalSemaphoreCount * sizeof(const VkSemaphore));
    }
}

void deepcopy_VkMemoryAllocateInfo(
    Pool* pool,
    const VkMemoryAllocateInfo* from,
    VkMemoryAllocateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->allocationSize = from->allocationSize;
    to->memoryTypeIndex = from->memoryTypeIndex;
}

void deepcopy_VkMappedMemoryRange(
    Pool* pool,
    const VkMappedMemoryRange* from,
    VkMappedMemoryRange* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memory = from->memory;
    to->offset = from->offset;
    to->size = from->size;
}

void deepcopy_VkMemoryRequirements(
    Pool* pool,
    const VkMemoryRequirements* from,
    VkMemoryRequirements* to)
{
    to->size = from->size;
    to->alignment = from->alignment;
    to->memoryTypeBits = from->memoryTypeBits;
}

void deepcopy_VkSparseImageFormatProperties(
    Pool* pool,
    const VkSparseImageFormatProperties* from,
    VkSparseImageFormatProperties* to)
{
    to->aspectMask = from->aspectMask;
    deepcopy_VkExtent3D(pool, &from->imageGranularity, (VkExtent3D*)(&to->imageGranularity));
    to->flags = from->flags;
}

void deepcopy_VkSparseImageMemoryRequirements(
    Pool* pool,
    const VkSparseImageMemoryRequirements* from,
    VkSparseImageMemoryRequirements* to)
{
    deepcopy_VkSparseImageFormatProperties(pool, &from->formatProperties, (VkSparseImageFormatProperties*)(&to->formatProperties));
    to->imageMipTailFirstLod = from->imageMipTailFirstLod;
    to->imageMipTailSize = from->imageMipTailSize;
    to->imageMipTailOffset = from->imageMipTailOffset;
    to->imageMipTailStride = from->imageMipTailStride;
}

void deepcopy_VkSparseMemoryBind(
    Pool* pool,
    const VkSparseMemoryBind* from,
    VkSparseMemoryBind* to)
{
    to->resourceOffset = from->resourceOffset;
    to->size = from->size;
    to->memory = from->memory;
    to->memoryOffset = from->memoryOffset;
    to->flags = from->flags;
}

void deepcopy_VkSparseBufferMemoryBindInfo(
    Pool* pool,
    const VkSparseBufferMemoryBindInfo* from,
    VkSparseBufferMemoryBindInfo* to)
{
    to->buffer = from->buffer;
    to->bindCount = from->bindCount;
    to->pBinds = nullptr;
    if (from->pBinds)
    {
        to->pBinds = (VkSparseMemoryBind*)pool->alloc(from->bindCount * sizeof(const VkSparseMemoryBind));
        to->bindCount = from->bindCount;
        for (uint32_t i = 0; i < (uint32_t)from->bindCount; ++i)
        {
            deepcopy_VkSparseMemoryBind(pool, from->pBinds + i, (VkSparseMemoryBind*)(to->pBinds + i));
        }
    }
}

void deepcopy_VkSparseImageOpaqueMemoryBindInfo(
    Pool* pool,
    const VkSparseImageOpaqueMemoryBindInfo* from,
    VkSparseImageOpaqueMemoryBindInfo* to)
{
    to->image = from->image;
    to->bindCount = from->bindCount;
    to->pBinds = nullptr;
    if (from->pBinds)
    {
        to->pBinds = (VkSparseMemoryBind*)pool->alloc(from->bindCount * sizeof(const VkSparseMemoryBind));
        to->bindCount = from->bindCount;
        for (uint32_t i = 0; i < (uint32_t)from->bindCount; ++i)
        {
            deepcopy_VkSparseMemoryBind(pool, from->pBinds + i, (VkSparseMemoryBind*)(to->pBinds + i));
        }
    }
}

void deepcopy_VkImageSubresource(
    Pool* pool,
    const VkImageSubresource* from,
    VkImageSubresource* to)
{
    to->aspectMask = from->aspectMask;
    to->mipLevel = from->mipLevel;
    to->arrayLayer = from->arrayLayer;
}

void deepcopy_VkOffset3D(
    Pool* pool,
    const VkOffset3D* from,
    VkOffset3D* to)
{
    to->x = from->x;
    to->y = from->y;
    to->z = from->z;
}

void deepcopy_VkSparseImageMemoryBind(
    Pool* pool,
    const VkSparseImageMemoryBind* from,
    VkSparseImageMemoryBind* to)
{
    deepcopy_VkImageSubresource(pool, &from->subresource, (VkImageSubresource*)(&to->subresource));
    deepcopy_VkOffset3D(pool, &from->offset, (VkOffset3D*)(&to->offset));
    deepcopy_VkExtent3D(pool, &from->extent, (VkExtent3D*)(&to->extent));
    to->memory = from->memory;
    to->memoryOffset = from->memoryOffset;
    to->flags = from->flags;
}

void deepcopy_VkSparseImageMemoryBindInfo(
    Pool* pool,
    const VkSparseImageMemoryBindInfo* from,
    VkSparseImageMemoryBindInfo* to)
{
    to->image = from->image;
    to->bindCount = from->bindCount;
    to->pBinds = nullptr;
    if (from->pBinds)
    {
        to->pBinds = (VkSparseImageMemoryBind*)pool->alloc(from->bindCount * sizeof(const VkSparseImageMemoryBind));
        to->bindCount = from->bindCount;
        for (uint32_t i = 0; i < (uint32_t)from->bindCount; ++i)
        {
            deepcopy_VkSparseImageMemoryBind(pool, from->pBinds + i, (VkSparseImageMemoryBind*)(to->pBinds + i));
        }
    }
}

void deepcopy_VkBindSparseInfo(
    Pool* pool,
    const VkBindSparseInfo* from,
    VkBindSparseInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->waitSemaphoreCount = from->waitSemaphoreCount;
    to->pWaitSemaphores = nullptr;
    if (from->pWaitSemaphores)
    {
        to->pWaitSemaphores = (VkSemaphore*)pool->dupArray(from->pWaitSemaphores, from->waitSemaphoreCount * sizeof(const VkSemaphore));
    }
    to->bufferBindCount = from->bufferBindCount;
    to->pBufferBinds = nullptr;
    if (from->pBufferBinds)
    {
        to->pBufferBinds = (VkSparseBufferMemoryBindInfo*)pool->alloc(from->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
        to->bufferBindCount = from->bufferBindCount;
        for (uint32_t i = 0; i < (uint32_t)from->bufferBindCount; ++i)
        {
            deepcopy_VkSparseBufferMemoryBindInfo(pool, from->pBufferBinds + i, (VkSparseBufferMemoryBindInfo*)(to->pBufferBinds + i));
        }
    }
    to->imageOpaqueBindCount = from->imageOpaqueBindCount;
    to->pImageOpaqueBinds = nullptr;
    if (from->pImageOpaqueBinds)
    {
        to->pImageOpaqueBinds = (VkSparseImageOpaqueMemoryBindInfo*)pool->alloc(from->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
        to->imageOpaqueBindCount = from->imageOpaqueBindCount;
        for (uint32_t i = 0; i < (uint32_t)from->imageOpaqueBindCount; ++i)
        {
            deepcopy_VkSparseImageOpaqueMemoryBindInfo(pool, from->pImageOpaqueBinds + i, (VkSparseImageOpaqueMemoryBindInfo*)(to->pImageOpaqueBinds + i));
        }
    }
    to->imageBindCount = from->imageBindCount;
    to->pImageBinds = nullptr;
    if (from->pImageBinds)
    {
        to->pImageBinds = (VkSparseImageMemoryBindInfo*)pool->alloc(from->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
        to->imageBindCount = from->imageBindCount;
        for (uint32_t i = 0; i < (uint32_t)from->imageBindCount; ++i)
        {
            deepcopy_VkSparseImageMemoryBindInfo(pool, from->pImageBinds + i, (VkSparseImageMemoryBindInfo*)(to->pImageBinds + i));
        }
    }
    to->signalSemaphoreCount = from->signalSemaphoreCount;
    to->pSignalSemaphores = nullptr;
    if (from->pSignalSemaphores)
    {
        to->pSignalSemaphores = (VkSemaphore*)pool->dupArray(from->pSignalSemaphores, from->signalSemaphoreCount * sizeof(const VkSemaphore));
    }
}

void deepcopy_VkFenceCreateInfo(
    Pool* pool,
    const VkFenceCreateInfo* from,
    VkFenceCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
}

void deepcopy_VkSemaphoreCreateInfo(
    Pool* pool,
    const VkSemaphoreCreateInfo* from,
    VkSemaphoreCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
}

void deepcopy_VkEventCreateInfo(
    Pool* pool,
    const VkEventCreateInfo* from,
    VkEventCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
}

void deepcopy_VkQueryPoolCreateInfo(
    Pool* pool,
    const VkQueryPoolCreateInfo* from,
    VkQueryPoolCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->queryType = from->queryType;
    to->queryCount = from->queryCount;
    to->pipelineStatistics = from->pipelineStatistics;
}

void deepcopy_VkBufferCreateInfo(
    Pool* pool,
    const VkBufferCreateInfo* from,
    VkBufferCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->size = from->size;
    to->usage = from->usage;
    to->sharingMode = from->sharingMode;
    to->queueFamilyIndexCount = from->queueFamilyIndexCount;
    to->pQueueFamilyIndices = nullptr;
    if (from->pQueueFamilyIndices)
    {
        to->pQueueFamilyIndices = (uint32_t*)pool->dupArray(from->pQueueFamilyIndices, from->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkBufferViewCreateInfo(
    Pool* pool,
    const VkBufferViewCreateInfo* from,
    VkBufferViewCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->buffer = from->buffer;
    to->format = from->format;
    to->offset = from->offset;
    to->range = from->range;
}

void deepcopy_VkImageCreateInfo(
    Pool* pool,
    const VkImageCreateInfo* from,
    VkImageCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->imageType = from->imageType;
    to->format = from->format;
    deepcopy_VkExtent3D(pool, &from->extent, (VkExtent3D*)(&to->extent));
    to->mipLevels = from->mipLevels;
    to->arrayLayers = from->arrayLayers;
    to->samples = from->samples;
    to->tiling = from->tiling;
    to->usage = from->usage;
    to->sharingMode = from->sharingMode;
    to->queueFamilyIndexCount = from->queueFamilyIndexCount;
    to->pQueueFamilyIndices = nullptr;
    if (from->pQueueFamilyIndices)
    {
        to->pQueueFamilyIndices = (uint32_t*)pool->dupArray(from->pQueueFamilyIndices, from->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    to->initialLayout = from->initialLayout;
}

void deepcopy_VkSubresourceLayout(
    Pool* pool,
    const VkSubresourceLayout* from,
    VkSubresourceLayout* to)
{
    to->offset = from->offset;
    to->size = from->size;
    to->rowPitch = from->rowPitch;
    to->arrayPitch = from->arrayPitch;
    to->depthPitch = from->depthPitch;
}

void deepcopy_VkComponentMapping(
    Pool* pool,
    const VkComponentMapping* from,
    VkComponentMapping* to)
{
    to->r = from->r;
    to->g = from->g;
    to->b = from->b;
    to->a = from->a;
}

void deepcopy_VkImageSubresourceRange(
    Pool* pool,
    const VkImageSubresourceRange* from,
    VkImageSubresourceRange* to)
{
    to->aspectMask = from->aspectMask;
    to->baseMipLevel = from->baseMipLevel;
    to->levelCount = from->levelCount;
    to->baseArrayLayer = from->baseArrayLayer;
    to->layerCount = from->layerCount;
}

void deepcopy_VkImageViewCreateInfo(
    Pool* pool,
    const VkImageViewCreateInfo* from,
    VkImageViewCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->image = from->image;
    to->viewType = from->viewType;
    to->format = from->format;
    deepcopy_VkComponentMapping(pool, &from->components, (VkComponentMapping*)(&to->components));
    deepcopy_VkImageSubresourceRange(pool, &from->subresourceRange, (VkImageSubresourceRange*)(&to->subresourceRange));
}

void deepcopy_VkShaderModuleCreateInfo(
    Pool* pool,
    const VkShaderModuleCreateInfo* from,
    VkShaderModuleCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->codeSize = from->codeSize;
    to->pCode = nullptr;
    if (from->pCode)
    {
        to->pCode = (uint32_t*)pool->dupArray(from->pCode, (from->codeSize / 4) * sizeof(const uint32_t));
    }
}

void deepcopy_VkPipelineCacheCreateInfo(
    Pool* pool,
    const VkPipelineCacheCreateInfo* from,
    VkPipelineCacheCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->initialDataSize = from->initialDataSize;
    to->pInitialData = nullptr;
    if (from->pInitialData)
    {
        to->pInitialData = (void*)pool->dupArray(from->pInitialData, from->initialDataSize * sizeof(const uint8_t));
    }
}

void deepcopy_VkSpecializationMapEntry(
    Pool* pool,
    const VkSpecializationMapEntry* from,
    VkSpecializationMapEntry* to)
{
    to->constantID = from->constantID;
    to->offset = from->offset;
    to->size = from->size;
}

void deepcopy_VkSpecializationInfo(
    Pool* pool,
    const VkSpecializationInfo* from,
    VkSpecializationInfo* to)
{
    to->mapEntryCount = from->mapEntryCount;
    to->pMapEntries = nullptr;
    if (from->pMapEntries)
    {
        to->pMapEntries = (VkSpecializationMapEntry*)pool->alloc(from->mapEntryCount * sizeof(const VkSpecializationMapEntry));
        to->mapEntryCount = from->mapEntryCount;
        for (uint32_t i = 0; i < (uint32_t)from->mapEntryCount; ++i)
        {
            deepcopy_VkSpecializationMapEntry(pool, from->pMapEntries + i, (VkSpecializationMapEntry*)(to->pMapEntries + i));
        }
    }
    to->dataSize = from->dataSize;
    to->pData = nullptr;
    if (from->pData)
    {
        to->pData = (void*)pool->dupArray(from->pData, from->dataSize * sizeof(const uint8_t));
    }
}

void deepcopy_VkPipelineShaderStageCreateInfo(
    Pool* pool,
    const VkPipelineShaderStageCreateInfo* from,
    VkPipelineShaderStageCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->stage = from->stage;
    to->module = from->module;
    to->pName = nullptr;
    if (from->pName)
    {
        to->pName = pool->strDup(from->pName);
    }
    to->pSpecializationInfo = nullptr;
    if (from->pSpecializationInfo)
    {
        to->pSpecializationInfo = (VkSpecializationInfo*)pool->alloc(sizeof(const VkSpecializationInfo));
        deepcopy_VkSpecializationInfo(pool, from->pSpecializationInfo, (VkSpecializationInfo*)(to->pSpecializationInfo));
    }
}

void deepcopy_VkVertexInputBindingDescription(
    Pool* pool,
    const VkVertexInputBindingDescription* from,
    VkVertexInputBindingDescription* to)
{
    to->binding = from->binding;
    to->stride = from->stride;
    to->inputRate = from->inputRate;
}

void deepcopy_VkVertexInputAttributeDescription(
    Pool* pool,
    const VkVertexInputAttributeDescription* from,
    VkVertexInputAttributeDescription* to)
{
    to->location = from->location;
    to->binding = from->binding;
    to->format = from->format;
    to->offset = from->offset;
}

void deepcopy_VkPipelineVertexInputStateCreateInfo(
    Pool* pool,
    const VkPipelineVertexInputStateCreateInfo* from,
    VkPipelineVertexInputStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->vertexBindingDescriptionCount = from->vertexBindingDescriptionCount;
    to->pVertexBindingDescriptions = nullptr;
    if (from->pVertexBindingDescriptions)
    {
        to->pVertexBindingDescriptions = (VkVertexInputBindingDescription*)pool->alloc(from->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
        to->vertexBindingDescriptionCount = from->vertexBindingDescriptionCount;
        for (uint32_t i = 0; i < (uint32_t)from->vertexBindingDescriptionCount; ++i)
        {
            deepcopy_VkVertexInputBindingDescription(pool, from->pVertexBindingDescriptions + i, (VkVertexInputBindingDescription*)(to->pVertexBindingDescriptions + i));
        }
    }
    to->vertexAttributeDescriptionCount = from->vertexAttributeDescriptionCount;
    to->pVertexAttributeDescriptions = nullptr;
    if (from->pVertexAttributeDescriptions)
    {
        to->pVertexAttributeDescriptions = (VkVertexInputAttributeDescription*)pool->alloc(from->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
        to->vertexAttributeDescriptionCount = from->vertexAttributeDescriptionCount;
        for (uint32_t i = 0; i < (uint32_t)from->vertexAttributeDescriptionCount; ++i)
        {
            deepcopy_VkVertexInputAttributeDescription(pool, from->pVertexAttributeDescriptions + i, (VkVertexInputAttributeDescription*)(to->pVertexAttributeDescriptions + i));
        }
    }
}

void deepcopy_VkPipelineInputAssemblyStateCreateInfo(
    Pool* pool,
    const VkPipelineInputAssemblyStateCreateInfo* from,
    VkPipelineInputAssemblyStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->topology = from->topology;
    to->primitiveRestartEnable = from->primitiveRestartEnable;
}

void deepcopy_VkPipelineTessellationStateCreateInfo(
    Pool* pool,
    const VkPipelineTessellationStateCreateInfo* from,
    VkPipelineTessellationStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->patchControlPoints = from->patchControlPoints;
}

void deepcopy_VkViewport(
    Pool* pool,
    const VkViewport* from,
    VkViewport* to)
{
    to->x = from->x;
    to->y = from->y;
    to->width = from->width;
    to->height = from->height;
    to->minDepth = from->minDepth;
    to->maxDepth = from->maxDepth;
}

void deepcopy_VkOffset2D(
    Pool* pool,
    const VkOffset2D* from,
    VkOffset2D* to)
{
    to->x = from->x;
    to->y = from->y;
}

void deepcopy_VkExtent2D(
    Pool* pool,
    const VkExtent2D* from,
    VkExtent2D* to)
{
    to->width = from->width;
    to->height = from->height;
}

void deepcopy_VkRect2D(
    Pool* pool,
    const VkRect2D* from,
    VkRect2D* to)
{
    deepcopy_VkOffset2D(pool, &from->offset, (VkOffset2D*)(&to->offset));
    deepcopy_VkExtent2D(pool, &from->extent, (VkExtent2D*)(&to->extent));
}

void deepcopy_VkPipelineViewportStateCreateInfo(
    Pool* pool,
    const VkPipelineViewportStateCreateInfo* from,
    VkPipelineViewportStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->viewportCount = from->viewportCount;
    to->pViewports = nullptr;
    if (from->pViewports)
    {
        to->pViewports = (VkViewport*)pool->alloc(from->viewportCount * sizeof(const VkViewport));
        to->viewportCount = from->viewportCount;
        for (uint32_t i = 0; i < (uint32_t)from->viewportCount; ++i)
        {
            deepcopy_VkViewport(pool, from->pViewports + i, (VkViewport*)(to->pViewports + i));
        }
    }
    to->scissorCount = from->scissorCount;
    to->pScissors = nullptr;
    if (from->pScissors)
    {
        to->pScissors = (VkRect2D*)pool->alloc(from->scissorCount * sizeof(const VkRect2D));
        to->scissorCount = from->scissorCount;
        for (uint32_t i = 0; i < (uint32_t)from->scissorCount; ++i)
        {
            deepcopy_VkRect2D(pool, from->pScissors + i, (VkRect2D*)(to->pScissors + i));
        }
    }
}

void deepcopy_VkPipelineRasterizationStateCreateInfo(
    Pool* pool,
    const VkPipelineRasterizationStateCreateInfo* from,
    VkPipelineRasterizationStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->depthClampEnable = from->depthClampEnable;
    to->rasterizerDiscardEnable = from->rasterizerDiscardEnable;
    to->polygonMode = from->polygonMode;
    to->cullMode = from->cullMode;
    to->frontFace = from->frontFace;
    to->depthBiasEnable = from->depthBiasEnable;
    to->depthBiasConstantFactor = from->depthBiasConstantFactor;
    to->depthBiasClamp = from->depthBiasClamp;
    to->depthBiasSlopeFactor = from->depthBiasSlopeFactor;
    to->lineWidth = from->lineWidth;
}

void deepcopy_VkPipelineMultisampleStateCreateInfo(
    Pool* pool,
    const VkPipelineMultisampleStateCreateInfo* from,
    VkPipelineMultisampleStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->rasterizationSamples = from->rasterizationSamples;
    to->sampleShadingEnable = from->sampleShadingEnable;
    to->minSampleShading = from->minSampleShading;
    to->pSampleMask = nullptr;
    if (from->pSampleMask)
    {
        to->pSampleMask = (VkSampleMask*)pool->dupArray(from->pSampleMask, (((from->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    to->alphaToCoverageEnable = from->alphaToCoverageEnable;
    to->alphaToOneEnable = from->alphaToOneEnable;
}

void deepcopy_VkStencilOpState(
    Pool* pool,
    const VkStencilOpState* from,
    VkStencilOpState* to)
{
    to->failOp = from->failOp;
    to->passOp = from->passOp;
    to->depthFailOp = from->depthFailOp;
    to->compareOp = from->compareOp;
    to->compareMask = from->compareMask;
    to->writeMask = from->writeMask;
    to->reference = from->reference;
}

void deepcopy_VkPipelineDepthStencilStateCreateInfo(
    Pool* pool,
    const VkPipelineDepthStencilStateCreateInfo* from,
    VkPipelineDepthStencilStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->depthTestEnable = from->depthTestEnable;
    to->depthWriteEnable = from->depthWriteEnable;
    to->depthCompareOp = from->depthCompareOp;
    to->depthBoundsTestEnable = from->depthBoundsTestEnable;
    to->stencilTestEnable = from->stencilTestEnable;
    deepcopy_VkStencilOpState(pool, &from->front, (VkStencilOpState*)(&to->front));
    deepcopy_VkStencilOpState(pool, &from->back, (VkStencilOpState*)(&to->back));
    to->minDepthBounds = from->minDepthBounds;
    to->maxDepthBounds = from->maxDepthBounds;
}

void deepcopy_VkPipelineColorBlendAttachmentState(
    Pool* pool,
    const VkPipelineColorBlendAttachmentState* from,
    VkPipelineColorBlendAttachmentState* to)
{
    to->blendEnable = from->blendEnable;
    to->srcColorBlendFactor = from->srcColorBlendFactor;
    to->dstColorBlendFactor = from->dstColorBlendFactor;
    to->colorBlendOp = from->colorBlendOp;
    to->srcAlphaBlendFactor = from->srcAlphaBlendFactor;
    to->dstAlphaBlendFactor = from->dstAlphaBlendFactor;
    to->alphaBlendOp = from->alphaBlendOp;
    to->colorWriteMask = from->colorWriteMask;
}

void deepcopy_VkPipelineColorBlendStateCreateInfo(
    Pool* pool,
    const VkPipelineColorBlendStateCreateInfo* from,
    VkPipelineColorBlendStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->logicOpEnable = from->logicOpEnable;
    to->logicOp = from->logicOp;
    to->attachmentCount = from->attachmentCount;
    to->pAttachments = nullptr;
    if (from->pAttachments)
    {
        to->pAttachments = (VkPipelineColorBlendAttachmentState*)pool->alloc(from->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
        to->attachmentCount = from->attachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->attachmentCount; ++i)
        {
            deepcopy_VkPipelineColorBlendAttachmentState(pool, from->pAttachments + i, (VkPipelineColorBlendAttachmentState*)(to->pAttachments + i));
        }
    }
    memcpy(to->blendConstants, from->blendConstants, 4 * sizeof(float));
}

void deepcopy_VkPipelineDynamicStateCreateInfo(
    Pool* pool,
    const VkPipelineDynamicStateCreateInfo* from,
    VkPipelineDynamicStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->dynamicStateCount = from->dynamicStateCount;
    to->pDynamicStates = nullptr;
    if (from->pDynamicStates)
    {
        to->pDynamicStates = (VkDynamicState*)pool->dupArray(from->pDynamicStates, from->dynamicStateCount * sizeof(const VkDynamicState));
    }
}

void deepcopy_VkGraphicsPipelineCreateInfo(
    Pool* pool,
    const VkGraphicsPipelineCreateInfo* from,
    VkGraphicsPipelineCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->stageCount = from->stageCount;
    to->pStages = nullptr;
    if (from->pStages)
    {
        to->pStages = (VkPipelineShaderStageCreateInfo*)pool->alloc(from->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
        to->stageCount = from->stageCount;
        for (uint32_t i = 0; i < (uint32_t)from->stageCount; ++i)
        {
            deepcopy_VkPipelineShaderStageCreateInfo(pool, from->pStages + i, (VkPipelineShaderStageCreateInfo*)(to->pStages + i));
        }
    }
    to->pVertexInputState = nullptr;
    if (from->pVertexInputState)
    {
        to->pVertexInputState = (VkPipelineVertexInputStateCreateInfo*)pool->alloc(sizeof(const VkPipelineVertexInputStateCreateInfo));
        deepcopy_VkPipelineVertexInputStateCreateInfo(pool, from->pVertexInputState, (VkPipelineVertexInputStateCreateInfo*)(to->pVertexInputState));
    }
    to->pInputAssemblyState = nullptr;
    if (from->pInputAssemblyState)
    {
        to->pInputAssemblyState = (VkPipelineInputAssemblyStateCreateInfo*)pool->alloc(sizeof(const VkPipelineInputAssemblyStateCreateInfo));
        deepcopy_VkPipelineInputAssemblyStateCreateInfo(pool, from->pInputAssemblyState, (VkPipelineInputAssemblyStateCreateInfo*)(to->pInputAssemblyState));
    }
    to->pTessellationState = nullptr;
    if (from->pTessellationState)
    {
        to->pTessellationState = (VkPipelineTessellationStateCreateInfo*)pool->alloc(sizeof(const VkPipelineTessellationStateCreateInfo));
        deepcopy_VkPipelineTessellationStateCreateInfo(pool, from->pTessellationState, (VkPipelineTessellationStateCreateInfo*)(to->pTessellationState));
    }
    to->pViewportState = nullptr;
    if (from->pViewportState)
    {
        to->pViewportState = (VkPipelineViewportStateCreateInfo*)pool->alloc(sizeof(const VkPipelineViewportStateCreateInfo));
        deepcopy_VkPipelineViewportStateCreateInfo(pool, from->pViewportState, (VkPipelineViewportStateCreateInfo*)(to->pViewportState));
    }
    to->pRasterizationState = nullptr;
    if (from->pRasterizationState)
    {
        to->pRasterizationState = (VkPipelineRasterizationStateCreateInfo*)pool->alloc(sizeof(const VkPipelineRasterizationStateCreateInfo));
        deepcopy_VkPipelineRasterizationStateCreateInfo(pool, from->pRasterizationState, (VkPipelineRasterizationStateCreateInfo*)(to->pRasterizationState));
    }
    to->pMultisampleState = nullptr;
    if (from->pMultisampleState)
    {
        to->pMultisampleState = (VkPipelineMultisampleStateCreateInfo*)pool->alloc(sizeof(const VkPipelineMultisampleStateCreateInfo));
        deepcopy_VkPipelineMultisampleStateCreateInfo(pool, from->pMultisampleState, (VkPipelineMultisampleStateCreateInfo*)(to->pMultisampleState));
    }
    to->pDepthStencilState = nullptr;
    if (from->pDepthStencilState)
    {
        to->pDepthStencilState = (VkPipelineDepthStencilStateCreateInfo*)pool->alloc(sizeof(const VkPipelineDepthStencilStateCreateInfo));
        deepcopy_VkPipelineDepthStencilStateCreateInfo(pool, from->pDepthStencilState, (VkPipelineDepthStencilStateCreateInfo*)(to->pDepthStencilState));
    }
    to->pColorBlendState = nullptr;
    if (from->pColorBlendState)
    {
        to->pColorBlendState = (VkPipelineColorBlendStateCreateInfo*)pool->alloc(sizeof(const VkPipelineColorBlendStateCreateInfo));
        deepcopy_VkPipelineColorBlendStateCreateInfo(pool, from->pColorBlendState, (VkPipelineColorBlendStateCreateInfo*)(to->pColorBlendState));
    }
    to->pDynamicState = nullptr;
    if (from->pDynamicState)
    {
        to->pDynamicState = (VkPipelineDynamicStateCreateInfo*)pool->alloc(sizeof(const VkPipelineDynamicStateCreateInfo));
        deepcopy_VkPipelineDynamicStateCreateInfo(pool, from->pDynamicState, (VkPipelineDynamicStateCreateInfo*)(to->pDynamicState));
    }
    to->layout = from->layout;
    to->renderPass = from->renderPass;
    to->subpass = from->subpass;
    to->basePipelineHandle = from->basePipelineHandle;
    to->basePipelineIndex = from->basePipelineIndex;
}

void deepcopy_VkComputePipelineCreateInfo(
    Pool* pool,
    const VkComputePipelineCreateInfo* from,
    VkComputePipelineCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    deepcopy_VkPipelineShaderStageCreateInfo(pool, &from->stage, (VkPipelineShaderStageCreateInfo*)(&to->stage));
    to->layout = from->layout;
    to->basePipelineHandle = from->basePipelineHandle;
    to->basePipelineIndex = from->basePipelineIndex;
}

void deepcopy_VkPushConstantRange(
    Pool* pool,
    const VkPushConstantRange* from,
    VkPushConstantRange* to)
{
    to->stageFlags = from->stageFlags;
    to->offset = from->offset;
    to->size = from->size;
}

void deepcopy_VkPipelineLayoutCreateInfo(
    Pool* pool,
    const VkPipelineLayoutCreateInfo* from,
    VkPipelineLayoutCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->setLayoutCount = from->setLayoutCount;
    to->pSetLayouts = nullptr;
    if (from->pSetLayouts)
    {
        to->pSetLayouts = (VkDescriptorSetLayout*)pool->dupArray(from->pSetLayouts, from->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    }
    to->pushConstantRangeCount = from->pushConstantRangeCount;
    to->pPushConstantRanges = nullptr;
    if (from->pPushConstantRanges)
    {
        to->pPushConstantRanges = (VkPushConstantRange*)pool->alloc(from->pushConstantRangeCount * sizeof(const VkPushConstantRange));
        to->pushConstantRangeCount = from->pushConstantRangeCount;
        for (uint32_t i = 0; i < (uint32_t)from->pushConstantRangeCount; ++i)
        {
            deepcopy_VkPushConstantRange(pool, from->pPushConstantRanges + i, (VkPushConstantRange*)(to->pPushConstantRanges + i));
        }
    }
}

void deepcopy_VkSamplerCreateInfo(
    Pool* pool,
    const VkSamplerCreateInfo* from,
    VkSamplerCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->magFilter = from->magFilter;
    to->minFilter = from->minFilter;
    to->mipmapMode = from->mipmapMode;
    to->addressModeU = from->addressModeU;
    to->addressModeV = from->addressModeV;
    to->addressModeW = from->addressModeW;
    to->mipLodBias = from->mipLodBias;
    to->anisotropyEnable = from->anisotropyEnable;
    to->maxAnisotropy = from->maxAnisotropy;
    to->compareEnable = from->compareEnable;
    to->compareOp = from->compareOp;
    to->minLod = from->minLod;
    to->maxLod = from->maxLod;
    to->borderColor = from->borderColor;
    to->unnormalizedCoordinates = from->unnormalizedCoordinates;
}

void deepcopy_VkDescriptorSetLayoutBinding(
    Pool* pool,
    const VkDescriptorSetLayoutBinding* from,
    VkDescriptorSetLayoutBinding* to)
{
    to->binding = from->binding;
    to->descriptorType = from->descriptorType;
    to->descriptorCount = from->descriptorCount;
    to->stageFlags = from->stageFlags;
    to->pImmutableSamplers = nullptr;
    if (from->pImmutableSamplers)
    {
        to->pImmutableSamplers = (VkSampler*)pool->dupArray(from->pImmutableSamplers, from->descriptorCount * sizeof(const VkSampler));
    }
}

void deepcopy_VkDescriptorSetLayoutCreateInfo(
    Pool* pool,
    const VkDescriptorSetLayoutCreateInfo* from,
    VkDescriptorSetLayoutCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->bindingCount = from->bindingCount;
    to->pBindings = nullptr;
    if (from->pBindings)
    {
        to->pBindings = (VkDescriptorSetLayoutBinding*)pool->alloc(from->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
        to->bindingCount = from->bindingCount;
        for (uint32_t i = 0; i < (uint32_t)from->bindingCount; ++i)
        {
            deepcopy_VkDescriptorSetLayoutBinding(pool, from->pBindings + i, (VkDescriptorSetLayoutBinding*)(to->pBindings + i));
        }
    }
}

void deepcopy_VkDescriptorPoolSize(
    Pool* pool,
    const VkDescriptorPoolSize* from,
    VkDescriptorPoolSize* to)
{
    to->type = from->type;
    to->descriptorCount = from->descriptorCount;
}

void deepcopy_VkDescriptorPoolCreateInfo(
    Pool* pool,
    const VkDescriptorPoolCreateInfo* from,
    VkDescriptorPoolCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->maxSets = from->maxSets;
    to->poolSizeCount = from->poolSizeCount;
    to->pPoolSizes = nullptr;
    if (from->pPoolSizes)
    {
        to->pPoolSizes = (VkDescriptorPoolSize*)pool->alloc(from->poolSizeCount * sizeof(const VkDescriptorPoolSize));
        to->poolSizeCount = from->poolSizeCount;
        for (uint32_t i = 0; i < (uint32_t)from->poolSizeCount; ++i)
        {
            deepcopy_VkDescriptorPoolSize(pool, from->pPoolSizes + i, (VkDescriptorPoolSize*)(to->pPoolSizes + i));
        }
    }
}

void deepcopy_VkDescriptorSetAllocateInfo(
    Pool* pool,
    const VkDescriptorSetAllocateInfo* from,
    VkDescriptorSetAllocateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->descriptorPool = from->descriptorPool;
    to->descriptorSetCount = from->descriptorSetCount;
    to->pSetLayouts = nullptr;
    if (from->pSetLayouts)
    {
        to->pSetLayouts = (VkDescriptorSetLayout*)pool->dupArray(from->pSetLayouts, from->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
    }
}

void deepcopy_VkDescriptorImageInfo(
    Pool* pool,
    const VkDescriptorImageInfo* from,
    VkDescriptorImageInfo* to)
{
    to->sampler = from->sampler;
    to->imageView = from->imageView;
    to->imageLayout = from->imageLayout;
}

void deepcopy_VkDescriptorBufferInfo(
    Pool* pool,
    const VkDescriptorBufferInfo* from,
    VkDescriptorBufferInfo* to)
{
    to->buffer = from->buffer;
    to->offset = from->offset;
    to->range = from->range;
}

void deepcopy_VkWriteDescriptorSet(
    Pool* pool,
    const VkWriteDescriptorSet* from,
    VkWriteDescriptorSet* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->dstSet = from->dstSet;
    to->dstBinding = from->dstBinding;
    to->dstArrayElement = from->dstArrayElement;
    to->descriptorCount = from->descriptorCount;
    to->descriptorType = from->descriptorType;
    to->pImageInfo = nullptr;
    if (from->pImageInfo)
    {
        to->pImageInfo = (VkDescriptorImageInfo*)pool->alloc(from->descriptorCount * sizeof(const VkDescriptorImageInfo));
        to->descriptorCount = from->descriptorCount;
        for (uint32_t i = 0; i < (uint32_t)from->descriptorCount; ++i)
        {
            deepcopy_VkDescriptorImageInfo(pool, from->pImageInfo + i, (VkDescriptorImageInfo*)(to->pImageInfo + i));
        }
    }
    to->pBufferInfo = nullptr;
    if (from->pBufferInfo)
    {
        to->pBufferInfo = (VkDescriptorBufferInfo*)pool->alloc(from->descriptorCount * sizeof(const VkDescriptorBufferInfo));
        to->descriptorCount = from->descriptorCount;
        for (uint32_t i = 0; i < (uint32_t)from->descriptorCount; ++i)
        {
            deepcopy_VkDescriptorBufferInfo(pool, from->pBufferInfo + i, (VkDescriptorBufferInfo*)(to->pBufferInfo + i));
        }
    }
    to->pTexelBufferView = nullptr;
    if (from->pTexelBufferView)
    {
        to->pTexelBufferView = (VkBufferView*)pool->dupArray(from->pTexelBufferView, from->descriptorCount * sizeof(const VkBufferView));
    }
}

void deepcopy_VkCopyDescriptorSet(
    Pool* pool,
    const VkCopyDescriptorSet* from,
    VkCopyDescriptorSet* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcSet = from->srcSet;
    to->srcBinding = from->srcBinding;
    to->srcArrayElement = from->srcArrayElement;
    to->dstSet = from->dstSet;
    to->dstBinding = from->dstBinding;
    to->dstArrayElement = from->dstArrayElement;
    to->descriptorCount = from->descriptorCount;
}

void deepcopy_VkFramebufferCreateInfo(
    Pool* pool,
    const VkFramebufferCreateInfo* from,
    VkFramebufferCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->renderPass = from->renderPass;
    to->attachmentCount = from->attachmentCount;
    to->pAttachments = nullptr;
    if (from->pAttachments)
    {
        to->pAttachments = (VkImageView*)pool->dupArray(from->pAttachments, from->attachmentCount * sizeof(const VkImageView));
    }
    to->width = from->width;
    to->height = from->height;
    to->layers = from->layers;
}

void deepcopy_VkAttachmentDescription(
    Pool* pool,
    const VkAttachmentDescription* from,
    VkAttachmentDescription* to)
{
    to->flags = from->flags;
    to->format = from->format;
    to->samples = from->samples;
    to->loadOp = from->loadOp;
    to->storeOp = from->storeOp;
    to->stencilLoadOp = from->stencilLoadOp;
    to->stencilStoreOp = from->stencilStoreOp;
    to->initialLayout = from->initialLayout;
    to->finalLayout = from->finalLayout;
}

void deepcopy_VkAttachmentReference(
    Pool* pool,
    const VkAttachmentReference* from,
    VkAttachmentReference* to)
{
    to->attachment = from->attachment;
    to->layout = from->layout;
}

void deepcopy_VkSubpassDescription(
    Pool* pool,
    const VkSubpassDescription* from,
    VkSubpassDescription* to)
{
    to->flags = from->flags;
    to->pipelineBindPoint = from->pipelineBindPoint;
    to->inputAttachmentCount = from->inputAttachmentCount;
    to->pInputAttachments = nullptr;
    if (from->pInputAttachments)
    {
        to->pInputAttachments = (VkAttachmentReference*)pool->alloc(from->inputAttachmentCount * sizeof(const VkAttachmentReference));
        to->inputAttachmentCount = from->inputAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->inputAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference(pool, from->pInputAttachments + i, (VkAttachmentReference*)(to->pInputAttachments + i));
        }
    }
    to->colorAttachmentCount = from->colorAttachmentCount;
    to->pColorAttachments = nullptr;
    if (from->pColorAttachments)
    {
        to->pColorAttachments = (VkAttachmentReference*)pool->alloc(from->colorAttachmentCount * sizeof(const VkAttachmentReference));
        to->colorAttachmentCount = from->colorAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->colorAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference(pool, from->pColorAttachments + i, (VkAttachmentReference*)(to->pColorAttachments + i));
        }
    }
    to->pResolveAttachments = nullptr;
    if (from->pResolveAttachments)
    {
        to->pResolveAttachments = (VkAttachmentReference*)pool->alloc(from->colorAttachmentCount * sizeof(const VkAttachmentReference));
        to->colorAttachmentCount = from->colorAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->colorAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference(pool, from->pResolveAttachments + i, (VkAttachmentReference*)(to->pResolveAttachments + i));
        }
    }
    to->pDepthStencilAttachment = nullptr;
    if (from->pDepthStencilAttachment)
    {
        to->pDepthStencilAttachment = (VkAttachmentReference*)pool->alloc(sizeof(const VkAttachmentReference));
        deepcopy_VkAttachmentReference(pool, from->pDepthStencilAttachment, (VkAttachmentReference*)(to->pDepthStencilAttachment));
    }
    to->preserveAttachmentCount = from->preserveAttachmentCount;
    to->pPreserveAttachments = nullptr;
    if (from->pPreserveAttachments)
    {
        to->pPreserveAttachments = (uint32_t*)pool->dupArray(from->pPreserveAttachments, from->preserveAttachmentCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkSubpassDependency(
    Pool* pool,
    const VkSubpassDependency* from,
    VkSubpassDependency* to)
{
    to->srcSubpass = from->srcSubpass;
    to->dstSubpass = from->dstSubpass;
    to->srcStageMask = from->srcStageMask;
    to->dstStageMask = from->dstStageMask;
    to->srcAccessMask = from->srcAccessMask;
    to->dstAccessMask = from->dstAccessMask;
    to->dependencyFlags = from->dependencyFlags;
}

void deepcopy_VkRenderPassCreateInfo(
    Pool* pool,
    const VkRenderPassCreateInfo* from,
    VkRenderPassCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->attachmentCount = from->attachmentCount;
    to->pAttachments = nullptr;
    if (from->pAttachments)
    {
        to->pAttachments = (VkAttachmentDescription*)pool->alloc(from->attachmentCount * sizeof(const VkAttachmentDescription));
        to->attachmentCount = from->attachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->attachmentCount; ++i)
        {
            deepcopy_VkAttachmentDescription(pool, from->pAttachments + i, (VkAttachmentDescription*)(to->pAttachments + i));
        }
    }
    to->subpassCount = from->subpassCount;
    to->pSubpasses = nullptr;
    if (from->pSubpasses)
    {
        to->pSubpasses = (VkSubpassDescription*)pool->alloc(from->subpassCount * sizeof(const VkSubpassDescription));
        to->subpassCount = from->subpassCount;
        for (uint32_t i = 0; i < (uint32_t)from->subpassCount; ++i)
        {
            deepcopy_VkSubpassDescription(pool, from->pSubpasses + i, (VkSubpassDescription*)(to->pSubpasses + i));
        }
    }
    to->dependencyCount = from->dependencyCount;
    to->pDependencies = nullptr;
    if (from->pDependencies)
    {
        to->pDependencies = (VkSubpassDependency*)pool->alloc(from->dependencyCount * sizeof(const VkSubpassDependency));
        to->dependencyCount = from->dependencyCount;
        for (uint32_t i = 0; i < (uint32_t)from->dependencyCount; ++i)
        {
            deepcopy_VkSubpassDependency(pool, from->pDependencies + i, (VkSubpassDependency*)(to->pDependencies + i));
        }
    }
}

void deepcopy_VkCommandPoolCreateInfo(
    Pool* pool,
    const VkCommandPoolCreateInfo* from,
    VkCommandPoolCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->queueFamilyIndex = from->queueFamilyIndex;
}

void deepcopy_VkCommandBufferAllocateInfo(
    Pool* pool,
    const VkCommandBufferAllocateInfo* from,
    VkCommandBufferAllocateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->commandPool = from->commandPool;
    to->level = from->level;
    to->commandBufferCount = from->commandBufferCount;
}

void deepcopy_VkCommandBufferInheritanceInfo(
    Pool* pool,
    const VkCommandBufferInheritanceInfo* from,
    VkCommandBufferInheritanceInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->renderPass = from->renderPass;
    to->subpass = from->subpass;
    to->framebuffer = from->framebuffer;
    to->occlusionQueryEnable = from->occlusionQueryEnable;
    to->queryFlags = from->queryFlags;
    to->pipelineStatistics = from->pipelineStatistics;
}

void deepcopy_VkCommandBufferBeginInfo(
    Pool* pool,
    const VkCommandBufferBeginInfo* from,
    VkCommandBufferBeginInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pInheritanceInfo = nullptr;
    if (from->pInheritanceInfo)
    {
        to->pInheritanceInfo = (VkCommandBufferInheritanceInfo*)pool->alloc(sizeof(const VkCommandBufferInheritanceInfo));
        deepcopy_VkCommandBufferInheritanceInfo(pool, from->pInheritanceInfo, (VkCommandBufferInheritanceInfo*)(to->pInheritanceInfo));
    }
}

void deepcopy_VkBufferCopy(
    Pool* pool,
    const VkBufferCopy* from,
    VkBufferCopy* to)
{
    to->srcOffset = from->srcOffset;
    to->dstOffset = from->dstOffset;
    to->size = from->size;
}

void deepcopy_VkImageSubresourceLayers(
    Pool* pool,
    const VkImageSubresourceLayers* from,
    VkImageSubresourceLayers* to)
{
    to->aspectMask = from->aspectMask;
    to->mipLevel = from->mipLevel;
    to->baseArrayLayer = from->baseArrayLayer;
    to->layerCount = from->layerCount;
}

void deepcopy_VkImageCopy(
    Pool* pool,
    const VkImageCopy* from,
    VkImageCopy* to)
{
    deepcopy_VkImageSubresourceLayers(pool, &from->srcSubresource, (VkImageSubresourceLayers*)(&to->srcSubresource));
    deepcopy_VkOffset3D(pool, &from->srcOffset, (VkOffset3D*)(&to->srcOffset));
    deepcopy_VkImageSubresourceLayers(pool, &from->dstSubresource, (VkImageSubresourceLayers*)(&to->dstSubresource));
    deepcopy_VkOffset3D(pool, &from->dstOffset, (VkOffset3D*)(&to->dstOffset));
    deepcopy_VkExtent3D(pool, &from->extent, (VkExtent3D*)(&to->extent));
}

void deepcopy_VkImageBlit(
    Pool* pool,
    const VkImageBlit* from,
    VkImageBlit* to)
{
    deepcopy_VkImageSubresourceLayers(pool, &from->srcSubresource, (VkImageSubresourceLayers*)(&to->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        deepcopy_VkOffset3D(pool, from->srcOffsets + i, (VkOffset3D*)(to->srcOffsets + i));
    }
    deepcopy_VkImageSubresourceLayers(pool, &from->dstSubresource, (VkImageSubresourceLayers*)(&to->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        deepcopy_VkOffset3D(pool, from->dstOffsets + i, (VkOffset3D*)(to->dstOffsets + i));
    }
}

void deepcopy_VkBufferImageCopy(
    Pool* pool,
    const VkBufferImageCopy* from,
    VkBufferImageCopy* to)
{
    to->bufferOffset = from->bufferOffset;
    to->bufferRowLength = from->bufferRowLength;
    to->bufferImageHeight = from->bufferImageHeight;
    deepcopy_VkImageSubresourceLayers(pool, &from->imageSubresource, (VkImageSubresourceLayers*)(&to->imageSubresource));
    deepcopy_VkOffset3D(pool, &from->imageOffset, (VkOffset3D*)(&to->imageOffset));
    deepcopy_VkExtent3D(pool, &from->imageExtent, (VkExtent3D*)(&to->imageExtent));
}

void deepcopy_VkClearColorValue(
    Pool* pool,
    const VkClearColorValue* from,
    VkClearColorValue* to)
{
    memcpy(to->float32, from->float32, 4 * sizeof(float));
    memcpy(to->int32, from->int32, 4 * sizeof(int32_t));
    memcpy(to->uint32, from->uint32, 4 * sizeof(uint32_t));
}

void deepcopy_VkClearDepthStencilValue(
    Pool* pool,
    const VkClearDepthStencilValue* from,
    VkClearDepthStencilValue* to)
{
    to->depth = from->depth;
    to->stencil = from->stencil;
}

void deepcopy_VkClearValue(
    Pool* pool,
    const VkClearValue* from,
    VkClearValue* to)
{
    deepcopy_VkClearColorValue(pool, &from->color, (VkClearColorValue*)(&to->color));
    deepcopy_VkClearDepthStencilValue(pool, &from->depthStencil, (VkClearDepthStencilValue*)(&to->depthStencil));
}

void deepcopy_VkClearAttachment(
    Pool* pool,
    const VkClearAttachment* from,
    VkClearAttachment* to)
{
    to->aspectMask = from->aspectMask;
    to->colorAttachment = from->colorAttachment;
    deepcopy_VkClearValue(pool, &from->clearValue, (VkClearValue*)(&to->clearValue));
}

void deepcopy_VkClearRect(
    Pool* pool,
    const VkClearRect* from,
    VkClearRect* to)
{
    deepcopy_VkRect2D(pool, &from->rect, (VkRect2D*)(&to->rect));
    to->baseArrayLayer = from->baseArrayLayer;
    to->layerCount = from->layerCount;
}

void deepcopy_VkImageResolve(
    Pool* pool,
    const VkImageResolve* from,
    VkImageResolve* to)
{
    deepcopy_VkImageSubresourceLayers(pool, &from->srcSubresource, (VkImageSubresourceLayers*)(&to->srcSubresource));
    deepcopy_VkOffset3D(pool, &from->srcOffset, (VkOffset3D*)(&to->srcOffset));
    deepcopy_VkImageSubresourceLayers(pool, &from->dstSubresource, (VkImageSubresourceLayers*)(&to->dstSubresource));
    deepcopy_VkOffset3D(pool, &from->dstOffset, (VkOffset3D*)(&to->dstOffset));
    deepcopy_VkExtent3D(pool, &from->extent, (VkExtent3D*)(&to->extent));
}

void deepcopy_VkMemoryBarrier(
    Pool* pool,
    const VkMemoryBarrier* from,
    VkMemoryBarrier* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcAccessMask = from->srcAccessMask;
    to->dstAccessMask = from->dstAccessMask;
}

void deepcopy_VkBufferMemoryBarrier(
    Pool* pool,
    const VkBufferMemoryBarrier* from,
    VkBufferMemoryBarrier* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcAccessMask = from->srcAccessMask;
    to->dstAccessMask = from->dstAccessMask;
    to->srcQueueFamilyIndex = from->srcQueueFamilyIndex;
    to->dstQueueFamilyIndex = from->dstQueueFamilyIndex;
    to->buffer = from->buffer;
    to->offset = from->offset;
    to->size = from->size;
}

void deepcopy_VkImageMemoryBarrier(
    Pool* pool,
    const VkImageMemoryBarrier* from,
    VkImageMemoryBarrier* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcAccessMask = from->srcAccessMask;
    to->dstAccessMask = from->dstAccessMask;
    to->oldLayout = from->oldLayout;
    to->newLayout = from->newLayout;
    to->srcQueueFamilyIndex = from->srcQueueFamilyIndex;
    to->dstQueueFamilyIndex = from->dstQueueFamilyIndex;
    to->image = from->image;
    deepcopy_VkImageSubresourceRange(pool, &from->subresourceRange, (VkImageSubresourceRange*)(&to->subresourceRange));
}

void deepcopy_VkRenderPassBeginInfo(
    Pool* pool,
    const VkRenderPassBeginInfo* from,
    VkRenderPassBeginInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->renderPass = from->renderPass;
    to->framebuffer = from->framebuffer;
    deepcopy_VkRect2D(pool, &from->renderArea, (VkRect2D*)(&to->renderArea));
    to->clearValueCount = from->clearValueCount;
    to->pClearValues = nullptr;
    if (from->pClearValues)
    {
        to->pClearValues = (VkClearValue*)pool->alloc(from->clearValueCount * sizeof(const VkClearValue));
        to->clearValueCount = from->clearValueCount;
        for (uint32_t i = 0; i < (uint32_t)from->clearValueCount; ++i)
        {
            deepcopy_VkClearValue(pool, from->pClearValues + i, (VkClearValue*)(to->pClearValues + i));
        }
    }
}

void deepcopy_VkDispatchIndirectCommand(
    Pool* pool,
    const VkDispatchIndirectCommand* from,
    VkDispatchIndirectCommand* to)
{
    to->x = from->x;
    to->y = from->y;
    to->z = from->z;
}

void deepcopy_VkDrawIndexedIndirectCommand(
    Pool* pool,
    const VkDrawIndexedIndirectCommand* from,
    VkDrawIndexedIndirectCommand* to)
{
    to->indexCount = from->indexCount;
    to->instanceCount = from->instanceCount;
    to->firstIndex = from->firstIndex;
    to->vertexOffset = from->vertexOffset;
    to->firstInstance = from->firstInstance;
}

void deepcopy_VkDrawIndirectCommand(
    Pool* pool,
    const VkDrawIndirectCommand* from,
    VkDrawIndirectCommand* to)
{
    to->vertexCount = from->vertexCount;
    to->instanceCount = from->instanceCount;
    to->firstVertex = from->firstVertex;
    to->firstInstance = from->firstInstance;
}

void deepcopy_VkBaseOutStructure(
    Pool* pool,
    const VkBaseOutStructure* from,
    VkBaseOutStructure* to)
{
    to->sType = from->sType;
    // TODO: Unsupported : VkBaseOutStructure* pNext
}

void deepcopy_VkBaseInStructure(
    Pool* pool,
    const VkBaseInStructure* from,
    VkBaseInStructure* to)
{
    to->sType = from->sType;
    // TODO: Unsupported : const VkBaseInStructure* pNext
}

#endif
#ifdef VK_VERSION_1_1
void deepcopy_VkPhysicalDeviceSubgroupProperties(
    Pool* pool,
    const VkPhysicalDeviceSubgroupProperties* from,
    VkPhysicalDeviceSubgroupProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->subgroupSize = from->subgroupSize;
    to->supportedStages = from->supportedStages;
    to->supportedOperations = from->supportedOperations;
    to->quadOperationsInAllStages = from->quadOperationsInAllStages;
}

void deepcopy_VkBindBufferMemoryInfo(
    Pool* pool,
    const VkBindBufferMemoryInfo* from,
    VkBindBufferMemoryInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->buffer = from->buffer;
    to->memory = from->memory;
    to->memoryOffset = from->memoryOffset;
}

void deepcopy_VkBindImageMemoryInfo(
    Pool* pool,
    const VkBindImageMemoryInfo* from,
    VkBindImageMemoryInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->image = from->image;
    to->memory = from->memory;
    to->memoryOffset = from->memoryOffset;
}

void deepcopy_VkPhysicalDevice16BitStorageFeatures(
    Pool* pool,
    const VkPhysicalDevice16BitStorageFeatures* from,
    VkPhysicalDevice16BitStorageFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->storageBuffer16BitAccess = from->storageBuffer16BitAccess;
    to->uniformAndStorageBuffer16BitAccess = from->uniformAndStorageBuffer16BitAccess;
    to->storagePushConstant16 = from->storagePushConstant16;
    to->storageInputOutput16 = from->storageInputOutput16;
}

void deepcopy_VkMemoryDedicatedRequirements(
    Pool* pool,
    const VkMemoryDedicatedRequirements* from,
    VkMemoryDedicatedRequirements* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->prefersDedicatedAllocation = from->prefersDedicatedAllocation;
    to->requiresDedicatedAllocation = from->requiresDedicatedAllocation;
}

void deepcopy_VkMemoryDedicatedAllocateInfo(
    Pool* pool,
    const VkMemoryDedicatedAllocateInfo* from,
    VkMemoryDedicatedAllocateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->image = from->image;
    to->buffer = from->buffer;
}

void deepcopy_VkMemoryAllocateFlagsInfo(
    Pool* pool,
    const VkMemoryAllocateFlagsInfo* from,
    VkMemoryAllocateFlagsInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->deviceMask = from->deviceMask;
}

void deepcopy_VkDeviceGroupRenderPassBeginInfo(
    Pool* pool,
    const VkDeviceGroupRenderPassBeginInfo* from,
    VkDeviceGroupRenderPassBeginInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->deviceMask = from->deviceMask;
    to->deviceRenderAreaCount = from->deviceRenderAreaCount;
    to->pDeviceRenderAreas = nullptr;
    if (from->pDeviceRenderAreas)
    {
        to->pDeviceRenderAreas = (VkRect2D*)pool->alloc(from->deviceRenderAreaCount * sizeof(const VkRect2D));
        to->deviceRenderAreaCount = from->deviceRenderAreaCount;
        for (uint32_t i = 0; i < (uint32_t)from->deviceRenderAreaCount; ++i)
        {
            deepcopy_VkRect2D(pool, from->pDeviceRenderAreas + i, (VkRect2D*)(to->pDeviceRenderAreas + i));
        }
    }
}

void deepcopy_VkDeviceGroupCommandBufferBeginInfo(
    Pool* pool,
    const VkDeviceGroupCommandBufferBeginInfo* from,
    VkDeviceGroupCommandBufferBeginInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->deviceMask = from->deviceMask;
}

void deepcopy_VkDeviceGroupSubmitInfo(
    Pool* pool,
    const VkDeviceGroupSubmitInfo* from,
    VkDeviceGroupSubmitInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->waitSemaphoreCount = from->waitSemaphoreCount;
    to->pWaitSemaphoreDeviceIndices = nullptr;
    if (from->pWaitSemaphoreDeviceIndices)
    {
        to->pWaitSemaphoreDeviceIndices = (uint32_t*)pool->dupArray(from->pWaitSemaphoreDeviceIndices, from->waitSemaphoreCount * sizeof(const uint32_t));
    }
    to->commandBufferCount = from->commandBufferCount;
    to->pCommandBufferDeviceMasks = nullptr;
    if (from->pCommandBufferDeviceMasks)
    {
        to->pCommandBufferDeviceMasks = (uint32_t*)pool->dupArray(from->pCommandBufferDeviceMasks, from->commandBufferCount * sizeof(const uint32_t));
    }
    to->signalSemaphoreCount = from->signalSemaphoreCount;
    to->pSignalSemaphoreDeviceIndices = nullptr;
    if (from->pSignalSemaphoreDeviceIndices)
    {
        to->pSignalSemaphoreDeviceIndices = (uint32_t*)pool->dupArray(from->pSignalSemaphoreDeviceIndices, from->signalSemaphoreCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkDeviceGroupBindSparseInfo(
    Pool* pool,
    const VkDeviceGroupBindSparseInfo* from,
    VkDeviceGroupBindSparseInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->resourceDeviceIndex = from->resourceDeviceIndex;
    to->memoryDeviceIndex = from->memoryDeviceIndex;
}

void deepcopy_VkBindBufferMemoryDeviceGroupInfo(
    Pool* pool,
    const VkBindBufferMemoryDeviceGroupInfo* from,
    VkBindBufferMemoryDeviceGroupInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->deviceIndexCount = from->deviceIndexCount;
    to->pDeviceIndices = nullptr;
    if (from->pDeviceIndices)
    {
        to->pDeviceIndices = (uint32_t*)pool->dupArray(from->pDeviceIndices, from->deviceIndexCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkBindImageMemoryDeviceGroupInfo(
    Pool* pool,
    const VkBindImageMemoryDeviceGroupInfo* from,
    VkBindImageMemoryDeviceGroupInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->deviceIndexCount = from->deviceIndexCount;
    to->pDeviceIndices = nullptr;
    if (from->pDeviceIndices)
    {
        to->pDeviceIndices = (uint32_t*)pool->dupArray(from->pDeviceIndices, from->deviceIndexCount * sizeof(const uint32_t));
    }
    to->splitInstanceBindRegionCount = from->splitInstanceBindRegionCount;
    to->pSplitInstanceBindRegions = nullptr;
    if (from->pSplitInstanceBindRegions)
    {
        to->pSplitInstanceBindRegions = (VkRect2D*)pool->alloc(from->splitInstanceBindRegionCount * sizeof(const VkRect2D));
        to->splitInstanceBindRegionCount = from->splitInstanceBindRegionCount;
        for (uint32_t i = 0; i < (uint32_t)from->splitInstanceBindRegionCount; ++i)
        {
            deepcopy_VkRect2D(pool, from->pSplitInstanceBindRegions + i, (VkRect2D*)(to->pSplitInstanceBindRegions + i));
        }
    }
}

void deepcopy_VkPhysicalDeviceGroupProperties(
    Pool* pool,
    const VkPhysicalDeviceGroupProperties* from,
    VkPhysicalDeviceGroupProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->physicalDeviceCount = from->physicalDeviceCount;
    memcpy(to->physicalDevices, from->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    to->subsetAllocation = from->subsetAllocation;
}

void deepcopy_VkDeviceGroupDeviceCreateInfo(
    Pool* pool,
    const VkDeviceGroupDeviceCreateInfo* from,
    VkDeviceGroupDeviceCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->physicalDeviceCount = from->physicalDeviceCount;
    to->pPhysicalDevices = nullptr;
    if (from->pPhysicalDevices)
    {
        to->pPhysicalDevices = (VkPhysicalDevice*)pool->dupArray(from->pPhysicalDevices, from->physicalDeviceCount * sizeof(const VkPhysicalDevice));
    }
}

void deepcopy_VkBufferMemoryRequirementsInfo2(
    Pool* pool,
    const VkBufferMemoryRequirementsInfo2* from,
    VkBufferMemoryRequirementsInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->buffer = from->buffer;
}

void deepcopy_VkImageMemoryRequirementsInfo2(
    Pool* pool,
    const VkImageMemoryRequirementsInfo2* from,
    VkImageMemoryRequirementsInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->image = from->image;
}

void deepcopy_VkImageSparseMemoryRequirementsInfo2(
    Pool* pool,
    const VkImageSparseMemoryRequirementsInfo2* from,
    VkImageSparseMemoryRequirementsInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->image = from->image;
}

void deepcopy_VkMemoryRequirements2(
    Pool* pool,
    const VkMemoryRequirements2* from,
    VkMemoryRequirements2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkMemoryRequirements(pool, &from->memoryRequirements, (VkMemoryRequirements*)(&to->memoryRequirements));
}

void deepcopy_VkSparseImageMemoryRequirements2(
    Pool* pool,
    const VkSparseImageMemoryRequirements2* from,
    VkSparseImageMemoryRequirements2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkSparseImageMemoryRequirements(pool, &from->memoryRequirements, (VkSparseImageMemoryRequirements*)(&to->memoryRequirements));
}

void deepcopy_VkPhysicalDeviceFeatures2(
    Pool* pool,
    const VkPhysicalDeviceFeatures2* from,
    VkPhysicalDeviceFeatures2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkPhysicalDeviceFeatures(pool, &from->features, (VkPhysicalDeviceFeatures*)(&to->features));
}

void deepcopy_VkPhysicalDeviceProperties2(
    Pool* pool,
    const VkPhysicalDeviceProperties2* from,
    VkPhysicalDeviceProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkPhysicalDeviceProperties(pool, &from->properties, (VkPhysicalDeviceProperties*)(&to->properties));
}

void deepcopy_VkFormatProperties2(
    Pool* pool,
    const VkFormatProperties2* from,
    VkFormatProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkFormatProperties(pool, &from->formatProperties, (VkFormatProperties*)(&to->formatProperties));
}

void deepcopy_VkImageFormatProperties2(
    Pool* pool,
    const VkImageFormatProperties2* from,
    VkImageFormatProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkImageFormatProperties(pool, &from->imageFormatProperties, (VkImageFormatProperties*)(&to->imageFormatProperties));
}

void deepcopy_VkPhysicalDeviceImageFormatInfo2(
    Pool* pool,
    const VkPhysicalDeviceImageFormatInfo2* from,
    VkPhysicalDeviceImageFormatInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->format = from->format;
    to->type = from->type;
    to->tiling = from->tiling;
    to->usage = from->usage;
    to->flags = from->flags;
}

void deepcopy_VkQueueFamilyProperties2(
    Pool* pool,
    const VkQueueFamilyProperties2* from,
    VkQueueFamilyProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkQueueFamilyProperties(pool, &from->queueFamilyProperties, (VkQueueFamilyProperties*)(&to->queueFamilyProperties));
}

void deepcopy_VkPhysicalDeviceMemoryProperties2(
    Pool* pool,
    const VkPhysicalDeviceMemoryProperties2* from,
    VkPhysicalDeviceMemoryProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkPhysicalDeviceMemoryProperties(pool, &from->memoryProperties, (VkPhysicalDeviceMemoryProperties*)(&to->memoryProperties));
}

void deepcopy_VkSparseImageFormatProperties2(
    Pool* pool,
    const VkSparseImageFormatProperties2* from,
    VkSparseImageFormatProperties2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkSparseImageFormatProperties(pool, &from->properties, (VkSparseImageFormatProperties*)(&to->properties));
}

void deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(
    Pool* pool,
    const VkPhysicalDeviceSparseImageFormatInfo2* from,
    VkPhysicalDeviceSparseImageFormatInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->format = from->format;
    to->type = from->type;
    to->samples = from->samples;
    to->usage = from->usage;
    to->tiling = from->tiling;
}

void deepcopy_VkPhysicalDevicePointClippingProperties(
    Pool* pool,
    const VkPhysicalDevicePointClippingProperties* from,
    VkPhysicalDevicePointClippingProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pointClippingBehavior = from->pointClippingBehavior;
}

void deepcopy_VkInputAttachmentAspectReference(
    Pool* pool,
    const VkInputAttachmentAspectReference* from,
    VkInputAttachmentAspectReference* to)
{
    to->subpass = from->subpass;
    to->inputAttachmentIndex = from->inputAttachmentIndex;
    to->aspectMask = from->aspectMask;
}

void deepcopy_VkRenderPassInputAttachmentAspectCreateInfo(
    Pool* pool,
    const VkRenderPassInputAttachmentAspectCreateInfo* from,
    VkRenderPassInputAttachmentAspectCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->aspectReferenceCount = from->aspectReferenceCount;
    to->pAspectReferences = nullptr;
    if (from->pAspectReferences)
    {
        to->pAspectReferences = (VkInputAttachmentAspectReference*)pool->alloc(from->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
        to->aspectReferenceCount = from->aspectReferenceCount;
        for (uint32_t i = 0; i < (uint32_t)from->aspectReferenceCount; ++i)
        {
            deepcopy_VkInputAttachmentAspectReference(pool, from->pAspectReferences + i, (VkInputAttachmentAspectReference*)(to->pAspectReferences + i));
        }
    }
}

void deepcopy_VkImageViewUsageCreateInfo(
    Pool* pool,
    const VkImageViewUsageCreateInfo* from,
    VkImageViewUsageCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->usage = from->usage;
}

void deepcopy_VkPipelineTessellationDomainOriginStateCreateInfo(
    Pool* pool,
    const VkPipelineTessellationDomainOriginStateCreateInfo* from,
    VkPipelineTessellationDomainOriginStateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->domainOrigin = from->domainOrigin;
}

void deepcopy_VkRenderPassMultiviewCreateInfo(
    Pool* pool,
    const VkRenderPassMultiviewCreateInfo* from,
    VkRenderPassMultiviewCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->subpassCount = from->subpassCount;
    to->pViewMasks = nullptr;
    if (from->pViewMasks)
    {
        to->pViewMasks = (uint32_t*)pool->dupArray(from->pViewMasks, from->subpassCount * sizeof(const uint32_t));
    }
    to->dependencyCount = from->dependencyCount;
    to->pViewOffsets = nullptr;
    if (from->pViewOffsets)
    {
        to->pViewOffsets = (int32_t*)pool->dupArray(from->pViewOffsets, from->dependencyCount * sizeof(const int32_t));
    }
    to->correlationMaskCount = from->correlationMaskCount;
    to->pCorrelationMasks = nullptr;
    if (from->pCorrelationMasks)
    {
        to->pCorrelationMasks = (uint32_t*)pool->dupArray(from->pCorrelationMasks, from->correlationMaskCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkPhysicalDeviceMultiviewFeatures(
    Pool* pool,
    const VkPhysicalDeviceMultiviewFeatures* from,
    VkPhysicalDeviceMultiviewFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->multiview = from->multiview;
    to->multiviewGeometryShader = from->multiviewGeometryShader;
    to->multiviewTessellationShader = from->multiviewTessellationShader;
}

void deepcopy_VkPhysicalDeviceMultiviewProperties(
    Pool* pool,
    const VkPhysicalDeviceMultiviewProperties* from,
    VkPhysicalDeviceMultiviewProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxMultiviewViewCount = from->maxMultiviewViewCount;
    to->maxMultiviewInstanceIndex = from->maxMultiviewInstanceIndex;
}

void deepcopy_VkPhysicalDeviceVariablePointerFeatures(
    Pool* pool,
    const VkPhysicalDeviceVariablePointerFeatures* from,
    VkPhysicalDeviceVariablePointerFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->variablePointersStorageBuffer = from->variablePointersStorageBuffer;
    to->variablePointers = from->variablePointers;
}

void deepcopy_VkPhysicalDeviceProtectedMemoryFeatures(
    Pool* pool,
    const VkPhysicalDeviceProtectedMemoryFeatures* from,
    VkPhysicalDeviceProtectedMemoryFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->protectedMemory = from->protectedMemory;
}

void deepcopy_VkPhysicalDeviceProtectedMemoryProperties(
    Pool* pool,
    const VkPhysicalDeviceProtectedMemoryProperties* from,
    VkPhysicalDeviceProtectedMemoryProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->protectedNoFault = from->protectedNoFault;
}

void deepcopy_VkDeviceQueueInfo2(
    Pool* pool,
    const VkDeviceQueueInfo2* from,
    VkDeviceQueueInfo2* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->queueFamilyIndex = from->queueFamilyIndex;
    to->queueIndex = from->queueIndex;
}

void deepcopy_VkProtectedSubmitInfo(
    Pool* pool,
    const VkProtectedSubmitInfo* from,
    VkProtectedSubmitInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->protectedSubmit = from->protectedSubmit;
}

void deepcopy_VkSamplerYcbcrConversionCreateInfo(
    Pool* pool,
    const VkSamplerYcbcrConversionCreateInfo* from,
    VkSamplerYcbcrConversionCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->format = from->format;
    to->ycbcrModel = from->ycbcrModel;
    to->ycbcrRange = from->ycbcrRange;
    deepcopy_VkComponentMapping(pool, &from->components, (VkComponentMapping*)(&to->components));
    to->xChromaOffset = from->xChromaOffset;
    to->yChromaOffset = from->yChromaOffset;
    to->chromaFilter = from->chromaFilter;
    to->forceExplicitReconstruction = from->forceExplicitReconstruction;
}

void deepcopy_VkSamplerYcbcrConversionInfo(
    Pool* pool,
    const VkSamplerYcbcrConversionInfo* from,
    VkSamplerYcbcrConversionInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->conversion = from->conversion;
}

void deepcopy_VkBindImagePlaneMemoryInfo(
    Pool* pool,
    const VkBindImagePlaneMemoryInfo* from,
    VkBindImagePlaneMemoryInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->planeAspect = from->planeAspect;
}

void deepcopy_VkImagePlaneMemoryRequirementsInfo(
    Pool* pool,
    const VkImagePlaneMemoryRequirementsInfo* from,
    VkImagePlaneMemoryRequirementsInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->planeAspect = from->planeAspect;
}

void deepcopy_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    Pool* pool,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* from,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->samplerYcbcrConversion = from->samplerYcbcrConversion;
}

void deepcopy_VkSamplerYcbcrConversionImageFormatProperties(
    Pool* pool,
    const VkSamplerYcbcrConversionImageFormatProperties* from,
    VkSamplerYcbcrConversionImageFormatProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->combinedImageSamplerDescriptorCount = from->combinedImageSamplerDescriptorCount;
}

void deepcopy_VkDescriptorUpdateTemplateEntry(
    Pool* pool,
    const VkDescriptorUpdateTemplateEntry* from,
    VkDescriptorUpdateTemplateEntry* to)
{
    to->dstBinding = from->dstBinding;
    to->dstArrayElement = from->dstArrayElement;
    to->descriptorCount = from->descriptorCount;
    to->descriptorType = from->descriptorType;
    to->offset = from->offset;
    to->stride = from->stride;
}

void deepcopy_VkDescriptorUpdateTemplateCreateInfo(
    Pool* pool,
    const VkDescriptorUpdateTemplateCreateInfo* from,
    VkDescriptorUpdateTemplateCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->descriptorUpdateEntryCount = from->descriptorUpdateEntryCount;
    to->pDescriptorUpdateEntries = nullptr;
    if (from->pDescriptorUpdateEntries)
    {
        to->pDescriptorUpdateEntries = (VkDescriptorUpdateTemplateEntry*)pool->alloc(from->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
        to->descriptorUpdateEntryCount = from->descriptorUpdateEntryCount;
        for (uint32_t i = 0; i < (uint32_t)from->descriptorUpdateEntryCount; ++i)
        {
            deepcopy_VkDescriptorUpdateTemplateEntry(pool, from->pDescriptorUpdateEntries + i, (VkDescriptorUpdateTemplateEntry*)(to->pDescriptorUpdateEntries + i));
        }
    }
    to->templateType = from->templateType;
    to->descriptorSetLayout = from->descriptorSetLayout;
    to->pipelineBindPoint = from->pipelineBindPoint;
    to->pipelineLayout = from->pipelineLayout;
    to->set = from->set;
}

void deepcopy_VkExternalMemoryProperties(
    Pool* pool,
    const VkExternalMemoryProperties* from,
    VkExternalMemoryProperties* to)
{
    to->externalMemoryFeatures = from->externalMemoryFeatures;
    to->exportFromImportedHandleTypes = from->exportFromImportedHandleTypes;
    to->compatibleHandleTypes = from->compatibleHandleTypes;
}

void deepcopy_VkPhysicalDeviceExternalImageFormatInfo(
    Pool* pool,
    const VkPhysicalDeviceExternalImageFormatInfo* from,
    VkPhysicalDeviceExternalImageFormatInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
}

void deepcopy_VkExternalImageFormatProperties(
    Pool* pool,
    const VkExternalImageFormatProperties* from,
    VkExternalImageFormatProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkExternalMemoryProperties(pool, &from->externalMemoryProperties, (VkExternalMemoryProperties*)(&to->externalMemoryProperties));
}

void deepcopy_VkPhysicalDeviceExternalBufferInfo(
    Pool* pool,
    const VkPhysicalDeviceExternalBufferInfo* from,
    VkPhysicalDeviceExternalBufferInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->usage = from->usage;
    to->handleType = from->handleType;
}

void deepcopy_VkExternalBufferProperties(
    Pool* pool,
    const VkExternalBufferProperties* from,
    VkExternalBufferProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkExternalMemoryProperties(pool, &from->externalMemoryProperties, (VkExternalMemoryProperties*)(&to->externalMemoryProperties));
}

void deepcopy_VkPhysicalDeviceIDProperties(
    Pool* pool,
    const VkPhysicalDeviceIDProperties* from,
    VkPhysicalDeviceIDProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    memcpy(to->deviceUUID, from->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    memcpy(to->driverUUID, from->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    memcpy(to->deviceLUID, from->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    to->deviceNodeMask = from->deviceNodeMask;
    to->deviceLUIDValid = from->deviceLUIDValid;
}

void deepcopy_VkExternalMemoryImageCreateInfo(
    Pool* pool,
    const VkExternalMemoryImageCreateInfo* from,
    VkExternalMemoryImageCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkExternalMemoryBufferCreateInfo(
    Pool* pool,
    const VkExternalMemoryBufferCreateInfo* from,
    VkExternalMemoryBufferCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkExportMemoryAllocateInfo(
    Pool* pool,
    const VkExportMemoryAllocateInfo* from,
    VkExportMemoryAllocateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkPhysicalDeviceExternalFenceInfo(
    Pool* pool,
    const VkPhysicalDeviceExternalFenceInfo* from,
    VkPhysicalDeviceExternalFenceInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
}

void deepcopy_VkExternalFenceProperties(
    Pool* pool,
    const VkExternalFenceProperties* from,
    VkExternalFenceProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->exportFromImportedHandleTypes = from->exportFromImportedHandleTypes;
    to->compatibleHandleTypes = from->compatibleHandleTypes;
    to->externalFenceFeatures = from->externalFenceFeatures;
}

void deepcopy_VkExportFenceCreateInfo(
    Pool* pool,
    const VkExportFenceCreateInfo* from,
    VkExportFenceCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkExportSemaphoreCreateInfo(
    Pool* pool,
    const VkExportSemaphoreCreateInfo* from,
    VkExportSemaphoreCreateInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(
    Pool* pool,
    const VkPhysicalDeviceExternalSemaphoreInfo* from,
    VkPhysicalDeviceExternalSemaphoreInfo* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
}

void deepcopy_VkExternalSemaphoreProperties(
    Pool* pool,
    const VkExternalSemaphoreProperties* from,
    VkExternalSemaphoreProperties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->exportFromImportedHandleTypes = from->exportFromImportedHandleTypes;
    to->compatibleHandleTypes = from->compatibleHandleTypes;
    to->externalSemaphoreFeatures = from->externalSemaphoreFeatures;
}

void deepcopy_VkPhysicalDeviceMaintenance3Properties(
    Pool* pool,
    const VkPhysicalDeviceMaintenance3Properties* from,
    VkPhysicalDeviceMaintenance3Properties* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxPerSetDescriptors = from->maxPerSetDescriptors;
    to->maxMemoryAllocationSize = from->maxMemoryAllocationSize;
}

void deepcopy_VkDescriptorSetLayoutSupport(
    Pool* pool,
    const VkDescriptorSetLayoutSupport* from,
    VkDescriptorSetLayoutSupport* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->supported = from->supported;
}

void deepcopy_VkPhysicalDeviceShaderDrawParameterFeatures(
    Pool* pool,
    const VkPhysicalDeviceShaderDrawParameterFeatures* from,
    VkPhysicalDeviceShaderDrawParameterFeatures* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->shaderDrawParameters = from->shaderDrawParameters;
}

#endif
#ifdef VK_KHR_surface
void deepcopy_VkSurfaceCapabilitiesKHR(
    Pool* pool,
    const VkSurfaceCapabilitiesKHR* from,
    VkSurfaceCapabilitiesKHR* to)
{
    to->minImageCount = from->minImageCount;
    to->maxImageCount = from->maxImageCount;
    deepcopy_VkExtent2D(pool, &from->currentExtent, (VkExtent2D*)(&to->currentExtent));
    deepcopy_VkExtent2D(pool, &from->minImageExtent, (VkExtent2D*)(&to->minImageExtent));
    deepcopy_VkExtent2D(pool, &from->maxImageExtent, (VkExtent2D*)(&to->maxImageExtent));
    to->maxImageArrayLayers = from->maxImageArrayLayers;
    to->supportedTransforms = from->supportedTransforms;
    to->currentTransform = from->currentTransform;
    to->supportedCompositeAlpha = from->supportedCompositeAlpha;
    to->supportedUsageFlags = from->supportedUsageFlags;
}

void deepcopy_VkSurfaceFormatKHR(
    Pool* pool,
    const VkSurfaceFormatKHR* from,
    VkSurfaceFormatKHR* to)
{
    to->format = from->format;
    to->colorSpace = from->colorSpace;
}

#endif
#ifdef VK_KHR_swapchain
void deepcopy_VkSwapchainCreateInfoKHR(
    Pool* pool,
    const VkSwapchainCreateInfoKHR* from,
    VkSwapchainCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->surface = from->surface;
    to->minImageCount = from->minImageCount;
    to->imageFormat = from->imageFormat;
    to->imageColorSpace = from->imageColorSpace;
    deepcopy_VkExtent2D(pool, &from->imageExtent, (VkExtent2D*)(&to->imageExtent));
    to->imageArrayLayers = from->imageArrayLayers;
    to->imageUsage = from->imageUsage;
    to->imageSharingMode = from->imageSharingMode;
    to->queueFamilyIndexCount = from->queueFamilyIndexCount;
    to->pQueueFamilyIndices = nullptr;
    if (from->pQueueFamilyIndices)
    {
        to->pQueueFamilyIndices = (uint32_t*)pool->dupArray(from->pQueueFamilyIndices, from->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    to->preTransform = from->preTransform;
    to->compositeAlpha = from->compositeAlpha;
    to->presentMode = from->presentMode;
    to->clipped = from->clipped;
    to->oldSwapchain = from->oldSwapchain;
}

void deepcopy_VkPresentInfoKHR(
    Pool* pool,
    const VkPresentInfoKHR* from,
    VkPresentInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->waitSemaphoreCount = from->waitSemaphoreCount;
    to->pWaitSemaphores = nullptr;
    if (from->pWaitSemaphores)
    {
        to->pWaitSemaphores = (VkSemaphore*)pool->dupArray(from->pWaitSemaphores, from->waitSemaphoreCount * sizeof(const VkSemaphore));
    }
    to->swapchainCount = from->swapchainCount;
    to->pSwapchains = nullptr;
    if (from->pSwapchains)
    {
        to->pSwapchains = (VkSwapchainKHR*)pool->dupArray(from->pSwapchains, from->swapchainCount * sizeof(const VkSwapchainKHR));
    }
    to->pImageIndices = nullptr;
    if (from->pImageIndices)
    {
        to->pImageIndices = (uint32_t*)pool->dupArray(from->pImageIndices, from->swapchainCount * sizeof(const uint32_t));
    }
    to->pResults = nullptr;
    if (from->pResults)
    {
        to->pResults = (VkResult*)pool->dupArray(from->pResults, from->swapchainCount * sizeof(VkResult));
    }
}

void deepcopy_VkImageSwapchainCreateInfoKHR(
    Pool* pool,
    const VkImageSwapchainCreateInfoKHR* from,
    VkImageSwapchainCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchain = from->swapchain;
}

void deepcopy_VkBindImageMemorySwapchainInfoKHR(
    Pool* pool,
    const VkBindImageMemorySwapchainInfoKHR* from,
    VkBindImageMemorySwapchainInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchain = from->swapchain;
    to->imageIndex = from->imageIndex;
}

void deepcopy_VkAcquireNextImageInfoKHR(
    Pool* pool,
    const VkAcquireNextImageInfoKHR* from,
    VkAcquireNextImageInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchain = from->swapchain;
    to->timeout = from->timeout;
    to->semaphore = from->semaphore;
    to->fence = from->fence;
    to->deviceMask = from->deviceMask;
}

void deepcopy_VkDeviceGroupPresentCapabilitiesKHR(
    Pool* pool,
    const VkDeviceGroupPresentCapabilitiesKHR* from,
    VkDeviceGroupPresentCapabilitiesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    memcpy(to->presentMask, from->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    to->modes = from->modes;
}

void deepcopy_VkDeviceGroupPresentInfoKHR(
    Pool* pool,
    const VkDeviceGroupPresentInfoKHR* from,
    VkDeviceGroupPresentInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchainCount = from->swapchainCount;
    to->pDeviceMasks = nullptr;
    if (from->pDeviceMasks)
    {
        to->pDeviceMasks = (uint32_t*)pool->dupArray(from->pDeviceMasks, from->swapchainCount * sizeof(const uint32_t));
    }
    to->mode = from->mode;
}

void deepcopy_VkDeviceGroupSwapchainCreateInfoKHR(
    Pool* pool,
    const VkDeviceGroupSwapchainCreateInfoKHR* from,
    VkDeviceGroupSwapchainCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->modes = from->modes;
}

#endif
#ifdef VK_KHR_display
void deepcopy_VkDisplayPropertiesKHR(
    Pool* pool,
    const VkDisplayPropertiesKHR* from,
    VkDisplayPropertiesKHR* to)
{
    to->display = from->display;
    to->displayName = nullptr;
    if (from->displayName)
    {
        to->displayName = pool->strDup(from->displayName);
    }
    deepcopy_VkExtent2D(pool, &from->physicalDimensions, (VkExtent2D*)(&to->physicalDimensions));
    deepcopy_VkExtent2D(pool, &from->physicalResolution, (VkExtent2D*)(&to->physicalResolution));
    to->supportedTransforms = from->supportedTransforms;
    to->planeReorderPossible = from->planeReorderPossible;
    to->persistentContent = from->persistentContent;
}

void deepcopy_VkDisplayModeParametersKHR(
    Pool* pool,
    const VkDisplayModeParametersKHR* from,
    VkDisplayModeParametersKHR* to)
{
    deepcopy_VkExtent2D(pool, &from->visibleRegion, (VkExtent2D*)(&to->visibleRegion));
    to->refreshRate = from->refreshRate;
}

void deepcopy_VkDisplayModePropertiesKHR(
    Pool* pool,
    const VkDisplayModePropertiesKHR* from,
    VkDisplayModePropertiesKHR* to)
{
    to->displayMode = from->displayMode;
    deepcopy_VkDisplayModeParametersKHR(pool, &from->parameters, (VkDisplayModeParametersKHR*)(&to->parameters));
}

void deepcopy_VkDisplayModeCreateInfoKHR(
    Pool* pool,
    const VkDisplayModeCreateInfoKHR* from,
    VkDisplayModeCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    deepcopy_VkDisplayModeParametersKHR(pool, &from->parameters, (VkDisplayModeParametersKHR*)(&to->parameters));
}

void deepcopy_VkDisplayPlaneCapabilitiesKHR(
    Pool* pool,
    const VkDisplayPlaneCapabilitiesKHR* from,
    VkDisplayPlaneCapabilitiesKHR* to)
{
    to->supportedAlpha = from->supportedAlpha;
    deepcopy_VkOffset2D(pool, &from->minSrcPosition, (VkOffset2D*)(&to->minSrcPosition));
    deepcopy_VkOffset2D(pool, &from->maxSrcPosition, (VkOffset2D*)(&to->maxSrcPosition));
    deepcopy_VkExtent2D(pool, &from->minSrcExtent, (VkExtent2D*)(&to->minSrcExtent));
    deepcopy_VkExtent2D(pool, &from->maxSrcExtent, (VkExtent2D*)(&to->maxSrcExtent));
    deepcopy_VkOffset2D(pool, &from->minDstPosition, (VkOffset2D*)(&to->minDstPosition));
    deepcopy_VkOffset2D(pool, &from->maxDstPosition, (VkOffset2D*)(&to->maxDstPosition));
    deepcopy_VkExtent2D(pool, &from->minDstExtent, (VkExtent2D*)(&to->minDstExtent));
    deepcopy_VkExtent2D(pool, &from->maxDstExtent, (VkExtent2D*)(&to->maxDstExtent));
}

void deepcopy_VkDisplayPlanePropertiesKHR(
    Pool* pool,
    const VkDisplayPlanePropertiesKHR* from,
    VkDisplayPlanePropertiesKHR* to)
{
    to->currentDisplay = from->currentDisplay;
    to->currentStackIndex = from->currentStackIndex;
}

void deepcopy_VkDisplaySurfaceCreateInfoKHR(
    Pool* pool,
    const VkDisplaySurfaceCreateInfoKHR* from,
    VkDisplaySurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->displayMode = from->displayMode;
    to->planeIndex = from->planeIndex;
    to->planeStackIndex = from->planeStackIndex;
    to->transform = from->transform;
    to->globalAlpha = from->globalAlpha;
    to->alphaMode = from->alphaMode;
    deepcopy_VkExtent2D(pool, &from->imageExtent, (VkExtent2D*)(&to->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void deepcopy_VkDisplayPresentInfoKHR(
    Pool* pool,
    const VkDisplayPresentInfoKHR* from,
    VkDisplayPresentInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkRect2D(pool, &from->srcRect, (VkRect2D*)(&to->srcRect));
    deepcopy_VkRect2D(pool, &from->dstRect, (VkRect2D*)(&to->dstRect));
    to->persistent = from->persistent;
}

#endif
#ifdef VK_KHR_xlib_surface
void deepcopy_VkXlibSurfaceCreateInfoKHR(
    Pool* pool,
    const VkXlibSurfaceCreateInfoKHR* from,
    VkXlibSurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->dpy = nullptr;
    if (from->dpy)
    {
        to->dpy = (Display*)pool->dupArray(from->dpy, sizeof(Display));
    }
    to->window = from->window;
}

#endif
#ifdef VK_KHR_xcb_surface
void deepcopy_VkXcbSurfaceCreateInfoKHR(
    Pool* pool,
    const VkXcbSurfaceCreateInfoKHR* from,
    VkXcbSurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->connection = nullptr;
    if (from->connection)
    {
        to->connection = (xcb_connection_t*)pool->dupArray(from->connection, sizeof(xcb_connection_t));
    }
    to->window = from->window;
}

#endif
#ifdef VK_KHR_wayland_surface
void deepcopy_VkWaylandSurfaceCreateInfoKHR(
    Pool* pool,
    const VkWaylandSurfaceCreateInfoKHR* from,
    VkWaylandSurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->display = nullptr;
    if (from->display)
    {
        to->display = (wl_display*)pool->dupArray(from->display, sizeof(wl_display));
    }
    to->surface = nullptr;
    if (from->surface)
    {
        to->surface = (wl_surface*)pool->dupArray(from->surface, sizeof(wl_surface));
    }
}

#endif
#ifdef VK_KHR_mir_surface
void deepcopy_VkMirSurfaceCreateInfoKHR(
    Pool* pool,
    const VkMirSurfaceCreateInfoKHR* from,
    VkMirSurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->connection = nullptr;
    if (from->connection)
    {
        to->connection = (MirConnection*)pool->dupArray(from->connection, sizeof(MirConnection));
    }
    to->mirSurface = nullptr;
    if (from->mirSurface)
    {
        to->mirSurface = (MirSurface*)pool->dupArray(from->mirSurface, sizeof(MirSurface));
    }
}

#endif
#ifdef VK_KHR_android_surface
void deepcopy_VkAndroidSurfaceCreateInfoKHR(
    Pool* pool,
    const VkAndroidSurfaceCreateInfoKHR* from,
    VkAndroidSurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->window = nullptr;
    if (from->window)
    {
        to->window = (ANativeWindow*)pool->dupArray(from->window, sizeof(ANativeWindow));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void deepcopy_VkWin32SurfaceCreateInfoKHR(
    Pool* pool,
    const VkWin32SurfaceCreateInfoKHR* from,
    VkWin32SurfaceCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->hinstance = from->hinstance;
    to->hwnd = from->hwnd;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void deepcopy_VkImportMemoryWin32HandleInfoKHR(
    Pool* pool,
    const VkImportMemoryWin32HandleInfoKHR* from,
    VkImportMemoryWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
    to->handle = from->handle;
    to->name = from->name;
}

void deepcopy_VkExportMemoryWin32HandleInfoKHR(
    Pool* pool,
    const VkExportMemoryWin32HandleInfoKHR* from,
    VkExportMemoryWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pAttributes = nullptr;
    if (from->pAttributes)
    {
        to->pAttributes = (SECURITY_ATTRIBUTES*)pool->dupArray(from->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    to->dwAccess = from->dwAccess;
    to->name = from->name;
}

void deepcopy_VkMemoryWin32HandlePropertiesKHR(
    Pool* pool,
    const VkMemoryWin32HandlePropertiesKHR* from,
    VkMemoryWin32HandlePropertiesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memoryTypeBits = from->memoryTypeBits;
}

void deepcopy_VkMemoryGetWin32HandleInfoKHR(
    Pool* pool,
    const VkMemoryGetWin32HandleInfoKHR* from,
    VkMemoryGetWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memory = from->memory;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_external_memory_fd
void deepcopy_VkImportMemoryFdInfoKHR(
    Pool* pool,
    const VkImportMemoryFdInfoKHR* from,
    VkImportMemoryFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
    to->fd = from->fd;
}

void deepcopy_VkMemoryFdPropertiesKHR(
    Pool* pool,
    const VkMemoryFdPropertiesKHR* from,
    VkMemoryFdPropertiesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memoryTypeBits = from->memoryTypeBits;
}

void deepcopy_VkMemoryGetFdInfoKHR(
    Pool* pool,
    const VkMemoryGetFdInfoKHR* from,
    VkMemoryGetFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memory = from->memory;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void deepcopy_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    Pool* pool,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* from,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->acquireCount = from->acquireCount;
    to->pAcquireSyncs = nullptr;
    if (from->pAcquireSyncs)
    {
        to->pAcquireSyncs = (VkDeviceMemory*)pool->dupArray(from->pAcquireSyncs, from->acquireCount * sizeof(const VkDeviceMemory));
    }
    to->pAcquireKeys = nullptr;
    if (from->pAcquireKeys)
    {
        to->pAcquireKeys = (uint64_t*)pool->dupArray(from->pAcquireKeys, from->acquireCount * sizeof(const uint64_t));
    }
    to->pAcquireTimeouts = nullptr;
    if (from->pAcquireTimeouts)
    {
        to->pAcquireTimeouts = (uint32_t*)pool->dupArray(from->pAcquireTimeouts, from->acquireCount * sizeof(const uint32_t));
    }
    to->releaseCount = from->releaseCount;
    to->pReleaseSyncs = nullptr;
    if (from->pReleaseSyncs)
    {
        to->pReleaseSyncs = (VkDeviceMemory*)pool->dupArray(from->pReleaseSyncs, from->releaseCount * sizeof(const VkDeviceMemory));
    }
    to->pReleaseKeys = nullptr;
    if (from->pReleaseKeys)
    {
        to->pReleaseKeys = (uint64_t*)pool->dupArray(from->pReleaseKeys, from->releaseCount * sizeof(const uint64_t));
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void deepcopy_VkImportSemaphoreWin32HandleInfoKHR(
    Pool* pool,
    const VkImportSemaphoreWin32HandleInfoKHR* from,
    VkImportSemaphoreWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->semaphore = from->semaphore;
    to->flags = from->flags;
    to->handleType = from->handleType;
    to->handle = from->handle;
    to->name = from->name;
}

void deepcopy_VkExportSemaphoreWin32HandleInfoKHR(
    Pool* pool,
    const VkExportSemaphoreWin32HandleInfoKHR* from,
    VkExportSemaphoreWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pAttributes = nullptr;
    if (from->pAttributes)
    {
        to->pAttributes = (SECURITY_ATTRIBUTES*)pool->dupArray(from->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    to->dwAccess = from->dwAccess;
    to->name = from->name;
}

void deepcopy_VkD3D12FenceSubmitInfoKHR(
    Pool* pool,
    const VkD3D12FenceSubmitInfoKHR* from,
    VkD3D12FenceSubmitInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->waitSemaphoreValuesCount = from->waitSemaphoreValuesCount;
    to->pWaitSemaphoreValues = nullptr;
    if (from->pWaitSemaphoreValues)
    {
        to->pWaitSemaphoreValues = (uint64_t*)pool->dupArray(from->pWaitSemaphoreValues, from->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    to->signalSemaphoreValuesCount = from->signalSemaphoreValuesCount;
    to->pSignalSemaphoreValues = nullptr;
    if (from->pSignalSemaphoreValues)
    {
        to->pSignalSemaphoreValues = (uint64_t*)pool->dupArray(from->pSignalSemaphoreValues, from->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void deepcopy_VkSemaphoreGetWin32HandleInfoKHR(
    Pool* pool,
    const VkSemaphoreGetWin32HandleInfoKHR* from,
    VkSemaphoreGetWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->semaphore = from->semaphore;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void deepcopy_VkImportSemaphoreFdInfoKHR(
    Pool* pool,
    const VkImportSemaphoreFdInfoKHR* from,
    VkImportSemaphoreFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->semaphore = from->semaphore;
    to->flags = from->flags;
    to->handleType = from->handleType;
    to->fd = from->fd;
}

void deepcopy_VkSemaphoreGetFdInfoKHR(
    Pool* pool,
    const VkSemaphoreGetFdInfoKHR* from,
    VkSemaphoreGetFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->semaphore = from->semaphore;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_push_descriptor
void deepcopy_VkPhysicalDevicePushDescriptorPropertiesKHR(
    Pool* pool,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* from,
    VkPhysicalDevicePushDescriptorPropertiesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxPushDescriptors = from->maxPushDescriptors;
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void deepcopy_VkRectLayerKHR(
    Pool* pool,
    const VkRectLayerKHR* from,
    VkRectLayerKHR* to)
{
    deepcopy_VkOffset2D(pool, &from->offset, (VkOffset2D*)(&to->offset));
    deepcopy_VkExtent2D(pool, &from->extent, (VkExtent2D*)(&to->extent));
    to->layer = from->layer;
}

void deepcopy_VkPresentRegionKHR(
    Pool* pool,
    const VkPresentRegionKHR* from,
    VkPresentRegionKHR* to)
{
    to->rectangleCount = from->rectangleCount;
    to->pRectangles = nullptr;
    if (from->pRectangles)
    {
        to->pRectangles = (VkRectLayerKHR*)pool->alloc(from->rectangleCount * sizeof(const VkRectLayerKHR));
        to->rectangleCount = from->rectangleCount;
        for (uint32_t i = 0; i < (uint32_t)from->rectangleCount; ++i)
        {
            deepcopy_VkRectLayerKHR(pool, from->pRectangles + i, (VkRectLayerKHR*)(to->pRectangles + i));
        }
    }
}

void deepcopy_VkPresentRegionsKHR(
    Pool* pool,
    const VkPresentRegionsKHR* from,
    VkPresentRegionsKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchainCount = from->swapchainCount;
    to->pRegions = nullptr;
    if (from->pRegions)
    {
        to->pRegions = (VkPresentRegionKHR*)pool->alloc(from->swapchainCount * sizeof(const VkPresentRegionKHR));
        to->swapchainCount = from->swapchainCount;
        for (uint32_t i = 0; i < (uint32_t)from->swapchainCount; ++i)
        {
            deepcopy_VkPresentRegionKHR(pool, from->pRegions + i, (VkPresentRegionKHR*)(to->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void deepcopy_VkAttachmentDescription2KHR(
    Pool* pool,
    const VkAttachmentDescription2KHR* from,
    VkAttachmentDescription2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->format = from->format;
    to->samples = from->samples;
    to->loadOp = from->loadOp;
    to->storeOp = from->storeOp;
    to->stencilLoadOp = from->stencilLoadOp;
    to->stencilStoreOp = from->stencilStoreOp;
    to->initialLayout = from->initialLayout;
    to->finalLayout = from->finalLayout;
}

void deepcopy_VkAttachmentReference2KHR(
    Pool* pool,
    const VkAttachmentReference2KHR* from,
    VkAttachmentReference2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->attachment = from->attachment;
    to->layout = from->layout;
    to->aspectMask = from->aspectMask;
}

void deepcopy_VkSubpassDescription2KHR(
    Pool* pool,
    const VkSubpassDescription2KHR* from,
    VkSubpassDescription2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pipelineBindPoint = from->pipelineBindPoint;
    to->viewMask = from->viewMask;
    to->inputAttachmentCount = from->inputAttachmentCount;
    to->pInputAttachments = nullptr;
    if (from->pInputAttachments)
    {
        to->pInputAttachments = (VkAttachmentReference2KHR*)pool->alloc(from->inputAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        to->inputAttachmentCount = from->inputAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->inputAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference2KHR(pool, from->pInputAttachments + i, (VkAttachmentReference2KHR*)(to->pInputAttachments + i));
        }
    }
    to->colorAttachmentCount = from->colorAttachmentCount;
    to->pColorAttachments = nullptr;
    if (from->pColorAttachments)
    {
        to->pColorAttachments = (VkAttachmentReference2KHR*)pool->alloc(from->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        to->colorAttachmentCount = from->colorAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->colorAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference2KHR(pool, from->pColorAttachments + i, (VkAttachmentReference2KHR*)(to->pColorAttachments + i));
        }
    }
    to->pResolveAttachments = nullptr;
    if (from->pResolveAttachments)
    {
        to->pResolveAttachments = (VkAttachmentReference2KHR*)pool->alloc(from->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        to->colorAttachmentCount = from->colorAttachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->colorAttachmentCount; ++i)
        {
            deepcopy_VkAttachmentReference2KHR(pool, from->pResolveAttachments + i, (VkAttachmentReference2KHR*)(to->pResolveAttachments + i));
        }
    }
    to->pDepthStencilAttachment = nullptr;
    if (from->pDepthStencilAttachment)
    {
        to->pDepthStencilAttachment = (VkAttachmentReference2KHR*)pool->alloc(sizeof(const VkAttachmentReference2KHR));
        deepcopy_VkAttachmentReference2KHR(pool, from->pDepthStencilAttachment, (VkAttachmentReference2KHR*)(to->pDepthStencilAttachment));
    }
    to->preserveAttachmentCount = from->preserveAttachmentCount;
    to->pPreserveAttachments = nullptr;
    if (from->pPreserveAttachments)
    {
        to->pPreserveAttachments = (uint32_t*)pool->dupArray(from->pPreserveAttachments, from->preserveAttachmentCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkSubpassDependency2KHR(
    Pool* pool,
    const VkSubpassDependency2KHR* from,
    VkSubpassDependency2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcSubpass = from->srcSubpass;
    to->dstSubpass = from->dstSubpass;
    to->srcStageMask = from->srcStageMask;
    to->dstStageMask = from->dstStageMask;
    to->srcAccessMask = from->srcAccessMask;
    to->dstAccessMask = from->dstAccessMask;
    to->dependencyFlags = from->dependencyFlags;
    to->viewOffset = from->viewOffset;
}

void deepcopy_VkRenderPassCreateInfo2KHR(
    Pool* pool,
    const VkRenderPassCreateInfo2KHR* from,
    VkRenderPassCreateInfo2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->attachmentCount = from->attachmentCount;
    to->pAttachments = nullptr;
    if (from->pAttachments)
    {
        to->pAttachments = (VkAttachmentDescription2KHR*)pool->alloc(from->attachmentCount * sizeof(const VkAttachmentDescription2KHR));
        to->attachmentCount = from->attachmentCount;
        for (uint32_t i = 0; i < (uint32_t)from->attachmentCount; ++i)
        {
            deepcopy_VkAttachmentDescription2KHR(pool, from->pAttachments + i, (VkAttachmentDescription2KHR*)(to->pAttachments + i));
        }
    }
    to->subpassCount = from->subpassCount;
    to->pSubpasses = nullptr;
    if (from->pSubpasses)
    {
        to->pSubpasses = (VkSubpassDescription2KHR*)pool->alloc(from->subpassCount * sizeof(const VkSubpassDescription2KHR));
        to->subpassCount = from->subpassCount;
        for (uint32_t i = 0; i < (uint32_t)from->subpassCount; ++i)
        {
            deepcopy_VkSubpassDescription2KHR(pool, from->pSubpasses + i, (VkSubpassDescription2KHR*)(to->pSubpasses + i));
        }
    }
    to->dependencyCount = from->dependencyCount;
    to->pDependencies = nullptr;
    if (from->pDependencies)
    {
        to->pDependencies = (VkSubpassDependency2KHR*)pool->alloc(from->dependencyCount * sizeof(const VkSubpassDependency2KHR));
        to->dependencyCount = from->dependencyCount;
        for (uint32_t i = 0; i < (uint32_t)from->dependencyCount; ++i)
        {
            deepcopy_VkSubpassDependency2KHR(pool, from->pDependencies + i, (VkSubpassDependency2KHR*)(to->pDependencies + i));
        }
    }
    to->correlatedViewMaskCount = from->correlatedViewMaskCount;
    to->pCorrelatedViewMasks = nullptr;
    if (from->pCorrelatedViewMasks)
    {
        to->pCorrelatedViewMasks = (uint32_t*)pool->dupArray(from->pCorrelatedViewMasks, from->correlatedViewMaskCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkSubpassBeginInfoKHR(
    Pool* pool,
    const VkSubpassBeginInfoKHR* from,
    VkSubpassBeginInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->contents = from->contents;
}

void deepcopy_VkSubpassEndInfoKHR(
    Pool* pool,
    const VkSubpassEndInfoKHR* from,
    VkSubpassEndInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
}

#endif
#ifdef VK_KHR_shared_presentable_image
void deepcopy_VkSharedPresentSurfaceCapabilitiesKHR(
    Pool* pool,
    const VkSharedPresentSurfaceCapabilitiesKHR* from,
    VkSharedPresentSurfaceCapabilitiesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->sharedPresentSupportedUsageFlags = from->sharedPresentSupportedUsageFlags;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void deepcopy_VkImportFenceWin32HandleInfoKHR(
    Pool* pool,
    const VkImportFenceWin32HandleInfoKHR* from,
    VkImportFenceWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->fence = from->fence;
    to->flags = from->flags;
    to->handleType = from->handleType;
    to->handle = from->handle;
    to->name = from->name;
}

void deepcopy_VkExportFenceWin32HandleInfoKHR(
    Pool* pool,
    const VkExportFenceWin32HandleInfoKHR* from,
    VkExportFenceWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pAttributes = nullptr;
    if (from->pAttributes)
    {
        to->pAttributes = (SECURITY_ATTRIBUTES*)pool->dupArray(from->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    to->dwAccess = from->dwAccess;
    to->name = from->name;
}

void deepcopy_VkFenceGetWin32HandleInfoKHR(
    Pool* pool,
    const VkFenceGetWin32HandleInfoKHR* from,
    VkFenceGetWin32HandleInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->fence = from->fence;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_external_fence_fd
void deepcopy_VkImportFenceFdInfoKHR(
    Pool* pool,
    const VkImportFenceFdInfoKHR* from,
    VkImportFenceFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->fence = from->fence;
    to->flags = from->flags;
    to->handleType = from->handleType;
    to->fd = from->fd;
}

void deepcopy_VkFenceGetFdInfoKHR(
    Pool* pool,
    const VkFenceGetFdInfoKHR* from,
    VkFenceGetFdInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->fence = from->fence;
    to->handleType = from->handleType;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(
    Pool* pool,
    const VkPhysicalDeviceSurfaceInfo2KHR* from,
    VkPhysicalDeviceSurfaceInfo2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->surface = from->surface;
}

void deepcopy_VkSurfaceCapabilities2KHR(
    Pool* pool,
    const VkSurfaceCapabilities2KHR* from,
    VkSurfaceCapabilities2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkSurfaceCapabilitiesKHR(pool, &from->surfaceCapabilities, (VkSurfaceCapabilitiesKHR*)(&to->surfaceCapabilities));
}

void deepcopy_VkSurfaceFormat2KHR(
    Pool* pool,
    const VkSurfaceFormat2KHR* from,
    VkSurfaceFormat2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkSurfaceFormatKHR(pool, &from->surfaceFormat, (VkSurfaceFormatKHR*)(&to->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void deepcopy_VkDisplayProperties2KHR(
    Pool* pool,
    const VkDisplayProperties2KHR* from,
    VkDisplayProperties2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkDisplayPropertiesKHR(pool, &from->displayProperties, (VkDisplayPropertiesKHR*)(&to->displayProperties));
}

void deepcopy_VkDisplayPlaneProperties2KHR(
    Pool* pool,
    const VkDisplayPlaneProperties2KHR* from,
    VkDisplayPlaneProperties2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkDisplayPlanePropertiesKHR(pool, &from->displayPlaneProperties, (VkDisplayPlanePropertiesKHR*)(&to->displayPlaneProperties));
}

void deepcopy_VkDisplayModeProperties2KHR(
    Pool* pool,
    const VkDisplayModeProperties2KHR* from,
    VkDisplayModeProperties2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkDisplayModePropertiesKHR(pool, &from->displayModeProperties, (VkDisplayModePropertiesKHR*)(&to->displayModeProperties));
}

void deepcopy_VkDisplayPlaneInfo2KHR(
    Pool* pool,
    const VkDisplayPlaneInfo2KHR* from,
    VkDisplayPlaneInfo2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->mode = from->mode;
    to->planeIndex = from->planeIndex;
}

void deepcopy_VkDisplayPlaneCapabilities2KHR(
    Pool* pool,
    const VkDisplayPlaneCapabilities2KHR* from,
    VkDisplayPlaneCapabilities2KHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkDisplayPlaneCapabilitiesKHR(pool, &from->capabilities, (VkDisplayPlaneCapabilitiesKHR*)(&to->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void deepcopy_VkImageFormatListCreateInfoKHR(
    Pool* pool,
    const VkImageFormatListCreateInfoKHR* from,
    VkImageFormatListCreateInfoKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->viewFormatCount = from->viewFormatCount;
    to->pViewFormats = nullptr;
    if (from->pViewFormats)
    {
        to->pViewFormats = (VkFormat*)pool->dupArray(from->pViewFormats, from->viewFormatCount * sizeof(const VkFormat));
    }
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void deepcopy_VkPhysicalDevice8BitStorageFeaturesKHR(
    Pool* pool,
    const VkPhysicalDevice8BitStorageFeaturesKHR* from,
    VkPhysicalDevice8BitStorageFeaturesKHR* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->storageBuffer8BitAccess = from->storageBuffer8BitAccess;
    to->uniformAndStorageBuffer8BitAccess = from->uniformAndStorageBuffer8BitAccess;
    to->storagePushConstant8 = from->storagePushConstant8;
}

#endif
#ifdef VK_EXT_debug_report
void deepcopy_VkDebugReportCallbackCreateInfoEXT(
    Pool* pool,
    const VkDebugReportCallbackCreateInfoEXT* from,
    VkDebugReportCallbackCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pfnCallback = from->pfnCallback;
    to->pUserData = nullptr;
    if (from->pUserData)
    {
        to->pUserData = (void*)pool->dupArray(from->pUserData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void deepcopy_VkPipelineRasterizationStateRasterizationOrderAMD(
    Pool* pool,
    const VkPipelineRasterizationStateRasterizationOrderAMD* from,
    VkPipelineRasterizationStateRasterizationOrderAMD* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->rasterizationOrder = from->rasterizationOrder;
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void deepcopy_VkDebugMarkerObjectNameInfoEXT(
    Pool* pool,
    const VkDebugMarkerObjectNameInfoEXT* from,
    VkDebugMarkerObjectNameInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectType = from->objectType;
    to->object = from->object;
    to->pObjectName = nullptr;
    if (from->pObjectName)
    {
        to->pObjectName = pool->strDup(from->pObjectName);
    }
}

void deepcopy_VkDebugMarkerObjectTagInfoEXT(
    Pool* pool,
    const VkDebugMarkerObjectTagInfoEXT* from,
    VkDebugMarkerObjectTagInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectType = from->objectType;
    to->object = from->object;
    to->tagName = from->tagName;
    to->tagSize = from->tagSize;
    to->pTag = nullptr;
    if (from->pTag)
    {
        to->pTag = (void*)pool->dupArray(from->pTag, from->tagSize * sizeof(const uint8_t));
    }
}

void deepcopy_VkDebugMarkerMarkerInfoEXT(
    Pool* pool,
    const VkDebugMarkerMarkerInfoEXT* from,
    VkDebugMarkerMarkerInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pMarkerName = nullptr;
    if (from->pMarkerName)
    {
        to->pMarkerName = pool->strDup(from->pMarkerName);
    }
    memcpy(to->color, from->color, 4 * sizeof(float));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void deepcopy_VkDedicatedAllocationImageCreateInfoNV(
    Pool* pool,
    const VkDedicatedAllocationImageCreateInfoNV* from,
    VkDedicatedAllocationImageCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->dedicatedAllocation = from->dedicatedAllocation;
}

void deepcopy_VkDedicatedAllocationBufferCreateInfoNV(
    Pool* pool,
    const VkDedicatedAllocationBufferCreateInfoNV* from,
    VkDedicatedAllocationBufferCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->dedicatedAllocation = from->dedicatedAllocation;
}

void deepcopy_VkDedicatedAllocationMemoryAllocateInfoNV(
    Pool* pool,
    const VkDedicatedAllocationMemoryAllocateInfoNV* from,
    VkDedicatedAllocationMemoryAllocateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->image = from->image;
    to->buffer = from->buffer;
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void deepcopy_VkTextureLODGatherFormatPropertiesAMD(
    Pool* pool,
    const VkTextureLODGatherFormatPropertiesAMD* from,
    VkTextureLODGatherFormatPropertiesAMD* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->supportsTextureGatherLODBiasAMD = from->supportsTextureGatherLODBiasAMD;
}

#endif
#ifdef VK_AMD_shader_info
void deepcopy_VkShaderResourceUsageAMD(
    Pool* pool,
    const VkShaderResourceUsageAMD* from,
    VkShaderResourceUsageAMD* to)
{
    to->numUsedVgprs = from->numUsedVgprs;
    to->numUsedSgprs = from->numUsedSgprs;
    to->ldsSizePerLocalWorkGroup = from->ldsSizePerLocalWorkGroup;
    to->ldsUsageSizeInBytes = from->ldsUsageSizeInBytes;
    to->scratchMemUsageInBytes = from->scratchMemUsageInBytes;
}

void deepcopy_VkShaderStatisticsInfoAMD(
    Pool* pool,
    const VkShaderStatisticsInfoAMD* from,
    VkShaderStatisticsInfoAMD* to)
{
    to->shaderStageMask = from->shaderStageMask;
    deepcopy_VkShaderResourceUsageAMD(pool, &from->resourceUsage, (VkShaderResourceUsageAMD*)(&to->resourceUsage));
    to->numPhysicalVgprs = from->numPhysicalVgprs;
    to->numPhysicalSgprs = from->numPhysicalSgprs;
    to->numAvailableVgprs = from->numAvailableVgprs;
    to->numAvailableSgprs = from->numAvailableSgprs;
    memcpy(to->computeWorkGroupSize, from->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void deepcopy_VkExternalImageFormatPropertiesNV(
    Pool* pool,
    const VkExternalImageFormatPropertiesNV* from,
    VkExternalImageFormatPropertiesNV* to)
{
    deepcopy_VkImageFormatProperties(pool, &from->imageFormatProperties, (VkImageFormatProperties*)(&to->imageFormatProperties));
    to->externalMemoryFeatures = from->externalMemoryFeatures;
    to->exportFromImportedHandleTypes = from->exportFromImportedHandleTypes;
    to->compatibleHandleTypes = from->compatibleHandleTypes;
}

#endif
#ifdef VK_NV_external_memory
void deepcopy_VkExternalMemoryImageCreateInfoNV(
    Pool* pool,
    const VkExternalMemoryImageCreateInfoNV* from,
    VkExternalMemoryImageCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

void deepcopy_VkExportMemoryAllocateInfoNV(
    Pool* pool,
    const VkExportMemoryAllocateInfoNV* from,
    VkExportMemoryAllocateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleTypes = from->handleTypes;
}

#endif
#ifdef VK_NV_external_memory_win32
void deepcopy_VkImportMemoryWin32HandleInfoNV(
    Pool* pool,
    const VkImportMemoryWin32HandleInfoNV* from,
    VkImportMemoryWin32HandleInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
    to->handle = from->handle;
}

void deepcopy_VkExportMemoryWin32HandleInfoNV(
    Pool* pool,
    const VkExportMemoryWin32HandleInfoNV* from,
    VkExportMemoryWin32HandleInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pAttributes = nullptr;
    if (from->pAttributes)
    {
        to->pAttributes = (SECURITY_ATTRIBUTES*)pool->dupArray(from->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    to->dwAccess = from->dwAccess;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void deepcopy_VkWin32KeyedMutexAcquireReleaseInfoNV(
    Pool* pool,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* from,
    VkWin32KeyedMutexAcquireReleaseInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->acquireCount = from->acquireCount;
    to->pAcquireSyncs = nullptr;
    if (from->pAcquireSyncs)
    {
        to->pAcquireSyncs = (VkDeviceMemory*)pool->dupArray(from->pAcquireSyncs, from->acquireCount * sizeof(const VkDeviceMemory));
    }
    to->pAcquireKeys = nullptr;
    if (from->pAcquireKeys)
    {
        to->pAcquireKeys = (uint64_t*)pool->dupArray(from->pAcquireKeys, from->acquireCount * sizeof(const uint64_t));
    }
    to->pAcquireTimeoutMilliseconds = nullptr;
    if (from->pAcquireTimeoutMilliseconds)
    {
        to->pAcquireTimeoutMilliseconds = (uint32_t*)pool->dupArray(from->pAcquireTimeoutMilliseconds, from->acquireCount * sizeof(const uint32_t));
    }
    to->releaseCount = from->releaseCount;
    to->pReleaseSyncs = nullptr;
    if (from->pReleaseSyncs)
    {
        to->pReleaseSyncs = (VkDeviceMemory*)pool->dupArray(from->pReleaseSyncs, from->releaseCount * sizeof(const VkDeviceMemory));
    }
    to->pReleaseKeys = nullptr;
    if (from->pReleaseKeys)
    {
        to->pReleaseKeys = (uint64_t*)pool->dupArray(from->pReleaseKeys, from->releaseCount * sizeof(const uint64_t));
    }
}

#endif
#ifdef VK_EXT_validation_flags
void deepcopy_VkValidationFlagsEXT(
    Pool* pool,
    const VkValidationFlagsEXT* from,
    VkValidationFlagsEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->disabledValidationCheckCount = from->disabledValidationCheckCount;
    to->pDisabledValidationChecks = nullptr;
    if (from->pDisabledValidationChecks)
    {
        to->pDisabledValidationChecks = (VkValidationCheckEXT*)pool->dupArray(from->pDisabledValidationChecks, from->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    }
}

#endif
#ifdef VK_NN_vi_surface
void deepcopy_VkViSurfaceCreateInfoNN(
    Pool* pool,
    const VkViSurfaceCreateInfoNN* from,
    VkViSurfaceCreateInfoNN* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->window = nullptr;
    if (from->window)
    {
        to->window = (void*)pool->dupArray(from->window, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void deepcopy_VkConditionalRenderingBeginInfoEXT(
    Pool* pool,
    const VkConditionalRenderingBeginInfoEXT* from,
    VkConditionalRenderingBeginInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->buffer = from->buffer;
    to->offset = from->offset;
    to->flags = from->flags;
}

void deepcopy_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    Pool* pool,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* from,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->conditionalRendering = from->conditionalRendering;
    to->inheritedConditionalRendering = from->inheritedConditionalRendering;
}

void deepcopy_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    Pool* pool,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* from,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->conditionalRenderingEnable = from->conditionalRenderingEnable;
}

#endif
#ifdef VK_NVX_device_generated_commands
void deepcopy_VkDeviceGeneratedCommandsFeaturesNVX(
    Pool* pool,
    const VkDeviceGeneratedCommandsFeaturesNVX* from,
    VkDeviceGeneratedCommandsFeaturesNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->computeBindingPointSupport = from->computeBindingPointSupport;
}

void deepcopy_VkDeviceGeneratedCommandsLimitsNVX(
    Pool* pool,
    const VkDeviceGeneratedCommandsLimitsNVX* from,
    VkDeviceGeneratedCommandsLimitsNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxIndirectCommandsLayoutTokenCount = from->maxIndirectCommandsLayoutTokenCount;
    to->maxObjectEntryCounts = from->maxObjectEntryCounts;
    to->minSequenceCountBufferOffsetAlignment = from->minSequenceCountBufferOffsetAlignment;
    to->minSequenceIndexBufferOffsetAlignment = from->minSequenceIndexBufferOffsetAlignment;
    to->minCommandsTokenBufferOffsetAlignment = from->minCommandsTokenBufferOffsetAlignment;
}

void deepcopy_VkIndirectCommandsTokenNVX(
    Pool* pool,
    const VkIndirectCommandsTokenNVX* from,
    VkIndirectCommandsTokenNVX* to)
{
    to->tokenType = from->tokenType;
    to->buffer = from->buffer;
    to->offset = from->offset;
}

void deepcopy_VkIndirectCommandsLayoutTokenNVX(
    Pool* pool,
    const VkIndirectCommandsLayoutTokenNVX* from,
    VkIndirectCommandsLayoutTokenNVX* to)
{
    to->tokenType = from->tokenType;
    to->bindingUnit = from->bindingUnit;
    to->dynamicCount = from->dynamicCount;
    to->divisor = from->divisor;
}

void deepcopy_VkIndirectCommandsLayoutCreateInfoNVX(
    Pool* pool,
    const VkIndirectCommandsLayoutCreateInfoNVX* from,
    VkIndirectCommandsLayoutCreateInfoNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pipelineBindPoint = from->pipelineBindPoint;
    to->flags = from->flags;
    to->tokenCount = from->tokenCount;
    to->pTokens = nullptr;
    if (from->pTokens)
    {
        to->pTokens = (VkIndirectCommandsLayoutTokenNVX*)pool->alloc(from->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNVX));
        to->tokenCount = from->tokenCount;
        for (uint32_t i = 0; i < (uint32_t)from->tokenCount; ++i)
        {
            deepcopy_VkIndirectCommandsLayoutTokenNVX(pool, from->pTokens + i, (VkIndirectCommandsLayoutTokenNVX*)(to->pTokens + i));
        }
    }
}

void deepcopy_VkCmdProcessCommandsInfoNVX(
    Pool* pool,
    const VkCmdProcessCommandsInfoNVX* from,
    VkCmdProcessCommandsInfoNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectTable = from->objectTable;
    to->indirectCommandsLayout = from->indirectCommandsLayout;
    to->indirectCommandsTokenCount = from->indirectCommandsTokenCount;
    to->pIndirectCommandsTokens = nullptr;
    if (from->pIndirectCommandsTokens)
    {
        to->pIndirectCommandsTokens = (VkIndirectCommandsTokenNVX*)pool->alloc(from->indirectCommandsTokenCount * sizeof(const VkIndirectCommandsTokenNVX));
        to->indirectCommandsTokenCount = from->indirectCommandsTokenCount;
        for (uint32_t i = 0; i < (uint32_t)from->indirectCommandsTokenCount; ++i)
        {
            deepcopy_VkIndirectCommandsTokenNVX(pool, from->pIndirectCommandsTokens + i, (VkIndirectCommandsTokenNVX*)(to->pIndirectCommandsTokens + i));
        }
    }
    to->maxSequencesCount = from->maxSequencesCount;
    to->targetCommandBuffer = from->targetCommandBuffer;
    to->sequencesCountBuffer = from->sequencesCountBuffer;
    to->sequencesCountOffset = from->sequencesCountOffset;
    to->sequencesIndexBuffer = from->sequencesIndexBuffer;
    to->sequencesIndexOffset = from->sequencesIndexOffset;
}

void deepcopy_VkCmdReserveSpaceForCommandsInfoNVX(
    Pool* pool,
    const VkCmdReserveSpaceForCommandsInfoNVX* from,
    VkCmdReserveSpaceForCommandsInfoNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectTable = from->objectTable;
    to->indirectCommandsLayout = from->indirectCommandsLayout;
    to->maxSequencesCount = from->maxSequencesCount;
}

void deepcopy_VkObjectTableCreateInfoNVX(
    Pool* pool,
    const VkObjectTableCreateInfoNVX* from,
    VkObjectTableCreateInfoNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectCount = from->objectCount;
    to->pObjectEntryTypes = nullptr;
    if (from->pObjectEntryTypes)
    {
        to->pObjectEntryTypes = (VkObjectEntryTypeNVX*)pool->dupArray(from->pObjectEntryTypes, from->objectCount * sizeof(const VkObjectEntryTypeNVX));
    }
    to->pObjectEntryCounts = nullptr;
    if (from->pObjectEntryCounts)
    {
        to->pObjectEntryCounts = (uint32_t*)pool->dupArray(from->pObjectEntryCounts, from->objectCount * sizeof(const uint32_t));
    }
    to->pObjectEntryUsageFlags = nullptr;
    if (from->pObjectEntryUsageFlags)
    {
        to->pObjectEntryUsageFlags = (VkObjectEntryUsageFlagsNVX*)pool->dupArray(from->pObjectEntryUsageFlags, from->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    }
    to->maxUniformBuffersPerDescriptor = from->maxUniformBuffersPerDescriptor;
    to->maxStorageBuffersPerDescriptor = from->maxStorageBuffersPerDescriptor;
    to->maxStorageImagesPerDescriptor = from->maxStorageImagesPerDescriptor;
    to->maxSampledImagesPerDescriptor = from->maxSampledImagesPerDescriptor;
    to->maxPipelineLayouts = from->maxPipelineLayouts;
}

void deepcopy_VkObjectTableEntryNVX(
    Pool* pool,
    const VkObjectTableEntryNVX* from,
    VkObjectTableEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
}

void deepcopy_VkObjectTablePipelineEntryNVX(
    Pool* pool,
    const VkObjectTablePipelineEntryNVX* from,
    VkObjectTablePipelineEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
    to->pipeline = from->pipeline;
}

void deepcopy_VkObjectTableDescriptorSetEntryNVX(
    Pool* pool,
    const VkObjectTableDescriptorSetEntryNVX* from,
    VkObjectTableDescriptorSetEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
    to->pipelineLayout = from->pipelineLayout;
    to->descriptorSet = from->descriptorSet;
}

void deepcopy_VkObjectTableVertexBufferEntryNVX(
    Pool* pool,
    const VkObjectTableVertexBufferEntryNVX* from,
    VkObjectTableVertexBufferEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
    to->buffer = from->buffer;
}

void deepcopy_VkObjectTableIndexBufferEntryNVX(
    Pool* pool,
    const VkObjectTableIndexBufferEntryNVX* from,
    VkObjectTableIndexBufferEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
    to->buffer = from->buffer;
    to->indexType = from->indexType;
}

void deepcopy_VkObjectTablePushConstantEntryNVX(
    Pool* pool,
    const VkObjectTablePushConstantEntryNVX* from,
    VkObjectTablePushConstantEntryNVX* to)
{
    to->type = from->type;
    to->flags = from->flags;
    to->pipelineLayout = from->pipelineLayout;
    to->stageFlags = from->stageFlags;
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void deepcopy_VkViewportWScalingNV(
    Pool* pool,
    const VkViewportWScalingNV* from,
    VkViewportWScalingNV* to)
{
    to->xcoeff = from->xcoeff;
    to->ycoeff = from->ycoeff;
}

void deepcopy_VkPipelineViewportWScalingStateCreateInfoNV(
    Pool* pool,
    const VkPipelineViewportWScalingStateCreateInfoNV* from,
    VkPipelineViewportWScalingStateCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->viewportWScalingEnable = from->viewportWScalingEnable;
    to->viewportCount = from->viewportCount;
    to->pViewportWScalings = nullptr;
    if (from->pViewportWScalings)
    {
        to->pViewportWScalings = (VkViewportWScalingNV*)pool->alloc(from->viewportCount * sizeof(const VkViewportWScalingNV));
        to->viewportCount = from->viewportCount;
        for (uint32_t i = 0; i < (uint32_t)from->viewportCount; ++i)
        {
            deepcopy_VkViewportWScalingNV(pool, from->pViewportWScalings + i, (VkViewportWScalingNV*)(to->pViewportWScalings + i));
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void deepcopy_VkSurfaceCapabilities2EXT(
    Pool* pool,
    const VkSurfaceCapabilities2EXT* from,
    VkSurfaceCapabilities2EXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->minImageCount = from->minImageCount;
    to->maxImageCount = from->maxImageCount;
    deepcopy_VkExtent2D(pool, &from->currentExtent, (VkExtent2D*)(&to->currentExtent));
    deepcopy_VkExtent2D(pool, &from->minImageExtent, (VkExtent2D*)(&to->minImageExtent));
    deepcopy_VkExtent2D(pool, &from->maxImageExtent, (VkExtent2D*)(&to->maxImageExtent));
    to->maxImageArrayLayers = from->maxImageArrayLayers;
    to->supportedTransforms = from->supportedTransforms;
    to->currentTransform = from->currentTransform;
    to->supportedCompositeAlpha = from->supportedCompositeAlpha;
    to->supportedUsageFlags = from->supportedUsageFlags;
    to->supportedSurfaceCounters = from->supportedSurfaceCounters;
}

#endif
#ifdef VK_EXT_display_control
void deepcopy_VkDisplayPowerInfoEXT(
    Pool* pool,
    const VkDisplayPowerInfoEXT* from,
    VkDisplayPowerInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->powerState = from->powerState;
}

void deepcopy_VkDeviceEventInfoEXT(
    Pool* pool,
    const VkDeviceEventInfoEXT* from,
    VkDeviceEventInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->deviceEvent = from->deviceEvent;
}

void deepcopy_VkDisplayEventInfoEXT(
    Pool* pool,
    const VkDisplayEventInfoEXT* from,
    VkDisplayEventInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->displayEvent = from->displayEvent;
}

void deepcopy_VkSwapchainCounterCreateInfoEXT(
    Pool* pool,
    const VkSwapchainCounterCreateInfoEXT* from,
    VkSwapchainCounterCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->surfaceCounters = from->surfaceCounters;
}

#endif
#ifdef VK_GOOGLE_display_timing
void deepcopy_VkRefreshCycleDurationGOOGLE(
    Pool* pool,
    const VkRefreshCycleDurationGOOGLE* from,
    VkRefreshCycleDurationGOOGLE* to)
{
    to->refreshDuration = from->refreshDuration;
}

void deepcopy_VkPastPresentationTimingGOOGLE(
    Pool* pool,
    const VkPastPresentationTimingGOOGLE* from,
    VkPastPresentationTimingGOOGLE* to)
{
    to->presentID = from->presentID;
    to->desiredPresentTime = from->desiredPresentTime;
    to->actualPresentTime = from->actualPresentTime;
    to->earliestPresentTime = from->earliestPresentTime;
    to->presentMargin = from->presentMargin;
}

void deepcopy_VkPresentTimeGOOGLE(
    Pool* pool,
    const VkPresentTimeGOOGLE* from,
    VkPresentTimeGOOGLE* to)
{
    to->presentID = from->presentID;
    to->desiredPresentTime = from->desiredPresentTime;
}

void deepcopy_VkPresentTimesInfoGOOGLE(
    Pool* pool,
    const VkPresentTimesInfoGOOGLE* from,
    VkPresentTimesInfoGOOGLE* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->swapchainCount = from->swapchainCount;
    to->pTimes = nullptr;
    if (from->pTimes)
    {
        to->pTimes = (VkPresentTimeGOOGLE*)pool->alloc(from->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        to->swapchainCount = from->swapchainCount;
        for (uint32_t i = 0; i < (uint32_t)from->swapchainCount; ++i)
        {
            deepcopy_VkPresentTimeGOOGLE(pool, from->pTimes + i, (VkPresentTimeGOOGLE*)(to->pTimes + i));
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void deepcopy_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    Pool* pool,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* from,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->perViewPositionAllComponents = from->perViewPositionAllComponents;
}

#endif
#ifdef VK_NV_viewport_swizzle
void deepcopy_VkViewportSwizzleNV(
    Pool* pool,
    const VkViewportSwizzleNV* from,
    VkViewportSwizzleNV* to)
{
    to->x = from->x;
    to->y = from->y;
    to->z = from->z;
    to->w = from->w;
}

void deepcopy_VkPipelineViewportSwizzleStateCreateInfoNV(
    Pool* pool,
    const VkPipelineViewportSwizzleStateCreateInfoNV* from,
    VkPipelineViewportSwizzleStateCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->viewportCount = from->viewportCount;
    to->pViewportSwizzles = nullptr;
    if (from->pViewportSwizzles)
    {
        to->pViewportSwizzles = (VkViewportSwizzleNV*)pool->alloc(from->viewportCount * sizeof(const VkViewportSwizzleNV));
        to->viewportCount = from->viewportCount;
        for (uint32_t i = 0; i < (uint32_t)from->viewportCount; ++i)
        {
            deepcopy_VkViewportSwizzleNV(pool, from->pViewportSwizzles + i, (VkViewportSwizzleNV*)(to->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void deepcopy_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* from,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxDiscardRectangles = from->maxDiscardRectangles;
}

void deepcopy_VkPipelineDiscardRectangleStateCreateInfoEXT(
    Pool* pool,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* from,
    VkPipelineDiscardRectangleStateCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->discardRectangleMode = from->discardRectangleMode;
    to->discardRectangleCount = from->discardRectangleCount;
    to->pDiscardRectangles = nullptr;
    if (from->pDiscardRectangles)
    {
        to->pDiscardRectangles = (VkRect2D*)pool->alloc(from->discardRectangleCount * sizeof(const VkRect2D));
        to->discardRectangleCount = from->discardRectangleCount;
        for (uint32_t i = 0; i < (uint32_t)from->discardRectangleCount; ++i)
        {
            deepcopy_VkRect2D(pool, from->pDiscardRectangles + i, (VkRect2D*)(to->pDiscardRectangles + i));
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void deepcopy_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* from,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->primitiveOverestimationSize = from->primitiveOverestimationSize;
    to->maxExtraPrimitiveOverestimationSize = from->maxExtraPrimitiveOverestimationSize;
    to->extraPrimitiveOverestimationSizeGranularity = from->extraPrimitiveOverestimationSizeGranularity;
    to->primitiveUnderestimation = from->primitiveUnderestimation;
    to->conservativePointAndLineRasterization = from->conservativePointAndLineRasterization;
    to->degenerateTrianglesRasterized = from->degenerateTrianglesRasterized;
    to->degenerateLinesRasterized = from->degenerateLinesRasterized;
    to->fullyCoveredFragmentShaderInputVariable = from->fullyCoveredFragmentShaderInputVariable;
    to->conservativeRasterizationPostDepthCoverage = from->conservativeRasterizationPostDepthCoverage;
}

void deepcopy_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    Pool* pool,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* from,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->conservativeRasterizationMode = from->conservativeRasterizationMode;
    to->extraPrimitiveOverestimationSize = from->extraPrimitiveOverestimationSize;
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void deepcopy_VkXYColorEXT(
    Pool* pool,
    const VkXYColorEXT* from,
    VkXYColorEXT* to)
{
    to->x = from->x;
    to->y = from->y;
}

void deepcopy_VkHdrMetadataEXT(
    Pool* pool,
    const VkHdrMetadataEXT* from,
    VkHdrMetadataEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkXYColorEXT(pool, &from->displayPrimaryRed, (VkXYColorEXT*)(&to->displayPrimaryRed));
    deepcopy_VkXYColorEXT(pool, &from->displayPrimaryGreen, (VkXYColorEXT*)(&to->displayPrimaryGreen));
    deepcopy_VkXYColorEXT(pool, &from->displayPrimaryBlue, (VkXYColorEXT*)(&to->displayPrimaryBlue));
    deepcopy_VkXYColorEXT(pool, &from->whitePoint, (VkXYColorEXT*)(&to->whitePoint));
    to->maxLuminance = from->maxLuminance;
    to->minLuminance = from->minLuminance;
    to->maxContentLightLevel = from->maxContentLightLevel;
    to->maxFrameAverageLightLevel = from->maxFrameAverageLightLevel;
}

#endif
#ifdef VK_MVK_ios_surface
void deepcopy_VkIOSSurfaceCreateInfoMVK(
    Pool* pool,
    const VkIOSSurfaceCreateInfoMVK* from,
    VkIOSSurfaceCreateInfoMVK* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pView = nullptr;
    if (from->pView)
    {
        to->pView = (void*)pool->dupArray(from->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void deepcopy_VkMacOSSurfaceCreateInfoMVK(
    Pool* pool,
    const VkMacOSSurfaceCreateInfoMVK* from,
    VkMacOSSurfaceCreateInfoMVK* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pView = nullptr;
    if (from->pView)
    {
        to->pView = (void*)pool->dupArray(from->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void deepcopy_VkDebugUtilsObjectNameInfoEXT(
    Pool* pool,
    const VkDebugUtilsObjectNameInfoEXT* from,
    VkDebugUtilsObjectNameInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectType = from->objectType;
    to->objectHandle = from->objectHandle;
    to->pObjectName = nullptr;
    if (from->pObjectName)
    {
        to->pObjectName = pool->strDup(from->pObjectName);
    }
}

void deepcopy_VkDebugUtilsObjectTagInfoEXT(
    Pool* pool,
    const VkDebugUtilsObjectTagInfoEXT* from,
    VkDebugUtilsObjectTagInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->objectType = from->objectType;
    to->objectHandle = from->objectHandle;
    to->tagName = from->tagName;
    to->tagSize = from->tagSize;
    to->pTag = nullptr;
    if (from->pTag)
    {
        to->pTag = (void*)pool->dupArray(from->pTag, from->tagSize * sizeof(const uint8_t));
    }
}

void deepcopy_VkDebugUtilsLabelEXT(
    Pool* pool,
    const VkDebugUtilsLabelEXT* from,
    VkDebugUtilsLabelEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->pLabelName = nullptr;
    if (from->pLabelName)
    {
        to->pLabelName = pool->strDup(from->pLabelName);
    }
    memcpy(to->color, from->color, 4 * sizeof(float));
}

void deepcopy_VkDebugUtilsMessengerCallbackDataEXT(
    Pool* pool,
    const VkDebugUtilsMessengerCallbackDataEXT* from,
    VkDebugUtilsMessengerCallbackDataEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->pMessageIdName = nullptr;
    if (from->pMessageIdName)
    {
        to->pMessageIdName = pool->strDup(from->pMessageIdName);
    }
    to->messageIdNumber = from->messageIdNumber;
    to->pMessage = nullptr;
    if (from->pMessage)
    {
        to->pMessage = pool->strDup(from->pMessage);
    }
    to->queueLabelCount = from->queueLabelCount;
    to->pQueueLabels = nullptr;
    if (from->pQueueLabels)
    {
        to->pQueueLabels = (VkDebugUtilsLabelEXT*)pool->alloc(from->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        to->queueLabelCount = from->queueLabelCount;
        for (uint32_t i = 0; i < (uint32_t)from->queueLabelCount; ++i)
        {
            deepcopy_VkDebugUtilsLabelEXT(pool, from->pQueueLabels + i, (VkDebugUtilsLabelEXT*)(to->pQueueLabels + i));
        }
    }
    to->cmdBufLabelCount = from->cmdBufLabelCount;
    to->pCmdBufLabels = nullptr;
    if (from->pCmdBufLabels)
    {
        to->pCmdBufLabels = (VkDebugUtilsLabelEXT*)pool->alloc(from->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        to->cmdBufLabelCount = from->cmdBufLabelCount;
        for (uint32_t i = 0; i < (uint32_t)from->cmdBufLabelCount; ++i)
        {
            deepcopy_VkDebugUtilsLabelEXT(pool, from->pCmdBufLabels + i, (VkDebugUtilsLabelEXT*)(to->pCmdBufLabels + i));
        }
    }
    to->objectCount = from->objectCount;
    to->pObjects = nullptr;
    if (from->pObjects)
    {
        to->pObjects = (VkDebugUtilsObjectNameInfoEXT*)pool->alloc(from->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        to->objectCount = from->objectCount;
        for (uint32_t i = 0; i < (uint32_t)from->objectCount; ++i)
        {
            deepcopy_VkDebugUtilsObjectNameInfoEXT(pool, from->pObjects + i, (VkDebugUtilsObjectNameInfoEXT*)(to->pObjects + i));
        }
    }
}

void deepcopy_VkDebugUtilsMessengerCreateInfoEXT(
    Pool* pool,
    const VkDebugUtilsMessengerCreateInfoEXT* from,
    VkDebugUtilsMessengerCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->messageSeverity = from->messageSeverity;
    to->messageType = from->messageType;
    to->pfnUserCallback = from->pfnUserCallback;
    to->pUserData = nullptr;
    if (from->pUserData)
    {
        to->pUserData = (void*)pool->dupArray(from->pUserData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void deepcopy_VkAndroidHardwareBufferUsageANDROID(
    Pool* pool,
    const VkAndroidHardwareBufferUsageANDROID* from,
    VkAndroidHardwareBufferUsageANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->androidHardwareBufferUsage = from->androidHardwareBufferUsage;
}

void deepcopy_VkAndroidHardwareBufferPropertiesANDROID(
    Pool* pool,
    const VkAndroidHardwareBufferPropertiesANDROID* from,
    VkAndroidHardwareBufferPropertiesANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->allocationSize = from->allocationSize;
    to->memoryTypeBits = from->memoryTypeBits;
}

void deepcopy_VkAndroidHardwareBufferFormatPropertiesANDROID(
    Pool* pool,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* from,
    VkAndroidHardwareBufferFormatPropertiesANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->format = from->format;
    to->externalFormat = from->externalFormat;
    to->formatFeatures = from->formatFeatures;
    deepcopy_VkComponentMapping(pool, &from->samplerYcbcrConversionComponents, (VkComponentMapping*)(&to->samplerYcbcrConversionComponents));
    to->suggestedYcbcrModel = from->suggestedYcbcrModel;
    to->suggestedYcbcrRange = from->suggestedYcbcrRange;
    to->suggestedXChromaOffset = from->suggestedXChromaOffset;
    to->suggestedYChromaOffset = from->suggestedYChromaOffset;
}

void deepcopy_VkImportAndroidHardwareBufferInfoANDROID(
    Pool* pool,
    const VkImportAndroidHardwareBufferInfoANDROID* from,
    VkImportAndroidHardwareBufferInfoANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->buffer = nullptr;
    if (from->buffer)
    {
        to->buffer = (AHardwareBuffer*)pool->dupArray(from->buffer, sizeof(AHardwareBuffer));
    }
}

void deepcopy_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    Pool* pool,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* from,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memory = from->memory;
}

void deepcopy_VkExternalFormatANDROID(
    Pool* pool,
    const VkExternalFormatANDROID* from,
    VkExternalFormatANDROID* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->externalFormat = from->externalFormat;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void deepcopy_VkSamplerReductionModeCreateInfoEXT(
    Pool* pool,
    const VkSamplerReductionModeCreateInfoEXT* from,
    VkSamplerReductionModeCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->reductionMode = from->reductionMode;
}

void deepcopy_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* from,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->filterMinmaxSingleComponentFormats = from->filterMinmaxSingleComponentFormats;
    to->filterMinmaxImageComponentMapping = from->filterMinmaxImageComponentMapping;
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void deepcopy_VkSampleLocationEXT(
    Pool* pool,
    const VkSampleLocationEXT* from,
    VkSampleLocationEXT* to)
{
    to->x = from->x;
    to->y = from->y;
}

void deepcopy_VkSampleLocationsInfoEXT(
    Pool* pool,
    const VkSampleLocationsInfoEXT* from,
    VkSampleLocationsInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->sampleLocationsPerPixel = from->sampleLocationsPerPixel;
    deepcopy_VkExtent2D(pool, &from->sampleLocationGridSize, (VkExtent2D*)(&to->sampleLocationGridSize));
    to->sampleLocationsCount = from->sampleLocationsCount;
    to->pSampleLocations = nullptr;
    if (from->pSampleLocations)
    {
        to->pSampleLocations = (VkSampleLocationEXT*)pool->alloc(from->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
        to->sampleLocationsCount = from->sampleLocationsCount;
        for (uint32_t i = 0; i < (uint32_t)from->sampleLocationsCount; ++i)
        {
            deepcopy_VkSampleLocationEXT(pool, from->pSampleLocations + i, (VkSampleLocationEXT*)(to->pSampleLocations + i));
        }
    }
}

void deepcopy_VkAttachmentSampleLocationsEXT(
    Pool* pool,
    const VkAttachmentSampleLocationsEXT* from,
    VkAttachmentSampleLocationsEXT* to)
{
    to->attachmentIndex = from->attachmentIndex;
    deepcopy_VkSampleLocationsInfoEXT(pool, &from->sampleLocationsInfo, (VkSampleLocationsInfoEXT*)(&to->sampleLocationsInfo));
}

void deepcopy_VkSubpassSampleLocationsEXT(
    Pool* pool,
    const VkSubpassSampleLocationsEXT* from,
    VkSubpassSampleLocationsEXT* to)
{
    to->subpassIndex = from->subpassIndex;
    deepcopy_VkSampleLocationsInfoEXT(pool, &from->sampleLocationsInfo, (VkSampleLocationsInfoEXT*)(&to->sampleLocationsInfo));
}

void deepcopy_VkRenderPassSampleLocationsBeginInfoEXT(
    Pool* pool,
    const VkRenderPassSampleLocationsBeginInfoEXT* from,
    VkRenderPassSampleLocationsBeginInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->attachmentInitialSampleLocationsCount = from->attachmentInitialSampleLocationsCount;
    to->pAttachmentInitialSampleLocations = nullptr;
    if (from->pAttachmentInitialSampleLocations)
    {
        to->pAttachmentInitialSampleLocations = (VkAttachmentSampleLocationsEXT*)pool->alloc(from->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
        to->attachmentInitialSampleLocationsCount = from->attachmentInitialSampleLocationsCount;
        for (uint32_t i = 0; i < (uint32_t)from->attachmentInitialSampleLocationsCount; ++i)
        {
            deepcopy_VkAttachmentSampleLocationsEXT(pool, from->pAttachmentInitialSampleLocations + i, (VkAttachmentSampleLocationsEXT*)(to->pAttachmentInitialSampleLocations + i));
        }
    }
    to->postSubpassSampleLocationsCount = from->postSubpassSampleLocationsCount;
    to->pPostSubpassSampleLocations = nullptr;
    if (from->pPostSubpassSampleLocations)
    {
        to->pPostSubpassSampleLocations = (VkSubpassSampleLocationsEXT*)pool->alloc(from->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
        to->postSubpassSampleLocationsCount = from->postSubpassSampleLocationsCount;
        for (uint32_t i = 0; i < (uint32_t)from->postSubpassSampleLocationsCount; ++i)
        {
            deepcopy_VkSubpassSampleLocationsEXT(pool, from->pPostSubpassSampleLocations + i, (VkSubpassSampleLocationsEXT*)(to->pPostSubpassSampleLocations + i));
        }
    }
}

void deepcopy_VkPipelineSampleLocationsStateCreateInfoEXT(
    Pool* pool,
    const VkPipelineSampleLocationsStateCreateInfoEXT* from,
    VkPipelineSampleLocationsStateCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->sampleLocationsEnable = from->sampleLocationsEnable;
    deepcopy_VkSampleLocationsInfoEXT(pool, &from->sampleLocationsInfo, (VkSampleLocationsInfoEXT*)(&to->sampleLocationsInfo));
}

void deepcopy_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* from,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->sampleLocationSampleCounts = from->sampleLocationSampleCounts;
    deepcopy_VkExtent2D(pool, &from->maxSampleLocationGridSize, (VkExtent2D*)(&to->maxSampleLocationGridSize));
    memcpy(to->sampleLocationCoordinateRange, from->sampleLocationCoordinateRange, 2 * sizeof(float));
    to->sampleLocationSubPixelBits = from->sampleLocationSubPixelBits;
    to->variableSampleLocations = from->variableSampleLocations;
}

void deepcopy_VkMultisamplePropertiesEXT(
    Pool* pool,
    const VkMultisamplePropertiesEXT* from,
    VkMultisamplePropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    deepcopy_VkExtent2D(pool, &from->maxSampleLocationGridSize, (VkExtent2D*)(&to->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void deepcopy_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    Pool* pool,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* from,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->advancedBlendCoherentOperations = from->advancedBlendCoherentOperations;
}

void deepcopy_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* from,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->advancedBlendMaxColorAttachments = from->advancedBlendMaxColorAttachments;
    to->advancedBlendIndependentBlend = from->advancedBlendIndependentBlend;
    to->advancedBlendNonPremultipliedSrcColor = from->advancedBlendNonPremultipliedSrcColor;
    to->advancedBlendNonPremultipliedDstColor = from->advancedBlendNonPremultipliedDstColor;
    to->advancedBlendCorrelatedOverlap = from->advancedBlendCorrelatedOverlap;
    to->advancedBlendAllOperations = from->advancedBlendAllOperations;
}

void deepcopy_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    Pool* pool,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* from,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->srcPremultiplied = from->srcPremultiplied;
    to->dstPremultiplied = from->dstPremultiplied;
    to->blendOverlap = from->blendOverlap;
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void deepcopy_VkPipelineCoverageToColorStateCreateInfoNV(
    Pool* pool,
    const VkPipelineCoverageToColorStateCreateInfoNV* from,
    VkPipelineCoverageToColorStateCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->coverageToColorEnable = from->coverageToColorEnable;
    to->coverageToColorLocation = from->coverageToColorLocation;
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void deepcopy_VkPipelineCoverageModulationStateCreateInfoNV(
    Pool* pool,
    const VkPipelineCoverageModulationStateCreateInfoNV* from,
    VkPipelineCoverageModulationStateCreateInfoNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->coverageModulationMode = from->coverageModulationMode;
    to->coverageModulationTableEnable = from->coverageModulationTableEnable;
    to->coverageModulationTableCount = from->coverageModulationTableCount;
    to->pCoverageModulationTable = nullptr;
    if (from->pCoverageModulationTable)
    {
        to->pCoverageModulationTable = (float*)pool->dupArray(from->pCoverageModulationTable, from->coverageModulationTableCount * sizeof(const float));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void deepcopy_VkValidationCacheCreateInfoEXT(
    Pool* pool,
    const VkValidationCacheCreateInfoEXT* from,
    VkValidationCacheCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->flags = from->flags;
    to->initialDataSize = from->initialDataSize;
    to->pInitialData = nullptr;
    if (from->pInitialData)
    {
        to->pInitialData = (void*)pool->dupArray(from->pInitialData, from->initialDataSize * sizeof(const uint8_t));
    }
}

void deepcopy_VkShaderModuleValidationCacheCreateInfoEXT(
    Pool* pool,
    const VkShaderModuleValidationCacheCreateInfoEXT* from,
    VkShaderModuleValidationCacheCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->validationCache = from->validationCache;
}

#endif
#ifdef VK_EXT_descriptor_indexing
void deepcopy_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    Pool* pool,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* from,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->bindingCount = from->bindingCount;
    to->pBindingFlags = nullptr;
    if (from->pBindingFlags)
    {
        to->pBindingFlags = (VkDescriptorBindingFlagsEXT*)pool->dupArray(from->pBindingFlags, from->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
    }
}

void deepcopy_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    Pool* pool,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* from,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->shaderInputAttachmentArrayDynamicIndexing = from->shaderInputAttachmentArrayDynamicIndexing;
    to->shaderUniformTexelBufferArrayDynamicIndexing = from->shaderUniformTexelBufferArrayDynamicIndexing;
    to->shaderStorageTexelBufferArrayDynamicIndexing = from->shaderStorageTexelBufferArrayDynamicIndexing;
    to->shaderUniformBufferArrayNonUniformIndexing = from->shaderUniformBufferArrayNonUniformIndexing;
    to->shaderSampledImageArrayNonUniformIndexing = from->shaderSampledImageArrayNonUniformIndexing;
    to->shaderStorageBufferArrayNonUniformIndexing = from->shaderStorageBufferArrayNonUniformIndexing;
    to->shaderStorageImageArrayNonUniformIndexing = from->shaderStorageImageArrayNonUniformIndexing;
    to->shaderInputAttachmentArrayNonUniformIndexing = from->shaderInputAttachmentArrayNonUniformIndexing;
    to->shaderUniformTexelBufferArrayNonUniformIndexing = from->shaderUniformTexelBufferArrayNonUniformIndexing;
    to->shaderStorageTexelBufferArrayNonUniformIndexing = from->shaderStorageTexelBufferArrayNonUniformIndexing;
    to->descriptorBindingUniformBufferUpdateAfterBind = from->descriptorBindingUniformBufferUpdateAfterBind;
    to->descriptorBindingSampledImageUpdateAfterBind = from->descriptorBindingSampledImageUpdateAfterBind;
    to->descriptorBindingStorageImageUpdateAfterBind = from->descriptorBindingStorageImageUpdateAfterBind;
    to->descriptorBindingStorageBufferUpdateAfterBind = from->descriptorBindingStorageBufferUpdateAfterBind;
    to->descriptorBindingUniformTexelBufferUpdateAfterBind = from->descriptorBindingUniformTexelBufferUpdateAfterBind;
    to->descriptorBindingStorageTexelBufferUpdateAfterBind = from->descriptorBindingStorageTexelBufferUpdateAfterBind;
    to->descriptorBindingUpdateUnusedWhilePending = from->descriptorBindingUpdateUnusedWhilePending;
    to->descriptorBindingPartiallyBound = from->descriptorBindingPartiallyBound;
    to->descriptorBindingVariableDescriptorCount = from->descriptorBindingVariableDescriptorCount;
    to->runtimeDescriptorArray = from->runtimeDescriptorArray;
}

void deepcopy_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* from,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxUpdateAfterBindDescriptorsInAllPools = from->maxUpdateAfterBindDescriptorsInAllPools;
    to->shaderUniformBufferArrayNonUniformIndexingNative = from->shaderUniformBufferArrayNonUniformIndexingNative;
    to->shaderSampledImageArrayNonUniformIndexingNative = from->shaderSampledImageArrayNonUniformIndexingNative;
    to->shaderStorageBufferArrayNonUniformIndexingNative = from->shaderStorageBufferArrayNonUniformIndexingNative;
    to->shaderStorageImageArrayNonUniformIndexingNative = from->shaderStorageImageArrayNonUniformIndexingNative;
    to->shaderInputAttachmentArrayNonUniformIndexingNative = from->shaderInputAttachmentArrayNonUniformIndexingNative;
    to->robustBufferAccessUpdateAfterBind = from->robustBufferAccessUpdateAfterBind;
    to->quadDivergentImplicitLod = from->quadDivergentImplicitLod;
    to->maxPerStageDescriptorUpdateAfterBindSamplers = from->maxPerStageDescriptorUpdateAfterBindSamplers;
    to->maxPerStageDescriptorUpdateAfterBindUniformBuffers = from->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    to->maxPerStageDescriptorUpdateAfterBindStorageBuffers = from->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    to->maxPerStageDescriptorUpdateAfterBindSampledImages = from->maxPerStageDescriptorUpdateAfterBindSampledImages;
    to->maxPerStageDescriptorUpdateAfterBindStorageImages = from->maxPerStageDescriptorUpdateAfterBindStorageImages;
    to->maxPerStageDescriptorUpdateAfterBindInputAttachments = from->maxPerStageDescriptorUpdateAfterBindInputAttachments;
    to->maxPerStageUpdateAfterBindResources = from->maxPerStageUpdateAfterBindResources;
    to->maxDescriptorSetUpdateAfterBindSamplers = from->maxDescriptorSetUpdateAfterBindSamplers;
    to->maxDescriptorSetUpdateAfterBindUniformBuffers = from->maxDescriptorSetUpdateAfterBindUniformBuffers;
    to->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = from->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    to->maxDescriptorSetUpdateAfterBindStorageBuffers = from->maxDescriptorSetUpdateAfterBindStorageBuffers;
    to->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = from->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    to->maxDescriptorSetUpdateAfterBindSampledImages = from->maxDescriptorSetUpdateAfterBindSampledImages;
    to->maxDescriptorSetUpdateAfterBindStorageImages = from->maxDescriptorSetUpdateAfterBindStorageImages;
    to->maxDescriptorSetUpdateAfterBindInputAttachments = from->maxDescriptorSetUpdateAfterBindInputAttachments;
}

void deepcopy_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    Pool* pool,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* from,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->descriptorSetCount = from->descriptorSetCount;
    to->pDescriptorCounts = nullptr;
    if (from->pDescriptorCounts)
    {
        to->pDescriptorCounts = (uint32_t*)pool->dupArray(from->pDescriptorCounts, from->descriptorSetCount * sizeof(const uint32_t));
    }
}

void deepcopy_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    Pool* pool,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* from,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxVariableDescriptorCount = from->maxVariableDescriptorCount;
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void deepcopy_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    Pool* pool,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* from,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->globalPriority = from->globalPriority;
}

#endif
#ifdef VK_EXT_external_memory_host
void deepcopy_VkImportMemoryHostPointerInfoEXT(
    Pool* pool,
    const VkImportMemoryHostPointerInfoEXT* from,
    VkImportMemoryHostPointerInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->handleType = from->handleType;
    to->pHostPointer = nullptr;
    if (from->pHostPointer)
    {
        to->pHostPointer = (void*)pool->dupArray(from->pHostPointer, sizeof(uint8_t));
    }
}

void deepcopy_VkMemoryHostPointerPropertiesEXT(
    Pool* pool,
    const VkMemoryHostPointerPropertiesEXT* from,
    VkMemoryHostPointerPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->memoryTypeBits = from->memoryTypeBits;
}

void deepcopy_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* from,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->minImportedHostPointerAlignment = from->minImportedHostPointerAlignment;
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void deepcopy_VkPhysicalDeviceShaderCorePropertiesAMD(
    Pool* pool,
    const VkPhysicalDeviceShaderCorePropertiesAMD* from,
    VkPhysicalDeviceShaderCorePropertiesAMD* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->shaderEngineCount = from->shaderEngineCount;
    to->shaderArraysPerEngineCount = from->shaderArraysPerEngineCount;
    to->computeUnitsPerShaderArray = from->computeUnitsPerShaderArray;
    to->simdPerComputeUnit = from->simdPerComputeUnit;
    to->wavefrontsPerSimd = from->wavefrontsPerSimd;
    to->wavefrontSize = from->wavefrontSize;
    to->sgprsPerSimd = from->sgprsPerSimd;
    to->minSgprAllocation = from->minSgprAllocation;
    to->maxSgprAllocation = from->maxSgprAllocation;
    to->sgprAllocationGranularity = from->sgprAllocationGranularity;
    to->vgprsPerSimd = from->vgprsPerSimd;
    to->minVgprAllocation = from->minVgprAllocation;
    to->maxVgprAllocation = from->maxVgprAllocation;
    to->vgprAllocationGranularity = from->vgprAllocationGranularity;
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void deepcopy_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    Pool* pool,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* from,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->maxVertexAttribDivisor = from->maxVertexAttribDivisor;
}

void deepcopy_VkVertexInputBindingDivisorDescriptionEXT(
    Pool* pool,
    const VkVertexInputBindingDivisorDescriptionEXT* from,
    VkVertexInputBindingDivisorDescriptionEXT* to)
{
    to->binding = from->binding;
    to->divisor = from->divisor;
}

void deepcopy_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    Pool* pool,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* from,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->vertexBindingDivisorCount = from->vertexBindingDivisorCount;
    to->pVertexBindingDivisors = nullptr;
    if (from->pVertexBindingDivisors)
    {
        to->pVertexBindingDivisors = (VkVertexInputBindingDivisorDescriptionEXT*)pool->alloc(from->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
        to->vertexBindingDivisorCount = from->vertexBindingDivisorCount;
        for (uint32_t i = 0; i < (uint32_t)from->vertexBindingDivisorCount; ++i)
        {
            deepcopy_VkVertexInputBindingDivisorDescriptionEXT(pool, from->pVertexBindingDivisors + i, (VkVertexInputBindingDivisorDescriptionEXT*)(to->pVertexBindingDivisors + i));
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void deepcopy_VkQueueFamilyCheckpointPropertiesNV(
    Pool* pool,
    const VkQueueFamilyCheckpointPropertiesNV* from,
    VkQueueFamilyCheckpointPropertiesNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->checkpointExecutionStageMask = from->checkpointExecutionStageMask;
}

void deepcopy_VkCheckpointDataNV(
    Pool* pool,
    const VkCheckpointDataNV* from,
    VkCheckpointDataNV* to)
{
    to->sType = from->sType;
    to->pNext = from->pNext;
    to->stage = from->stage;
    to->pCheckpointMarker = nullptr;
    if (from->pCheckpointMarker)
    {
        to->pCheckpointMarker = (void*)pool->dupArray(from->pCheckpointMarker, sizeof(uint8_t));
    }
}

#endif

} // namespace goldfish_vk
