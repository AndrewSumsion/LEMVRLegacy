// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_marshaling
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_marshaling.h"

#include "VulkanStream.h"

#include "android/base/files/StreamSerializing.h"

namespace goldfish_vk {

#ifdef VK_VERSION_1_0
void marshal_VkApplicationInfo(
    VulkanStream* vkStream,
    const VkApplicationInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->putString(forMarshaling->pApplicationName);
    vkStream->write((uint32_t*)&forMarshaling->applicationVersion, sizeof(uint32_t));
    vkStream->putString(forMarshaling->pEngineName);
    vkStream->write((uint32_t*)&forMarshaling->engineVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
}

void unmarshal_VkApplicationInfo(
    VulkanStream* vkStream,
    VkApplicationInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pApplicationName);
    vkStream->read((uint32_t*)&forUnmarshaling->applicationVersion, sizeof(uint32_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pEngineName);
    vkStream->read((uint32_t*)&forUnmarshaling->engineVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
}

void marshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    const VkInstanceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkInstanceCreateFlags*)&forMarshaling->flags, sizeof(VkInstanceCreateFlags));
    vkStream->write((const VkApplicationInfo**)&forMarshaling->pApplicationInfo, sizeof(const VkApplicationInfo*));
    if (forMarshaling->pApplicationInfo)
    {
        marshal_VkApplicationInfo(vkStream, (const VkApplicationInfo*)(forMarshaling->pApplicationInfo));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
}

void unmarshal_VkInstanceCreateInfo(
    VulkanStream* vkStream,
    VkInstanceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkInstanceCreateFlags*)&forUnmarshaling->flags, sizeof(VkInstanceCreateFlags));
    vkStream->read((VkApplicationInfo**)&forUnmarshaling->pApplicationInfo, sizeof(const VkApplicationInfo*));
    if (forUnmarshaling->pApplicationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pApplicationInfo, sizeof(const VkApplicationInfo));
        unmarshal_VkApplicationInfo(vkStream, (VkApplicationInfo*)(forUnmarshaling->pApplicationInfo));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
}

void marshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    const VkAllocationCallbacks* forMarshaling)
{
    vkStream->write((void**)&forMarshaling->pUserData, sizeof(void*));
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
    vkStream->write((PFN_vkAllocationFunction*)&forMarshaling->pfnAllocation, sizeof(PFN_vkAllocationFunction));
    vkStream->write((PFN_vkReallocationFunction*)&forMarshaling->pfnReallocation, sizeof(PFN_vkReallocationFunction));
    vkStream->write((PFN_vkFreeFunction*)&forMarshaling->pfnFree, sizeof(PFN_vkFreeFunction));
    vkStream->write((PFN_vkInternalAllocationNotification*)&forMarshaling->pfnInternalAllocation, sizeof(PFN_vkInternalAllocationNotification));
    vkStream->write((PFN_vkInternalFreeNotification*)&forMarshaling->pfnInternalFree, sizeof(PFN_vkInternalFreeNotification));
}

void unmarshal_VkAllocationCallbacks(
    VulkanStream* vkStream,
    VkAllocationCallbacks* forUnmarshaling)
{
    vkStream->read((void**)&forUnmarshaling->pUserData, sizeof(void*));
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
    vkStream->read((PFN_vkAllocationFunction*)&forUnmarshaling->pfnAllocation, sizeof(PFN_vkAllocationFunction));
    vkStream->read((PFN_vkReallocationFunction*)&forUnmarshaling->pfnReallocation, sizeof(PFN_vkReallocationFunction));
    vkStream->read((PFN_vkFreeFunction*)&forUnmarshaling->pfnFree, sizeof(PFN_vkFreeFunction));
    vkStream->read((PFN_vkInternalAllocationNotification*)&forUnmarshaling->pfnInternalAllocation, sizeof(PFN_vkInternalAllocationNotification));
    vkStream->read((PFN_vkInternalFreeNotification*)&forUnmarshaling->pfnInternalFree, sizeof(PFN_vkInternalFreeNotification));
}

VkResult marshal_vkCreateInstance(
    VulkanStream* vkStream,
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    marshal_VkInstanceCreateInfo(vkStream, (const VkInstanceCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkInstance*)pInstance, sizeof(VkInstance));
    VkResult marshal_vkCreateInstance_VkResult_return;
    vkStream->read(&marshal_vkCreateInstance_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateInstance_VkResult_return;
}

VkResult unmarshal_vkCreateInstance(
    VulkanStream* vkStream,
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
    unmarshal_VkInstanceCreateInfo(vkStream, (VkInstanceCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkInstance*)pInstance, sizeof(VkInstance));
    VkResult unmarshal_vkCreateInstance_VkResult_return;
    vkStream->write(&unmarshal_vkCreateInstance_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateInstance_VkResult_return;
}

void marshal_vkDestroyInstance(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyInstance(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkEnumeratePhysicalDevices(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    vkStream->read((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
    VkResult marshal_vkEnumeratePhysicalDevices_VkResult_return;
    vkStream->read(&marshal_vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumeratePhysicalDevices_VkResult_return;
}

VkResult unmarshal_vkEnumeratePhysicalDevices(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    vkStream->write((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
    VkResult unmarshal_vkEnumeratePhysicalDevices_VkResult_return;
    vkStream->write(&unmarshal_vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumeratePhysicalDevices_VkResult_return;
}

void marshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFeatures* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->independentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->geometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->logicOp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBounds, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->wideLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->largePoints, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiViewport, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedQueries, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->independentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->geometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBounds, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->wideLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->largePoints, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiViewport, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedQueries, sizeof(VkBool32));
}

void marshal_vkGetPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
}

void unmarshal_vkGetPhysicalDeviceFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
}

void marshal_VkFormatProperties(
    VulkanStream* vkStream,
    const VkFormatProperties* forMarshaling)
{
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void unmarshal_VkFormatProperties(
    VulkanStream* vkStream,
    VkFormatProperties* forUnmarshaling)
{
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void marshal_vkGetPhysicalDeviceFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
}

void unmarshal_vkGetPhysicalDeviceFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    unmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
}

void marshal_VkExtent3D(
    VulkanStream* vkStream,
    const VkExtent3D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
}

void unmarshal_VkExtent3D(
    VulkanStream* vkStream,
    VkExtent3D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->depth, sizeof(uint32_t));
}

void marshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    const VkImageFormatProperties* forMarshaling)
{
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->maxExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

void unmarshal_VkImageFormatProperties(
    VulkanStream* vkStream,
    VkImageFormatProperties* forUnmarshaling)
{
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->maxExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

VkResult marshal_vkGetPhysicalDeviceImageFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&type, sizeof(VkImageType));
    vkStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
    VkResult marshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&type, sizeof(VkImageType));
    vkStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
    VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void marshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    const VkPhysicalDeviceLimits* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxViewports, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->viewportSubPixelBits, sizeof(uint32_t));
    vkStream->write((size_t*)&forMarshaling->minMemoryMapAlignment, sizeof(size_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((int32_t*)&forMarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->minInterpolationOffset, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->timestampPeriod, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->write((float*)forMarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->write((float*)&forMarshaling->pointSizeGranularity, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidthGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->strictLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceLimits(
    VulkanStream* vkStream,
    VkPhysicalDeviceLimits* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxViewports, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportSubPixelBits, sizeof(uint32_t));
    vkStream->read((size_t*)&forUnmarshaling->minMemoryMapAlignment, sizeof(size_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->minInterpolationOffset, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->timestampPeriod, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->read((float*)forUnmarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->read((float*)&forUnmarshaling->pointSizeGranularity, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidthGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->strictLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSparseProperties* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseProperties* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->driverVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vendorID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceID, sizeof(uint32_t));
    vkStream->write((VkPhysicalDeviceType*)&forMarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->write((char*)forMarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->write((uint8_t*)forMarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    marshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forMarshaling->limits));
    marshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forMarshaling->sparseProperties));
}

void unmarshal_VkPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->driverVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vendorID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceID, sizeof(uint32_t));
    vkStream->read((VkPhysicalDeviceType*)&forUnmarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->read((char*)forUnmarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->read((uint8_t*)forUnmarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    unmarshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forUnmarshaling->limits));
    unmarshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forUnmarshaling->sparseProperties));
}

void marshal_vkGetPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
}

void unmarshal_vkGetPhysicalDeviceProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
}

void marshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    const VkQueueFamilyProperties* forMarshaling)
{
    vkStream->write((VkQueueFlags*)&forMarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->timestampValidBits, sizeof(uint32_t));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->minImageTransferGranularity));
}

void unmarshal_VkQueueFamilyProperties(
    VulkanStream* vkStream,
    VkQueueFamilyProperties* forUnmarshaling)
{
    vkStream->read((VkQueueFlags*)&forUnmarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->timestampValidBits, sizeof(uint32_t));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->minImageTransferGranularity));
}

void marshal_vkGetPhysicalDeviceQueueFamilyProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceQueueFamilyProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        unmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
    }
}

void marshal_VkMemoryType(
    VulkanStream* vkStream,
    const VkMemoryType* forMarshaling)
{
    vkStream->write((VkMemoryPropertyFlags*)&forMarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->write((uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryType(
    VulkanStream* vkStream,
    VkMemoryType* forUnmarshaling)
{
    vkStream->read((VkMemoryPropertyFlags*)&forUnmarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->heapIndex, sizeof(uint32_t));
}

void marshal_VkMemoryHeap(
    VulkanStream* vkStream,
    const VkMemoryHeap* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkMemoryHeapFlags*)&forMarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void unmarshal_VkMemoryHeap(
    VulkanStream* vkStream,
    VkMemoryHeap* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkMemoryHeapFlags*)&forUnmarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void marshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        marshal_VkMemoryType(vkStream, (VkMemoryType*)(forMarshaling->memoryTypes + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        marshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forMarshaling->memoryHeaps + i));
    }
}

void unmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        unmarshal_VkMemoryType(vkStream, (VkMemoryType*)(forUnmarshaling->memoryTypes + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        unmarshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forUnmarshaling->memoryHeaps + i));
    }
}

void marshal_vkGetPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
}

void unmarshal_vkGetPhysicalDeviceMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
}

PFN_vkVoidFunction marshal_vkGetInstanceProcAddr(
    VulkanStream* vkStream,
    VkInstance instance,
    const char* pName)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->putString(pName);
    PFN_vkVoidFunction marshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
    vkStream->read(&marshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return marshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction unmarshal_vkGetInstanceProcAddr(
    VulkanStream* vkStream,
    VkInstance instance,
    const char* pName)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->loadStringInPlace((char**)&pName);
    PFN_vkVoidFunction unmarshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
    vkStream->write(&unmarshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return unmarshal_vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction marshal_vkGetDeviceProcAddr(
    VulkanStream* vkStream,
    VkDevice device,
    const char* pName)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->putString(pName);
    PFN_vkVoidFunction marshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
    vkStream->read(&marshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return marshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction unmarshal_vkGetDeviceProcAddr(
    VulkanStream* vkStream,
    VkDevice device,
    const char* pName)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->loadStringInPlace((char**)&pName);
    PFN_vkVoidFunction unmarshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
    vkStream->write(&unmarshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return unmarshal_vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

void marshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceQueueCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((const float*)forMarshaling->pQueuePriorities, forMarshaling->queueCount * sizeof(const float));
}

void unmarshal_VkDeviceQueueCreateInfo(
    VulkanStream* vkStream,
    VkDeviceQueueCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
    vkStream->read((float*)forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
}

void marshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCreateInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueCreateInfoCount; ++i)
    {
        marshal_VkDeviceQueueCreateInfo(vkStream, (const VkDeviceQueueCreateInfo*)(forMarshaling->pQueueCreateInfos + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
    vkStream->write((const VkPhysicalDeviceFeatures**)&forMarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures*));
    if (forMarshaling->pEnabledFeatures)
    {
        marshal_VkPhysicalDeviceFeatures(vkStream, (const VkPhysicalDeviceFeatures*)(forMarshaling->pEnabledFeatures));
    }
}

void unmarshal_VkDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCreateInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pQueueCreateInfos, forUnmarshaling->queueCreateInfoCount * sizeof(const VkDeviceQueueCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueCreateInfoCount; ++i)
    {
        unmarshal_VkDeviceQueueCreateInfo(vkStream, (VkDeviceQueueCreateInfo*)(forUnmarshaling->pQueueCreateInfos + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
    vkStream->read((VkPhysicalDeviceFeatures**)&forUnmarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures*));
    if (forUnmarshaling->pEnabledFeatures)
    {
        vkStream->alloc((void**)&forUnmarshaling->pEnabledFeatures, sizeof(const VkPhysicalDeviceFeatures));
        unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(forUnmarshaling->pEnabledFeatures));
    }
}

VkResult marshal_vkCreateDevice(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDeviceCreateInfo(vkStream, (const VkDeviceCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDevice*)pDevice, sizeof(VkDevice));
    VkResult marshal_vkCreateDevice_VkResult_return;
    vkStream->read(&marshal_vkCreateDevice_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDevice_VkResult_return;
}

VkResult unmarshal_vkCreateDevice(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
    unmarshal_VkDeviceCreateInfo(vkStream, (VkDeviceCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDevice*)pDevice, sizeof(VkDevice));
    VkResult unmarshal_vkCreateDevice_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDevice_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDevice_VkResult_return;
}

void marshal_vkDestroyDevice(
    VulkanStream* vkStream,
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDevice(
    VulkanStream* vkStream,
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkExtensionProperties(
    VulkanStream* vkStream,
    const VkExtensionProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
}

void unmarshal_VkExtensionProperties(
    VulkanStream* vkStream,
    VkExtensionProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
}

VkResult marshal_vkEnumerateInstanceExtensionProperties(
    VulkanStream* vkStream,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    vkStream->putString(pLayerName);
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
    }
    VkResult marshal_vkEnumerateInstanceExtensionProperties_VkResult_return;
    vkStream->read(&marshal_vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult unmarshal_vkEnumerateInstanceExtensionProperties(
    VulkanStream* vkStream,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    vkStream->loadStringInPlace((char**)&pLayerName);
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
    }
    VkResult unmarshal_vkEnumerateInstanceExtensionProperties_VkResult_return;
    vkStream->write(&unmarshal_vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult marshal_vkEnumerateDeviceExtensionProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->putString(pLayerName);
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
    }
    VkResult marshal_vkEnumerateDeviceExtensionProperties_VkResult_return;
    vkStream->read(&marshal_vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult unmarshal_vkEnumerateDeviceExtensionProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->loadStringInPlace((char**)&pLayerName);
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
    }
    VkResult unmarshal_vkEnumerateDeviceExtensionProperties_VkResult_return;
    vkStream->write(&unmarshal_vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumerateDeviceExtensionProperties_VkResult_return;
}

void marshal_VkLayerProperties(
    VulkanStream* vkStream,
    const VkLayerProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void unmarshal_VkLayerProperties(
    VulkanStream* vkStream,
    VkLayerProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

VkResult marshal_vkEnumerateInstanceLayerProperties(
    VulkanStream* vkStream,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
    }
    VkResult marshal_vkEnumerateInstanceLayerProperties_VkResult_return;
    vkStream->read(&marshal_vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult unmarshal_vkEnumerateInstanceLayerProperties(
    VulkanStream* vkStream,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
    }
    VkResult unmarshal_vkEnumerateInstanceLayerProperties_VkResult_return;
    vkStream->write(&unmarshal_vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult marshal_vkEnumerateDeviceLayerProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
    }
    VkResult marshal_vkEnumerateDeviceLayerProperties_VkResult_return;
    vkStream->read(&marshal_vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumerateDeviceLayerProperties_VkResult_return;
}

VkResult unmarshal_vkEnumerateDeviceLayerProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
    }
    VkResult unmarshal_vkEnumerateDeviceLayerProperties_VkResult_return;
    vkStream->write(&unmarshal_vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumerateDeviceLayerProperties_VkResult_return;
}

void marshal_vkGetDeviceQueue(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&queueIndex, sizeof(uint32_t));
    vkStream->read((VkQueue*)pQueue, sizeof(VkQueue));
}

void unmarshal_vkGetDeviceQueue(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&queueIndex, sizeof(uint32_t));
    vkStream->write((VkQueue*)pQueue, sizeof(VkQueue));
}

void marshal_VkSubmitInfo(
    VulkanStream* vkStream,
    const VkSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const VkSemaphore*)forMarshaling->pWaitSemaphores, forMarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->write((const VkPipelineStageFlags*)forMarshaling->pWaitDstStageMask, forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->write((const VkCommandBuffer*)forMarshaling->pCommandBuffers, forMarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const VkSemaphore*)forMarshaling->pSignalSemaphores, forMarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
}

void unmarshal_VkSubmitInfo(
    VulkanStream* vkStream,
    VkSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->alloc((void**)&forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    vkStream->read((VkCommandBuffer*)forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount * sizeof(const VkCommandBuffer));
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
}

VkResult marshal_vkQueueSubmit(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->write((uint32_t*)&submitCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        marshal_VkSubmitInfo(vkStream, (const VkSubmitInfo*)(pSubmits + i));
    }
    vkStream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult marshal_vkQueueSubmit_VkResult_return;
    vkStream->read(&marshal_vkQueueSubmit_VkResult_return, sizeof(VkResult));
    return marshal_vkQueueSubmit_VkResult_return;
}

VkResult unmarshal_vkQueueSubmit(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->read((uint32_t*)&submitCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        unmarshal_VkSubmitInfo(vkStream, (VkSubmitInfo*)(pSubmits + i));
    }
    vkStream->read((VkFence*)&fence, sizeof(VkFence));
    VkResult unmarshal_vkQueueSubmit_VkResult_return;
    vkStream->write(&unmarshal_vkQueueSubmit_VkResult_return, sizeof(VkResult));
    return unmarshal_vkQueueSubmit_VkResult_return;
}

VkResult marshal_vkQueueWaitIdle(
    VulkanStream* vkStream,
    VkQueue queue)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    VkResult marshal_vkQueueWaitIdle_VkResult_return;
    vkStream->read(&marshal_vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    return marshal_vkQueueWaitIdle_VkResult_return;
}

VkResult unmarshal_vkQueueWaitIdle(
    VulkanStream* vkStream,
    VkQueue queue)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    VkResult unmarshal_vkQueueWaitIdle_VkResult_return;
    vkStream->write(&unmarshal_vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    return unmarshal_vkQueueWaitIdle_VkResult_return;
}

VkResult marshal_vkDeviceWaitIdle(
    VulkanStream* vkStream,
    VkDevice device)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    VkResult marshal_vkDeviceWaitIdle_VkResult_return;
    vkStream->read(&marshal_vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    return marshal_vkDeviceWaitIdle_VkResult_return;
}

VkResult unmarshal_vkDeviceWaitIdle(
    VulkanStream* vkStream,
    VkDevice device)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    VkResult unmarshal_vkDeviceWaitIdle_VkResult_return;
    vkStream->write(&unmarshal_vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    return unmarshal_vkDeviceWaitIdle_VkResult_return;
}

void marshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    const VkMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeIndex, sizeof(uint32_t));
}

VkResult marshal_vkAllocateMemory(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryAllocateInfo(vkStream, (const VkMemoryAllocateInfo*)(pAllocateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
    VkResult marshal_vkAllocateMemory_VkResult_return;
    vkStream->read(&marshal_vkAllocateMemory_VkResult_return, sizeof(VkResult));
    return marshal_vkAllocateMemory_VkResult_return;
}

VkResult unmarshal_vkAllocateMemory(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
    unmarshal_VkMemoryAllocateInfo(vkStream, (VkMemoryAllocateInfo*)(pAllocateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
    VkResult unmarshal_vkAllocateMemory_VkResult_return;
    vkStream->write(&unmarshal_vkAllocateMemory_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAllocateMemory_VkResult_return;
}

void marshal_vkFreeMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkFreeMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkMapMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    vkStream->write((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
    vkStream->read((void**)ppData, sizeof(void*));
    VkResult marshal_vkMapMemory_VkResult_return;
    vkStream->read(&marshal_vkMapMemory_VkResult_return, sizeof(VkResult));
    return marshal_vkMapMemory_VkResult_return;
}

VkResult unmarshal_vkMapMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    vkStream->read((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
    vkStream->write((void**)ppData, sizeof(void*));
    VkResult unmarshal_vkMapMemory_VkResult_return;
    vkStream->write(&unmarshal_vkMapMemory_VkResult_return, sizeof(VkResult));
    return unmarshal_vkMapMemory_VkResult_return;
}

void marshal_vkUnmapMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
}

void unmarshal_vkUnmapMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
}

void marshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    const VkMappedMemoryRange* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkMappedMemoryRange(
    VulkanStream* vkStream,
    VkMappedMemoryRange* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

VkResult marshal_vkFlushMappedMemoryRanges(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(vkStream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult marshal_vkFlushMappedMemoryRanges_VkResult_return;
    vkStream->read(&marshal_vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return marshal_vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult unmarshal_vkFlushMappedMemoryRanges(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        unmarshal_VkMappedMemoryRange(vkStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult unmarshal_vkFlushMappedMemoryRanges_VkResult_return;
    vkStream->write(&unmarshal_vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return unmarshal_vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult marshal_vkInvalidateMappedMemoryRanges(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(vkStream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult marshal_vkInvalidateMappedMemoryRanges_VkResult_return;
    vkStream->read(&marshal_vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return marshal_vkInvalidateMappedMemoryRanges_VkResult_return;
}

VkResult unmarshal_vkInvalidateMappedMemoryRanges(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        unmarshal_VkMappedMemoryRange(vkStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult unmarshal_vkInvalidateMappedMemoryRanges_VkResult_return;
    vkStream->write(&unmarshal_vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return unmarshal_vkInvalidateMappedMemoryRanges_VkResult_return;
}

void marshal_vkGetDeviceMemoryCommitment(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
}

void unmarshal_vkGetDeviceMemoryCommitment(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
}

VkResult marshal_vkBindBufferMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult marshal_vkBindBufferMemory_VkResult_return;
    vkStream->read(&marshal_vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    return marshal_vkBindBufferMemory_VkResult_return;
}

VkResult unmarshal_vkBindBufferMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult unmarshal_vkBindBufferMemory_VkResult_return;
    vkStream->write(&unmarshal_vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindBufferMemory_VkResult_return;
}

VkResult marshal_vkBindImageMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult marshal_vkBindImageMemory_VkResult_return;
    vkStream->read(&marshal_vkBindImageMemory_VkResult_return, sizeof(VkResult));
    return marshal_vkBindImageMemory_VkResult_return;
}

VkResult unmarshal_vkBindImageMemory(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult unmarshal_vkBindImageMemory_VkResult_return;
    vkStream->write(&unmarshal_vkBindImageMemory_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindImageMemory_VkResult_return;
}

void marshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    const VkMemoryRequirements* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryRequirements(
    VulkanStream* vkStream,
    VkMemoryRequirements* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_vkGetBufferMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void unmarshal_vkGetBufferMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    unmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void marshal_vkGetImageMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void unmarshal_vkGetImageMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    unmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void marshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    const VkSparseImageFormatProperties* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageGranularity));
    vkStream->write((VkSparseImageFormatFlags*)&forMarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void unmarshal_VkSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageGranularity));
    vkStream->read((VkSparseImageFormatFlags*)&forUnmarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void marshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    const VkSparseImageMemoryRequirements* forMarshaling)
{
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->formatProperties));
    vkStream->write((uint32_t*)&forMarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void unmarshal_VkSparseImageMemoryRequirements(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements* forUnmarshaling)
{
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->formatProperties));
    vkStream->read((uint32_t*)&forUnmarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void marshal_vkGetImageSparseMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    vkStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
    }
}

void unmarshal_vkGetImageSparseMemoryRequirements(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        unmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
    }
}

void marshal_vkGetPhysicalDeviceSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&type, sizeof(VkImageType));
    vkStream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceSparseImageFormatProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&type, sizeof(VkImageType));
    vkStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
    }
}

void marshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    const VkSparseMemoryBind* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseMemoryBind(
    VulkanStream* vkStream,
    VkSparseMemoryBind* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseBufferMemoryBindInfo* forMarshaling)
{
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseBufferMemoryBindInfo* forUnmarshaling)
{
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseImageOpaqueMemoryBindInfo* forMarshaling)
{
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageOpaqueMemoryBindInfo* forUnmarshaling)
{
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkImageSubresource(
    VulkanStream* vkStream,
    const VkImageSubresource* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayer, sizeof(uint32_t));
}

void unmarshal_VkImageSubresource(
    VulkanStream* vkStream,
    VkImageSubresource* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayer, sizeof(uint32_t));
}

void marshal_VkOffset3D(
    VulkanStream* vkStream,
    const VkOffset3D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->z, sizeof(int32_t));
}

void unmarshal_VkOffset3D(
    VulkanStream* vkStream,
    VkOffset3D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->z, sizeof(int32_t));
}

void marshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    const VkSparseImageMemoryBind* forMarshaling)
{
    marshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forMarshaling->subresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->offset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseImageMemoryBind(
    VulkanStream* vkStream,
    VkSparseImageMemoryBind* forUnmarshaling)
{
    unmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forUnmarshaling->subresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    const VkSparseImageMemoryBindInfo* forMarshaling)
{
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseImageMemoryBind(vkStream, (const VkSparseImageMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageMemoryBindInfo(
    VulkanStream* vkStream,
    VkSparseImageMemoryBindInfo* forUnmarshaling)
{
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBinds, forUnmarshaling->bindCount * sizeof(const VkSparseImageMemoryBind));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBind(vkStream, (VkSparseImageMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    const VkBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const VkSemaphore*)forMarshaling->pWaitSemaphores, forMarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->write((uint32_t*)&forMarshaling->bufferBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bufferBindCount; ++i)
    {
        marshal_VkSparseBufferMemoryBindInfo(vkStream, (const VkSparseBufferMemoryBindInfo*)(forMarshaling->pBufferBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageOpaqueBindCount; ++i)
    {
        marshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (const VkSparseImageOpaqueMemoryBindInfo*)(forMarshaling->pImageOpaqueBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageBindCount; ++i)
    {
        marshal_VkSparseImageMemoryBindInfo(vkStream, (const VkSparseImageMemoryBindInfo*)(forMarshaling->pImageBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const VkSemaphore*)forMarshaling->pSignalSemaphores, forMarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
}

void unmarshal_VkBindSparseInfo(
    VulkanStream* vkStream,
    VkBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBufferBinds, forUnmarshaling->bufferBindCount * sizeof(const VkSparseBufferMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bufferBindCount; ++i)
    {
        unmarshal_VkSparseBufferMemoryBindInfo(vkStream, (VkSparseBufferMemoryBindInfo*)(forUnmarshaling->pBufferBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pImageOpaqueBinds, forUnmarshaling->imageOpaqueBindCount * sizeof(const VkSparseImageOpaqueMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageOpaqueBindCount; ++i)
    {
        unmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (VkSparseImageOpaqueMemoryBindInfo*)(forUnmarshaling->pImageOpaqueBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageBindCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pImageBinds, forUnmarshaling->imageBindCount * sizeof(const VkSparseImageMemoryBindInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageBindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBindInfo(vkStream, (VkSparseImageMemoryBindInfo*)(forUnmarshaling->pImageBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount * sizeof(const VkSemaphore));
}

VkResult marshal_vkQueueBindSparse(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindSparseInfo(vkStream, (const VkBindSparseInfo*)(pBindInfo + i));
    }
    vkStream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult marshal_vkQueueBindSparse_VkResult_return;
    vkStream->read(&marshal_vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    return marshal_vkQueueBindSparse_VkResult_return;
}

VkResult unmarshal_vkQueueBindSparse(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        unmarshal_VkBindSparseInfo(vkStream, (VkBindSparseInfo*)(pBindInfo + i));
    }
    vkStream->read((VkFence*)&fence, sizeof(VkFence));
    VkResult unmarshal_vkQueueBindSparse_VkResult_return;
    vkStream->write(&unmarshal_vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    return unmarshal_vkQueueBindSparse_VkResult_return;
}

void marshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    const VkFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFenceCreateFlags*)&forMarshaling->flags, sizeof(VkFenceCreateFlags));
}

void unmarshal_VkFenceCreateInfo(
    VulkanStream* vkStream,
    VkFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFenceCreateFlags*)&forUnmarshaling->flags, sizeof(VkFenceCreateFlags));
}

VkResult marshal_vkCreateFence(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceCreateInfo(vkStream, (const VkFenceCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult marshal_vkCreateFence_VkResult_return;
    vkStream->read(&marshal_vkCreateFence_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateFence_VkResult_return;
}

VkResult unmarshal_vkCreateFence(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
    unmarshal_VkFenceCreateInfo(vkStream, (VkFenceCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkFence*)pFence, sizeof(VkFence));
    VkResult unmarshal_vkCreateFence_VkResult_return;
    vkStream->write(&unmarshal_vkCreateFence_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateFence_VkResult_return;
}

void marshal_vkDestroyFence(
    VulkanStream* vkStream,
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkFence*)&fence, sizeof(VkFence));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyFence(
    VulkanStream* vkStream,
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkFence*)&fence, sizeof(VkFence));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkResetFences(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
    vkStream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    VkResult marshal_vkResetFences_VkResult_return;
    vkStream->read(&marshal_vkResetFences_VkResult_return, sizeof(VkResult));
    return marshal_vkResetFences_VkResult_return;
}

VkResult unmarshal_vkResetFences(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
    vkStream->read((VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    VkResult unmarshal_vkResetFences_VkResult_return;
    vkStream->write(&unmarshal_vkResetFences_VkResult_return, sizeof(VkResult));
    return unmarshal_vkResetFences_VkResult_return;
}

VkResult marshal_vkGetFenceStatus(
    VulkanStream* vkStream,
    VkDevice device,
    VkFence fence)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult marshal_vkGetFenceStatus_VkResult_return;
    vkStream->read(&marshal_vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    return marshal_vkGetFenceStatus_VkResult_return;
}

VkResult unmarshal_vkGetFenceStatus(
    VulkanStream* vkStream,
    VkDevice device,
    VkFence fence)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkFence*)&fence, sizeof(VkFence));
    VkResult unmarshal_vkGetFenceStatus_VkResult_return;
    vkStream->write(&unmarshal_vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetFenceStatus_VkResult_return;
}

VkResult marshal_vkWaitForFences(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
    vkStream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    vkStream->write((VkBool32*)&waitAll, sizeof(VkBool32));
    vkStream->write((uint64_t*)&timeout, sizeof(uint64_t));
    VkResult marshal_vkWaitForFences_VkResult_return;
    vkStream->read(&marshal_vkWaitForFences_VkResult_return, sizeof(VkResult));
    return marshal_vkWaitForFences_VkResult_return;
}

VkResult unmarshal_vkWaitForFences(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
    vkStream->read((VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    vkStream->read((VkBool32*)&waitAll, sizeof(VkBool32));
    vkStream->read((uint64_t*)&timeout, sizeof(uint64_t));
    VkResult unmarshal_vkWaitForFences_VkResult_return;
    vkStream->write(&unmarshal_vkWaitForFences_VkResult_return, sizeof(VkResult));
    return unmarshal_vkWaitForFences_VkResult_return;
}

void marshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    const VkSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSemaphoreCreateFlags*)&forMarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

void unmarshal_VkSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSemaphoreCreateFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

VkResult marshal_vkCreateSemaphore(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreCreateInfo(vkStream, (const VkSemaphoreCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
    VkResult marshal_vkCreateSemaphore_VkResult_return;
    vkStream->read(&marshal_vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSemaphore_VkResult_return;
}

VkResult unmarshal_vkCreateSemaphore(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
    unmarshal_VkSemaphoreCreateInfo(vkStream, (VkSemaphoreCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
    VkResult unmarshal_vkCreateSemaphore_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSemaphore_VkResult_return;
}

void marshal_vkDestroySemaphore(
    VulkanStream* vkStream,
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySemaphore(
    VulkanStream* vkStream,
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    const VkEventCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkEventCreateFlags*)&forMarshaling->flags, sizeof(VkEventCreateFlags));
}

void unmarshal_VkEventCreateInfo(
    VulkanStream* vkStream,
    VkEventCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkEventCreateFlags*)&forUnmarshaling->flags, sizeof(VkEventCreateFlags));
}

VkResult marshal_vkCreateEvent(
    VulkanStream* vkStream,
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkEventCreateInfo(vkStream, (const VkEventCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkEvent*)pEvent, sizeof(VkEvent));
    VkResult marshal_vkCreateEvent_VkResult_return;
    vkStream->read(&marshal_vkCreateEvent_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateEvent_VkResult_return;
}

VkResult unmarshal_vkCreateEvent(
    VulkanStream* vkStream,
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
    unmarshal_VkEventCreateInfo(vkStream, (VkEventCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkEvent*)pEvent, sizeof(VkEvent));
    VkResult unmarshal_vkCreateEvent_VkResult_return;
    vkStream->write(&unmarshal_vkCreateEvent_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateEvent_VkResult_return;
}

void marshal_vkDestroyEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkGetEventStatus(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult marshal_vkGetEventStatus_VkResult_return;
    vkStream->read(&marshal_vkGetEventStatus_VkResult_return, sizeof(VkResult));
    return marshal_vkGetEventStatus_VkResult_return;
}

VkResult unmarshal_vkGetEventStatus(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    VkResult unmarshal_vkGetEventStatus_VkResult_return;
    vkStream->write(&unmarshal_vkGetEventStatus_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetEventStatus_VkResult_return;
}

VkResult marshal_vkSetEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult marshal_vkSetEvent_VkResult_return;
    vkStream->read(&marshal_vkSetEvent_VkResult_return, sizeof(VkResult));
    return marshal_vkSetEvent_VkResult_return;
}

VkResult unmarshal_vkSetEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    VkResult unmarshal_vkSetEvent_VkResult_return;
    vkStream->write(&unmarshal_vkSetEvent_VkResult_return, sizeof(VkResult));
    return unmarshal_vkSetEvent_VkResult_return;
}

VkResult marshal_vkResetEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult marshal_vkResetEvent_VkResult_return;
    vkStream->read(&marshal_vkResetEvent_VkResult_return, sizeof(VkResult));
    return marshal_vkResetEvent_VkResult_return;
}

VkResult unmarshal_vkResetEvent(
    VulkanStream* vkStream,
    VkDevice device,
    VkEvent event)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    VkResult unmarshal_vkResetEvent_VkResult_return;
    vkStream->write(&unmarshal_vkResetEvent_VkResult_return, sizeof(VkResult));
    return unmarshal_vkResetEvent_VkResult_return;
}

void marshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    const VkQueryPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkQueryPoolCreateFlags*)&forMarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->write((VkQueryType*)&forMarshaling->queryType, sizeof(VkQueryType));
    vkStream->write((uint32_t*)&forMarshaling->queryCount, sizeof(uint32_t));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkQueryPoolCreateInfo(
    VulkanStream* vkStream,
    VkQueryPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkQueryPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->read((VkQueryType*)&forUnmarshaling->queryType, sizeof(VkQueryType));
    vkStream->read((uint32_t*)&forUnmarshaling->queryCount, sizeof(uint32_t));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

VkResult marshal_vkCreateQueryPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkQueryPoolCreateInfo(vkStream, (const VkQueryPoolCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
    VkResult marshal_vkCreateQueryPool_VkResult_return;
    vkStream->read(&marshal_vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateQueryPool_VkResult_return;
}

VkResult unmarshal_vkCreateQueryPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
    unmarshal_VkQueryPoolCreateInfo(vkStream, (VkQueryPoolCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
    VkResult unmarshal_vkCreateQueryPool_VkResult_return;
    vkStream->write(&unmarshal_vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateQueryPool_VkResult_return;
}

void marshal_vkDestroyQueryPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyQueryPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkGetQueryPoolResults(
    VulkanStream* vkStream,
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
    vkStream->write((size_t*)&dataSize, sizeof(size_t));
    vkStream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    vkStream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    vkStream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
    VkResult marshal_vkGetQueryPoolResults_VkResult_return;
    vkStream->read(&marshal_vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    return marshal_vkGetQueryPoolResults_VkResult_return;
}

VkResult unmarshal_vkGetQueryPoolResults(
    VulkanStream* vkStream,
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
    vkStream->read((size_t*)&dataSize, sizeof(size_t));
    vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
    vkStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    vkStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
    VkResult unmarshal_vkGetQueryPoolResults_VkResult_return;
    vkStream->write(&unmarshal_vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetQueryPoolResults_VkResult_return;
}

void marshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    const VkBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t**)&forMarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void unmarshal_VkBufferCreateInfo(
    VulkanStream* vkStream,
    VkBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->read((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

VkResult marshal_vkCreateBuffer(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferCreateInfo(vkStream, (const VkBufferCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkBuffer*)pBuffer, sizeof(VkBuffer));
    VkResult marshal_vkCreateBuffer_VkResult_return;
    vkStream->read(&marshal_vkCreateBuffer_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateBuffer_VkResult_return;
}

VkResult unmarshal_vkCreateBuffer(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
    unmarshal_VkBufferCreateInfo(vkStream, (VkBufferCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkBuffer*)pBuffer, sizeof(VkBuffer));
    VkResult unmarshal_vkCreateBuffer_VkResult_return;
    vkStream->write(&unmarshal_vkCreateBuffer_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateBuffer_VkResult_return;
}

void marshal_vkDestroyBuffer(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyBuffer(
    VulkanStream* vkStream,
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    const VkBufferViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBufferViewCreateFlags*)&forMarshaling->flags, sizeof(VkBufferViewCreateFlags));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferViewCreateInfo(
    VulkanStream* vkStream,
    VkBufferViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBufferViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferViewCreateFlags));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

VkResult marshal_vkCreateBufferView(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferViewCreateInfo(vkStream, (const VkBufferViewCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkBufferView*)pView, sizeof(VkBufferView));
    VkResult marshal_vkCreateBufferView_VkResult_return;
    vkStream->read(&marshal_vkCreateBufferView_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateBufferView_VkResult_return;
}

VkResult unmarshal_vkCreateBufferView(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
    unmarshal_VkBufferViewCreateInfo(vkStream, (VkBufferViewCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkBufferView*)pView, sizeof(VkBufferView));
    VkResult unmarshal_vkCreateBufferView_VkResult_return;
    vkStream->write(&unmarshal_vkCreateBufferView_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateBufferView_VkResult_return;
}

void marshal_vkDestroyBufferView(
    VulkanStream* vkStream,
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkBufferView*)&bufferView, sizeof(VkBufferView));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyBufferView(
    VulkanStream* vkStream,
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkBufferView*)&bufferView, sizeof(VkBufferView));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    const VkImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->write((VkImageType*)&forMarshaling->imageType, sizeof(VkImageType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->mipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t**)&forMarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
}

void unmarshal_VkImageCreateInfo(
    VulkanStream* vkStream,
    VkImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->read((VkImageType*)&forUnmarshaling->imageType, sizeof(VkImageType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->read((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
}

VkResult marshal_vkCreateImage(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageCreateInfo(vkStream, (const VkImageCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkImage*)pImage, sizeof(VkImage));
    VkResult marshal_vkCreateImage_VkResult_return;
    vkStream->read(&marshal_vkCreateImage_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateImage_VkResult_return;
}

VkResult unmarshal_vkCreateImage(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
    unmarshal_VkImageCreateInfo(vkStream, (VkImageCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkImage*)pImage, sizeof(VkImage));
    VkResult unmarshal_vkCreateImage_VkResult_return;
    vkStream->write(&unmarshal_vkCreateImage_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateImage_VkResult_return;
}

void marshal_vkDestroyImage(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyImage(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    const VkSubresourceLayout* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->depthPitch, sizeof(VkDeviceSize));
}

void unmarshal_VkSubresourceLayout(
    VulkanStream* vkStream,
    VkSubresourceLayout* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->depthPitch, sizeof(VkDeviceSize));
}

void marshal_vkGetImageSubresourceLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    marshal_VkImageSubresource(vkStream, (const VkImageSubresource*)(pSubresource));
    marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
}

void unmarshal_vkGetImageSubresourceLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
    unmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(pSubresource));
    unmarshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
}

void marshal_VkComponentMapping(
    VulkanStream* vkStream,
    const VkComponentMapping* forMarshaling)
{
    vkStream->write((VkComponentSwizzle*)&forMarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->a, sizeof(VkComponentSwizzle));
}

void unmarshal_VkComponentMapping(
    VulkanStream* vkStream,
    VkComponentMapping* forUnmarshaling)
{
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->a, sizeof(VkComponentSwizzle));
}

void marshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    const VkImageSubresourceRange* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->levelCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceRange(
    VulkanStream* vkStream,
    VkImageSubresourceRange* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->levelCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    const VkImageViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImageViewCreateFlags*)&forMarshaling->flags, sizeof(VkImageViewCreateFlags));
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((VkImageViewType*)&forMarshaling->viewType, sizeof(VkImageViewType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageViewCreateInfo(
    VulkanStream* vkStream,
    VkImageViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImageViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageViewCreateFlags));
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((VkImageViewType*)&forUnmarshaling->viewType, sizeof(VkImageViewType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

VkResult marshal_vkCreateImageView(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageViewCreateInfo(vkStream, (const VkImageViewCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkImageView*)pView, sizeof(VkImageView));
    VkResult marshal_vkCreateImageView_VkResult_return;
    vkStream->read(&marshal_vkCreateImageView_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateImageView_VkResult_return;
}

VkResult unmarshal_vkCreateImageView(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
    unmarshal_VkImageViewCreateInfo(vkStream, (VkImageViewCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkImageView*)pView, sizeof(VkImageView));
    VkResult unmarshal_vkCreateImageView_VkResult_return;
    vkStream->write(&unmarshal_vkCreateImageView_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateImageView_VkResult_return;
}

void marshal_vkDestroyImageView(
    VulkanStream* vkStream,
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkImageView*)&imageView, sizeof(VkImageView));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyImageView(
    VulkanStream* vkStream,
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkImageView*)&imageView, sizeof(VkImageView));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    const VkShaderModuleCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkShaderModuleCreateFlags*)&forMarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    vkStream->write((size_t*)&forMarshaling->codeSize, sizeof(size_t));
    vkStream->write((const uint32_t*)forMarshaling->pCode, (forMarshaling->codeSize / 4) * sizeof(const uint32_t));
}

void unmarshal_VkShaderModuleCreateInfo(
    VulkanStream* vkStream,
    VkShaderModuleCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkShaderModuleCreateFlags*)&forUnmarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    vkStream->read((size_t*)&forUnmarshaling->codeSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
}

VkResult marshal_vkCreateShaderModule(
    VulkanStream* vkStream,
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkShaderModuleCreateInfo(vkStream, (const VkShaderModuleCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
    VkResult marshal_vkCreateShaderModule_VkResult_return;
    vkStream->read(&marshal_vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateShaderModule_VkResult_return;
}

VkResult unmarshal_vkCreateShaderModule(
    VulkanStream* vkStream,
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
    unmarshal_VkShaderModuleCreateInfo(vkStream, (VkShaderModuleCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
    VkResult unmarshal_vkCreateShaderModule_VkResult_return;
    vkStream->write(&unmarshal_vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateShaderModule_VkResult_return;
}

void marshal_vkDestroyShaderModule(
    VulkanStream* vkStream,
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkShaderModule*)&shaderModule, sizeof(VkShaderModule));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyShaderModule(
    VulkanStream* vkStream,
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkShaderModule*)&shaderModule, sizeof(VkShaderModule));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineCacheCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineCacheCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    vkStream->write((size_t*)&forMarshaling->initialDataSize, sizeof(size_t));
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkPipelineCacheCreateInfo(
    VulkanStream* vkStream,
    VkPipelineCacheCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineCacheCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    vkStream->read((size_t*)&forUnmarshaling->initialDataSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

VkResult marshal_vkCreatePipelineCache(
    VulkanStream* vkStream,
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkPipelineCacheCreateInfo(vkStream, (const VkPipelineCacheCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
    VkResult marshal_vkCreatePipelineCache_VkResult_return;
    vkStream->read(&marshal_vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    return marshal_vkCreatePipelineCache_VkResult_return;
}

VkResult unmarshal_vkCreatePipelineCache(
    VulkanStream* vkStream,
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
    unmarshal_VkPipelineCacheCreateInfo(vkStream, (VkPipelineCacheCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
    VkResult unmarshal_vkCreatePipelineCache_VkResult_return;
    vkStream->write(&unmarshal_vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreatePipelineCache_VkResult_return;
}

void marshal_vkDestroyPipelineCache(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyPipelineCache(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkGetPipelineCacheData(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->read((size_t*)pDataSize, sizeof(size_t));
    vkStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    VkResult marshal_vkGetPipelineCacheData_VkResult_return;
    vkStream->read(&marshal_vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPipelineCacheData_VkResult_return;
}

VkResult unmarshal_vkGetPipelineCacheData(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->write((size_t*)pDataSize, sizeof(size_t));
    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    VkResult unmarshal_vkGetPipelineCacheData_VkResult_return;
    vkStream->write(&unmarshal_vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPipelineCacheData_VkResult_return;
}

VkResult marshal_vkMergePipelineCaches(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineCache*)&dstCache, sizeof(VkPipelineCache));
    vkStream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    vkStream->write((const VkPipelineCache*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    VkResult marshal_vkMergePipelineCaches_VkResult_return;
    vkStream->read(&marshal_vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    return marshal_vkMergePipelineCaches_VkResult_return;
}

VkResult unmarshal_vkMergePipelineCaches(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineCache*)&dstCache, sizeof(VkPipelineCache));
    vkStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    vkStream->read((VkPipelineCache*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    VkResult unmarshal_vkMergePipelineCaches_VkResult_return;
    vkStream->write(&unmarshal_vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    return unmarshal_vkMergePipelineCaches_VkResult_return;
}

void marshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    const VkSpecializationMapEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->constantID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    vkStream->write((size_t*)&forMarshaling->size, sizeof(size_t));
}

void unmarshal_VkSpecializationMapEntry(
    VulkanStream* vkStream,
    VkSpecializationMapEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->constantID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    vkStream->read((size_t*)&forUnmarshaling->size, sizeof(size_t));
}

void marshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    const VkSpecializationInfo* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->mapEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->mapEntryCount; ++i)
    {
        marshal_VkSpecializationMapEntry(vkStream, (const VkSpecializationMapEntry*)(forMarshaling->pMapEntries + i));
    }
    vkStream->write((size_t*)&forMarshaling->dataSize, sizeof(size_t));
    vkStream->write((const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
}

void unmarshal_VkSpecializationInfo(
    VulkanStream* vkStream,
    VkSpecializationInfo* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->mapEntryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pMapEntries, forUnmarshaling->mapEntryCount * sizeof(const VkSpecializationMapEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->mapEntryCount; ++i)
    {
        unmarshal_VkSpecializationMapEntry(vkStream, (VkSpecializationMapEntry*)(forUnmarshaling->pMapEntries + i));
    }
    vkStream->read((size_t*)&forUnmarshaling->dataSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
}

void marshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineShaderStageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineShaderStageCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->write((VkShaderStageFlagBits*)&forMarshaling->stage, sizeof(VkShaderStageFlagBits));
    vkStream->write((VkShaderModule*)&forMarshaling->module, sizeof(VkShaderModule));
    vkStream->putString(forMarshaling->pName);
    vkStream->write((const VkSpecializationInfo**)&forMarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo*));
    if (forMarshaling->pSpecializationInfo)
    {
        marshal_VkSpecializationInfo(vkStream, (const VkSpecializationInfo*)(forMarshaling->pSpecializationInfo));
    }
}

void unmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStream* vkStream,
    VkPipelineShaderStageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineShaderStageCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->read((VkShaderStageFlagBits*)&forUnmarshaling->stage, sizeof(VkShaderStageFlagBits));
    vkStream->read((VkShaderModule*)&forUnmarshaling->module, sizeof(VkShaderModule));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pName);
    vkStream->read((VkSpecializationInfo**)&forUnmarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo*));
    if (forUnmarshaling->pSpecializationInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSpecializationInfo, sizeof(const VkSpecializationInfo));
        unmarshal_VkSpecializationInfo(vkStream, (VkSpecializationInfo*)(forUnmarshaling->pSpecializationInfo));
    }
}

void marshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    const VkVertexInputBindingDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    vkStream->write((VkVertexInputRate*)&forMarshaling->inputRate, sizeof(VkVertexInputRate));
}

void unmarshal_VkVertexInputBindingDescription(
    VulkanStream* vkStream,
    VkVertexInputBindingDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->stride, sizeof(uint32_t));
    vkStream->read((VkVertexInputRate*)&forUnmarshaling->inputRate, sizeof(VkVertexInputRate));
}

void marshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    const VkVertexInputAttributeDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->location, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
}

void unmarshal_VkVertexInputAttributeDescription(
    VulkanStream* vkStream,
    VkVertexInputAttributeDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->location, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineVertexInputStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineVertexInputStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDescriptionCount; ++i)
    {
        marshal_VkVertexInputBindingDescription(vkStream, (const VkVertexInputBindingDescription*)(forMarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexAttributeDescriptionCount; ++i)
    {
        marshal_VkVertexInputAttributeDescription(vkStream, (const VkVertexInputAttributeDescription*)(forMarshaling->pVertexAttributeDescriptions + i));
    }
}

void unmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineVertexInputStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineVertexInputStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDescriptions, forUnmarshaling->vertexBindingDescriptionCount * sizeof(const VkVertexInputBindingDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputBindingDescription(vkStream, (VkVertexInputBindingDescription*)(forUnmarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexAttributeDescriptions, forUnmarshaling->vertexAttributeDescriptionCount * sizeof(const VkVertexInputAttributeDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexAttributeDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputAttributeDescription(vkStream, (VkVertexInputAttributeDescription*)(forUnmarshaling->pVertexAttributeDescriptions + i));
    }
}

void marshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineInputAssemblyStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineInputAssemblyStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->write((VkPrimitiveTopology*)&forMarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->write((VkBool32*)&forMarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineInputAssemblyStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineInputAssemblyStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->read((VkPrimitiveTopology*)&forUnmarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void marshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineTessellationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineTessellationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->patchControlPoints, sizeof(uint32_t));
}

void unmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineTessellationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->patchControlPoints, sizeof(uint32_t));
}

void marshal_VkViewport(
    VulkanStream* vkStream,
    const VkViewport* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
    vkStream->write((float*)&forMarshaling->width, sizeof(float));
    vkStream->write((float*)&forMarshaling->height, sizeof(float));
    vkStream->write((float*)&forMarshaling->minDepth, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepth, sizeof(float));
}

void unmarshal_VkViewport(
    VulkanStream* vkStream,
    VkViewport* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->width, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->height, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minDepth, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepth, sizeof(float));
}

void marshal_VkOffset2D(
    VulkanStream* vkStream,
    const VkOffset2D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
}

void unmarshal_VkOffset2D(
    VulkanStream* vkStream,
    VkOffset2D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
}

void marshal_VkExtent2D(
    VulkanStream* vkStream,
    const VkExtent2D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
}

void unmarshal_VkExtent2D(
    VulkanStream* vkStream,
    VkExtent2D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
}

void marshal_VkRect2D(
    VulkanStream* vkStream,
    const VkRect2D* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
}

void unmarshal_VkRect2D(
    VulkanStream* vkStream,
    VkRect2D* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
}

void marshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineViewportStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineViewportStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    vkStream->write((const VkViewport**)&forMarshaling->pViewports, sizeof(const VkViewport*));
    if (forMarshaling->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewport(vkStream, (const VkViewport*)(forMarshaling->pViewports + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->scissorCount, sizeof(uint32_t));
    vkStream->write((const VkRect2D**)&forMarshaling->pScissors, sizeof(const VkRect2D*));
    if (forMarshaling->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->scissorCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pScissors + i));
        }
    }
}

void unmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineViewportStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineViewportStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    vkStream->read((VkViewport**)&forUnmarshaling->pViewports, sizeof(const VkViewport*));
    if (forUnmarshaling->pViewports)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewports, forUnmarshaling->viewportCount * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewport(vkStream, (VkViewport*)(forUnmarshaling->pViewports + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->scissorCount, sizeof(uint32_t));
    vkStream->read((VkRect2D**)&forUnmarshaling->pScissors, sizeof(const VkRect2D*));
    if (forUnmarshaling->pScissors)
    {
        vkStream->alloc((void**)&forUnmarshaling->pScissors, forUnmarshaling->scissorCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->scissorCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pScissors + i));
        }
    }
}

void marshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineRasterizationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineRasterizationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->write((VkPolygonMode*)&forMarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->write((VkCullModeFlags*)&forMarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->write((VkFrontFace*)&forMarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasClamp, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidth, sizeof(float));
}

void unmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineRasterizationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->read((VkPolygonMode*)&forUnmarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->read((VkCullModeFlags*)&forUnmarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->read((VkFrontFace*)&forUnmarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasClamp, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidth, sizeof(float));
}

void marshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineMultisampleStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineMultisampleStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkBool32*)&forMarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->minSampleShading, sizeof(float));
    vkStream->write((const VkSampleMask**)&forMarshaling->pSampleMask, sizeof(const VkSampleMask*));
    if (forMarshaling->pSampleMask)
    {
        vkStream->write((const VkSampleMask*)forMarshaling->pSampleMask, (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->write((VkBool32*)&forMarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineMultisampleStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineMultisampleStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->minSampleShading, sizeof(float));
    vkStream->read((VkSampleMask**)&forUnmarshaling->pSampleMask, sizeof(const VkSampleMask*));
    if (forUnmarshaling->pSampleMask)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        vkStream->read((VkSampleMask*)forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void marshal_VkStencilOpState(
    VulkanStream* vkStream,
    const VkStencilOpState* forMarshaling)
{
    vkStream->write((VkStencilOp*)&forMarshaling->failOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->passOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((uint32_t*)&forMarshaling->compareMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->writeMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->reference, sizeof(uint32_t));
}

void unmarshal_VkStencilOpState(
    VulkanStream* vkStream,
    VkStencilOpState* forUnmarshaling)
{
    vkStream->read((VkStencilOp*)&forUnmarshaling->failOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->passOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((uint32_t*)&forUnmarshaling->compareMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->writeMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->reference, sizeof(uint32_t));
}

void marshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineDepthStencilStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineDepthStencilStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->write((VkBool32*)&forMarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stencilTestEnable, sizeof(VkBool32));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->front));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->back));
    vkStream->write((float*)&forMarshaling->minDepthBounds, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepthBounds, sizeof(float));
}

void unmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDepthStencilStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineDepthStencilStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stencilTestEnable, sizeof(VkBool32));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->front));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->back));
    vkStream->read((float*)&forUnmarshaling->minDepthBounds, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepthBounds, sizeof(float));
}

void marshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    const VkPipelineColorBlendAttachmentState* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->blendEnable, sizeof(VkBool32));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkColorComponentFlags*)&forMarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void unmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStream* vkStream,
    VkPipelineColorBlendAttachmentState* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->blendEnable, sizeof(VkBool32));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkColorComponentFlags*)&forUnmarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void marshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineColorBlendStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineColorBlendStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->write((VkLogicOp*)&forMarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkPipelineColorBlendAttachmentState(vkStream, (const VkPipelineColorBlendAttachmentState*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((float*)forMarshaling->blendConstants, 4 * sizeof(float));
}

void unmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineColorBlendStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineColorBlendStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->read((VkLogicOp*)&forUnmarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkPipelineColorBlendAttachmentState));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkPipelineColorBlendAttachmentState(vkStream, (VkPipelineColorBlendAttachmentState*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((float*)forUnmarshaling->blendConstants, 4 * sizeof(float));
}

void marshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineDynamicStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineDynamicStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->write((const VkDynamicState*)forMarshaling->pDynamicStates, forMarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void unmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineDynamicStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineDynamicStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    vkStream->read((VkDynamicState*)forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void marshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    const VkGraphicsPipelineCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    marshal_VkPipelineVertexInputStateCreateInfo(vkStream, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState));
    marshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (const VkPipelineInputAssemblyStateCreateInfo*)(forMarshaling->pInputAssemblyState));
    vkStream->write((const VkPipelineTessellationStateCreateInfo**)&forMarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo*));
    if (forMarshaling->pTessellationState)
    {
        marshal_VkPipelineTessellationStateCreateInfo(vkStream, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState));
    }
    vkStream->write((const VkPipelineViewportStateCreateInfo**)&forMarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo*));
    if (forMarshaling->pViewportState)
    {
        marshal_VkPipelineViewportStateCreateInfo(vkStream, (const VkPipelineViewportStateCreateInfo*)(forMarshaling->pViewportState));
    }
    marshal_VkPipelineRasterizationStateCreateInfo(vkStream, (const VkPipelineRasterizationStateCreateInfo*)(forMarshaling->pRasterizationState));
    vkStream->write((const VkPipelineMultisampleStateCreateInfo**)&forMarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo*));
    if (forMarshaling->pMultisampleState)
    {
        marshal_VkPipelineMultisampleStateCreateInfo(vkStream, (const VkPipelineMultisampleStateCreateInfo*)(forMarshaling->pMultisampleState));
    }
    vkStream->write((const VkPipelineDepthStencilStateCreateInfo**)&forMarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo*));
    if (forMarshaling->pDepthStencilState)
    {
        marshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (const VkPipelineDepthStencilStateCreateInfo*)(forMarshaling->pDepthStencilState));
    }
    vkStream->write((const VkPipelineColorBlendStateCreateInfo**)&forMarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo*));
    if (forMarshaling->pColorBlendState)
    {
        marshal_VkPipelineColorBlendStateCreateInfo(vkStream, (const VkPipelineColorBlendStateCreateInfo*)(forMarshaling->pColorBlendState));
    }
    vkStream->write((const VkPipelineDynamicStateCreateInfo**)&forMarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo*));
    if (forMarshaling->pDynamicState)
    {
        marshal_VkPipelineDynamicStateCreateInfo(vkStream, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState));
    }
    vkStream->write((VkPipelineLayout*)&forMarshaling->layout, sizeof(VkPipelineLayout));
    vkStream->write((VkRenderPass*)&forMarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    vkStream->write((VkPipeline*)&forMarshaling->basePipelineHandle, sizeof(VkPipeline));
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStream* vkStream,
    VkGraphicsPipelineCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pStages, forUnmarshaling->stageCount * sizeof(const VkPipelineShaderStageCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    vkStream->alloc((void**)&forUnmarshaling->pVertexInputState, sizeof(const VkPipelineVertexInputStateCreateInfo));
    unmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState));
    vkStream->alloc((void**)&forUnmarshaling->pInputAssemblyState, sizeof(const VkPipelineInputAssemblyStateCreateInfo));
    unmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (VkPipelineInputAssemblyStateCreateInfo*)(forUnmarshaling->pInputAssemblyState));
    vkStream->read((VkPipelineTessellationStateCreateInfo**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo*));
    if (forUnmarshaling->pTessellationState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTessellationState, sizeof(const VkPipelineTessellationStateCreateInfo));
        unmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState));
    }
    vkStream->read((VkPipelineViewportStateCreateInfo**)&forUnmarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo*));
    if (forUnmarshaling->pViewportState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportState, sizeof(const VkPipelineViewportStateCreateInfo));
        unmarshal_VkPipelineViewportStateCreateInfo(vkStream, (VkPipelineViewportStateCreateInfo*)(forUnmarshaling->pViewportState));
    }
    vkStream->alloc((void**)&forUnmarshaling->pRasterizationState, sizeof(const VkPipelineRasterizationStateCreateInfo));
    unmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, (VkPipelineRasterizationStateCreateInfo*)(forUnmarshaling->pRasterizationState));
    vkStream->read((VkPipelineMultisampleStateCreateInfo**)&forUnmarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo*));
    if (forUnmarshaling->pMultisampleState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pMultisampleState, sizeof(const VkPipelineMultisampleStateCreateInfo));
        unmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, (VkPipelineMultisampleStateCreateInfo*)(forUnmarshaling->pMultisampleState));
    }
    vkStream->read((VkPipelineDepthStencilStateCreateInfo**)&forUnmarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo*));
    if (forUnmarshaling->pDepthStencilState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilState, sizeof(const VkPipelineDepthStencilStateCreateInfo));
        unmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (VkPipelineDepthStencilStateCreateInfo*)(forUnmarshaling->pDepthStencilState));
    }
    vkStream->read((VkPipelineColorBlendStateCreateInfo**)&forUnmarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo*));
    if (forUnmarshaling->pColorBlendState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pColorBlendState, sizeof(const VkPipelineColorBlendStateCreateInfo));
        unmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, (VkPipelineColorBlendStateCreateInfo*)(forUnmarshaling->pColorBlendState));
    }
    vkStream->read((VkPipelineDynamicStateCreateInfo**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo*));
    if (forUnmarshaling->pDynamicState)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDynamicState, sizeof(const VkPipelineDynamicStateCreateInfo));
        unmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState));
    }
    vkStream->read((VkPipelineLayout*)&forUnmarshaling->layout, sizeof(VkPipelineLayout));
    vkStream->read((VkRenderPass*)&forUnmarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    vkStream->read((VkPipeline*)&forUnmarshaling->basePipelineHandle, sizeof(VkPipeline));
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

VkResult marshal_vkCreateGraphicsPipelines(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkGraphicsPipelineCreateInfo(vkStream, (const VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
    }
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult marshal_vkCreateGraphicsPipelines_VkResult_return;
    vkStream->read(&marshal_vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateGraphicsPipelines_VkResult_return;
}

VkResult unmarshal_vkCreateGraphicsPipelines(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        unmarshal_VkGraphicsPipelineCreateInfo(vkStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
    }
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult unmarshal_vkCreateGraphicsPipelines_VkResult_return;
    vkStream->write(&unmarshal_vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateGraphicsPipelines_VkResult_return;
}

void marshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    const VkComputePipelineCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    marshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forMarshaling->stage));
    vkStream->write((VkPipelineLayout*)&forMarshaling->layout, sizeof(VkPipelineLayout));
    vkStream->write((VkPipeline*)&forMarshaling->basePipelineHandle, sizeof(VkPipeline));
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkComputePipelineCreateInfo(
    VulkanStream* vkStream,
    VkComputePipelineCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forUnmarshaling->stage));
    vkStream->read((VkPipelineLayout*)&forUnmarshaling->layout, sizeof(VkPipelineLayout));
    vkStream->read((VkPipeline*)&forUnmarshaling->basePipelineHandle, sizeof(VkPipeline));
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

VkResult marshal_vkCreateComputePipelines(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkComputePipelineCreateInfo(vkStream, (const VkComputePipelineCreateInfo*)(pCreateInfos + i));
    }
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult marshal_vkCreateComputePipelines_VkResult_return;
    vkStream->read(&marshal_vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateComputePipelines_VkResult_return;
}

VkResult unmarshal_vkCreateComputePipelines(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    vkStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        unmarshal_VkComputePipelineCreateInfo(vkStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
    }
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult unmarshal_vkCreateComputePipelines_VkResult_return;
    vkStream->write(&unmarshal_vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateComputePipelines_VkResult_return;
}

void marshal_vkDestroyPipeline(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyPipeline(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkPushConstantRange(
    VulkanStream* vkStream,
    const VkPushConstantRange* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->size, sizeof(uint32_t));
}

void unmarshal_VkPushConstantRange(
    VulkanStream* vkStream,
    VkPushConstantRange* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->size, sizeof(uint32_t));
}

void marshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->setLayoutCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorSetLayout*)forMarshaling->pSetLayouts, forMarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    vkStream->write((uint32_t*)&forMarshaling->pushConstantRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pushConstantRangeCount; ++i)
    {
        marshal_VkPushConstantRange(vkStream, (const VkPushConstantRange*)(forMarshaling->pPushConstantRanges + i));
    }
}

void unmarshal_VkPipelineLayoutCreateInfo(
    VulkanStream* vkStream,
    VkPipelineLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->setLayoutCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    vkStream->read((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount * sizeof(const VkDescriptorSetLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->pushConstantRangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPushConstantRanges, forUnmarshaling->pushConstantRangeCount * sizeof(const VkPushConstantRange));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pushConstantRangeCount; ++i)
    {
        unmarshal_VkPushConstantRange(vkStream, (VkPushConstantRange*)(forUnmarshaling->pPushConstantRanges + i));
    }
}

VkResult marshal_vkCreatePipelineLayout(
    VulkanStream* vkStream,
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkPipelineLayoutCreateInfo(vkStream, (const VkPipelineLayoutCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
    VkResult marshal_vkCreatePipelineLayout_VkResult_return;
    vkStream->read(&marshal_vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    return marshal_vkCreatePipelineLayout_VkResult_return;
}

VkResult unmarshal_vkCreatePipelineLayout(
    VulkanStream* vkStream,
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
    unmarshal_VkPipelineLayoutCreateInfo(vkStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
    VkResult unmarshal_vkCreatePipelineLayout_VkResult_return;
    vkStream->write(&unmarshal_vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreatePipelineLayout_VkResult_return;
}

void marshal_vkDestroyPipelineLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipelineLayout*)&pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyPipelineLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipelineLayout*)&pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    const VkSamplerCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSamplerCreateFlags*)&forMarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->write((VkFilter*)&forMarshaling->magFilter, sizeof(VkFilter));
    vkStream->write((VkFilter*)&forMarshaling->minFilter, sizeof(VkFilter));
    vkStream->write((VkSamplerMipmapMode*)&forMarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->write((float*)&forMarshaling->mipLodBias, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->maxAnisotropy, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->compareEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((float*)&forMarshaling->minLod, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxLod, sizeof(float));
    vkStream->write((VkBorderColor*)&forMarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->write((VkBool32*)&forMarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

void unmarshal_VkSamplerCreateInfo(
    VulkanStream* vkStream,
    VkSamplerCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSamplerCreateFlags*)&forUnmarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->read((VkFilter*)&forUnmarshaling->magFilter, sizeof(VkFilter));
    vkStream->read((VkFilter*)&forUnmarshaling->minFilter, sizeof(VkFilter));
    vkStream->read((VkSamplerMipmapMode*)&forUnmarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->read((float*)&forUnmarshaling->mipLodBias, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->maxAnisotropy, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->compareEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((float*)&forUnmarshaling->minLod, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxLod, sizeof(float));
    vkStream->read((VkBorderColor*)&forUnmarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->read((VkBool32*)&forUnmarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

VkResult marshal_vkCreateSampler(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerCreateInfo(vkStream, (const VkSamplerCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSampler*)pSampler, sizeof(VkSampler));
    VkResult marshal_vkCreateSampler_VkResult_return;
    vkStream->read(&marshal_vkCreateSampler_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSampler_VkResult_return;
}

VkResult unmarshal_vkCreateSampler(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
    unmarshal_VkSamplerCreateInfo(vkStream, (VkSamplerCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSampler*)pSampler, sizeof(VkSampler));
    VkResult unmarshal_vkCreateSampler_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSampler_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSampler_VkResult_return;
}

void marshal_vkDestroySampler(
    VulkanStream* vkStream,
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSampler*)&sampler, sizeof(VkSampler));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySampler(
    VulkanStream* vkStream,
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSampler*)&sampler, sizeof(VkSampler));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutBinding* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((const VkSampler**)&forMarshaling->pImmutableSamplers, sizeof(const VkSampler*));
    if (forMarshaling->pImmutableSamplers)
    {
        vkStream->write((const VkSampler*)forMarshaling->pImmutableSamplers, forMarshaling->descriptorCount * sizeof(const VkSampler));
    }
}

void unmarshal_VkDescriptorSetLayoutBinding(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBinding* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((VkSampler**)&forUnmarshaling->pImmutableSamplers, sizeof(const VkSampler*));
    if (forUnmarshaling->pImmutableSamplers)
    {
        vkStream->alloc((void**)&forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount * sizeof(const VkSampler));
        vkStream->read((VkSampler*)forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount * sizeof(const VkSampler));
    }
}

void marshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDescriptorSetLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindingCount; ++i)
    {
        marshal_VkDescriptorSetLayoutBinding(vkStream, (const VkDescriptorSetLayoutBinding*)(forMarshaling->pBindings + i));
    }
}

void unmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDescriptorSetLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBindings, forUnmarshaling->bindingCount * sizeof(const VkDescriptorSetLayoutBinding));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindingCount; ++i)
    {
        unmarshal_VkDescriptorSetLayoutBinding(vkStream, (VkDescriptorSetLayoutBinding*)(forUnmarshaling->pBindings + i));
    }
}

VkResult marshal_vkCreateDescriptorSetLayout(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(vkStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
    VkResult marshal_vkCreateDescriptorSetLayout_VkResult_return;
    vkStream->read(&marshal_vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDescriptorSetLayout_VkResult_return;
}

VkResult unmarshal_vkCreateDescriptorSetLayout(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
    unmarshal_VkDescriptorSetLayoutCreateInfo(vkStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
    VkResult unmarshal_vkCreateDescriptorSetLayout_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDescriptorSetLayout_VkResult_return;
}

void marshal_vkDestroyDescriptorSetLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorSetLayout*)&descriptorSetLayout, sizeof(VkDescriptorSetLayout));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDescriptorSetLayout(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorSetLayout*)&descriptorSetLayout, sizeof(VkDescriptorSetLayout));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    const VkDescriptorPoolSize* forMarshaling)
{
    vkStream->write((VkDescriptorType*)&forMarshaling->type, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorPoolSize(
    VulkanStream* vkStream,
    VkDescriptorPoolSize* forUnmarshaling)
{
    vkStream->read((VkDescriptorType*)&forUnmarshaling->type, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDescriptorPoolCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->poolSizeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->poolSizeCount; ++i)
    {
        marshal_VkDescriptorPoolSize(vkStream, (const VkDescriptorPoolSize*)(forMarshaling->pPoolSizes + i));
    }
}

void unmarshal_VkDescriptorPoolCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDescriptorPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->poolSizeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPoolSizes, forUnmarshaling->poolSizeCount * sizeof(const VkDescriptorPoolSize));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->poolSizeCount; ++i)
    {
        unmarshal_VkDescriptorPoolSize(vkStream, (VkDescriptorPoolSize*)(forUnmarshaling->pPoolSizes + i));
    }
}

VkResult marshal_vkCreateDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorPoolCreateInfo(vkStream, (const VkDescriptorPoolCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
    VkResult marshal_vkCreateDescriptorPool_VkResult_return;
    vkStream->read(&marshal_vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDescriptorPool_VkResult_return;
}

VkResult unmarshal_vkCreateDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
    unmarshal_VkDescriptorPoolCreateInfo(vkStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
    VkResult unmarshal_vkCreateDescriptorPool_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDescriptorPool_VkResult_return;
}

void marshal_vkDestroyDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkResetDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->write((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
    VkResult marshal_vkResetDescriptorPool_VkResult_return;
    vkStream->read(&marshal_vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    return marshal_vkResetDescriptorPool_VkResult_return;
}

VkResult unmarshal_vkResetDescriptorPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->read((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
    VkResult unmarshal_vkResetDescriptorPool_VkResult_return;
    vkStream->write(&unmarshal_vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    return unmarshal_vkResetDescriptorPool_VkResult_return;
}

void marshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    const VkDescriptorSetAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDescriptorPool*)&forMarshaling->descriptorPool, sizeof(VkDescriptorPool));
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorSetLayout*)forMarshaling->pSetLayouts, forMarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
}

void unmarshal_VkDescriptorSetAllocateInfo(
    VulkanStream* vkStream,
    VkDescriptorSetAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDescriptorPool*)&forUnmarshaling->descriptorPool, sizeof(VkDescriptorPool));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
    vkStream->read((VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount * sizeof(const VkDescriptorSetLayout));
}

VkResult marshal_vkAllocateDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetAllocateInfo(vkStream, (const VkDescriptorSetAllocateInfo*)(pAllocateInfo));
    vkStream->read((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    VkResult marshal_vkAllocateDescriptorSets_VkResult_return;
    vkStream->read(&marshal_vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    return marshal_vkAllocateDescriptorSets_VkResult_return;
}

VkResult unmarshal_vkAllocateDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
    unmarshal_VkDescriptorSetAllocateInfo(vkStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
    vkStream->write((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    VkResult unmarshal_vkAllocateDescriptorSets_VkResult_return;
    vkStream->write(&unmarshal_vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAllocateDescriptorSets_VkResult_return;
}

VkResult marshal_vkFreeDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorSet**)&pDescriptorSets, sizeof(const VkDescriptorSet*));
    if (pDescriptorSets)
    {
        vkStream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    VkResult marshal_vkFreeDescriptorSets_VkResult_return;
    vkStream->read(&marshal_vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    return marshal_vkFreeDescriptorSets_VkResult_return;
}

VkResult unmarshal_vkFreeDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    vkStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorSet**)&pDescriptorSets, sizeof(const VkDescriptorSet*));
    if (pDescriptorSets)
    {
        vkStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
        vkStream->read((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    VkResult unmarshal_vkFreeDescriptorSets_VkResult_return;
    vkStream->write(&unmarshal_vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    return unmarshal_vkFreeDescriptorSets_VkResult_return;
}

void marshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    const VkDescriptorImageInfo* forMarshaling)
{
    vkStream->write((VkSampler*)&forMarshaling->sampler, sizeof(VkSampler));
    vkStream->write((VkImageView*)&forMarshaling->imageView, sizeof(VkImageView));
    vkStream->write((VkImageLayout*)&forMarshaling->imageLayout, sizeof(VkImageLayout));
}

void unmarshal_VkDescriptorImageInfo(
    VulkanStream* vkStream,
    VkDescriptorImageInfo* forUnmarshaling)
{
    vkStream->read((VkSampler*)&forUnmarshaling->sampler, sizeof(VkSampler));
    vkStream->read((VkImageView*)&forUnmarshaling->imageView, sizeof(VkImageView));
    vkStream->read((VkImageLayout*)&forUnmarshaling->imageLayout, sizeof(VkImageLayout));
}

void marshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    const VkDescriptorBufferInfo* forMarshaling)
{
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkDescriptorBufferInfo(
    VulkanStream* vkStream,
    VkDescriptorBufferInfo* forUnmarshaling)
{
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

void marshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    const VkWriteDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDescriptorSet*)&forMarshaling->dstSet, sizeof(VkDescriptorSet));
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->write((const VkDescriptorImageInfo**)&forMarshaling->pImageInfo, sizeof(const VkDescriptorImageInfo*));
    if (forMarshaling->pImageInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
        {
            marshal_VkDescriptorImageInfo(vkStream, (const VkDescriptorImageInfo*)(forMarshaling->pImageInfo + i));
        }
    }
    vkStream->write((const VkDescriptorBufferInfo**)&forMarshaling->pBufferInfo, sizeof(const VkDescriptorBufferInfo*));
    if (forMarshaling->pBufferInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
        {
            marshal_VkDescriptorBufferInfo(vkStream, (const VkDescriptorBufferInfo*)(forMarshaling->pBufferInfo + i));
        }
    }
    vkStream->write((const VkBufferView**)&forMarshaling->pTexelBufferView, sizeof(const VkBufferView*));
    if (forMarshaling->pTexelBufferView)
    {
        vkStream->write((const VkBufferView*)forMarshaling->pTexelBufferView, forMarshaling->descriptorCount * sizeof(const VkBufferView));
    }
}

void unmarshal_VkWriteDescriptorSet(
    VulkanStream* vkStream,
    VkWriteDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDescriptorSet*)&forUnmarshaling->dstSet, sizeof(VkDescriptorSet));
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->read((VkDescriptorImageInfo**)&forUnmarshaling->pImageInfo, sizeof(const VkDescriptorImageInfo*));
    if (forUnmarshaling->pImageInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pImageInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorImageInfo));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
        {
            unmarshal_VkDescriptorImageInfo(vkStream, (VkDescriptorImageInfo*)(forUnmarshaling->pImageInfo + i));
        }
    }
    vkStream->read((VkDescriptorBufferInfo**)&forUnmarshaling->pBufferInfo, sizeof(const VkDescriptorBufferInfo*));
    if (forUnmarshaling->pBufferInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pBufferInfo, forUnmarshaling->descriptorCount * sizeof(const VkDescriptorBufferInfo));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
        {
            unmarshal_VkDescriptorBufferInfo(vkStream, (VkDescriptorBufferInfo*)(forUnmarshaling->pBufferInfo + i));
        }
    }
    vkStream->read((VkBufferView**)&forUnmarshaling->pTexelBufferView, sizeof(const VkBufferView*));
    if (forUnmarshaling->pTexelBufferView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount * sizeof(const VkBufferView));
        vkStream->read((VkBufferView*)forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount * sizeof(const VkBufferView));
    }
}

void marshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    const VkCopyDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDescriptorSet*)&forMarshaling->srcSet, sizeof(VkDescriptorSet));
    vkStream->write((uint32_t*)&forMarshaling->srcBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->srcArrayElement, sizeof(uint32_t));
    vkStream->write((VkDescriptorSet*)&forMarshaling->dstSet, sizeof(VkDescriptorSet));
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkCopyDescriptorSet(
    VulkanStream* vkStream,
    VkCopyDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDescriptorSet*)&forUnmarshaling->srcSet, sizeof(VkDescriptorSet));
    vkStream->read((uint32_t*)&forUnmarshaling->srcBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->srcArrayElement, sizeof(uint32_t));
    vkStream->read((VkDescriptorSet*)&forUnmarshaling->dstSet, sizeof(VkDescriptorSet));
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_vkUpdateDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(vkStream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
    vkStream->write((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        marshal_VkCopyDescriptorSet(vkStream, (const VkCopyDescriptorSet*)(pDescriptorCopies + i));
    }
}

void unmarshal_vkUpdateDescriptorSets(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        unmarshal_VkWriteDescriptorSet(vkStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
    vkStream->read((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        unmarshal_VkCopyDescriptorSet(vkStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
    }
}

void marshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    const VkFramebufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFramebufferCreateFlags*)&forMarshaling->flags, sizeof(VkFramebufferCreateFlags));
    vkStream->write((VkRenderPass*)&forMarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->write((const VkImageView*)forMarshaling->pAttachments, forMarshaling->attachmentCount * sizeof(const VkImageView));
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layers, sizeof(uint32_t));
}

void unmarshal_VkFramebufferCreateInfo(
    VulkanStream* vkStream,
    VkFramebufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFramebufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkFramebufferCreateFlags));
    vkStream->read((VkRenderPass*)&forUnmarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    vkStream->read((VkImageView*)forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkImageView));
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layers, sizeof(uint32_t));
}

VkResult marshal_vkCreateFramebuffer(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFramebufferCreateInfo(vkStream, (const VkFramebufferCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
    VkResult marshal_vkCreateFramebuffer_VkResult_return;
    vkStream->read(&marshal_vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateFramebuffer_VkResult_return;
}

VkResult unmarshal_vkCreateFramebuffer(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
    unmarshal_VkFramebufferCreateInfo(vkStream, (VkFramebufferCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
    VkResult unmarshal_vkCreateFramebuffer_VkResult_return;
    vkStream->write(&unmarshal_vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateFramebuffer_VkResult_return;
}

void marshal_vkDestroyFramebuffer(
    VulkanStream* vkStream,
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkFramebuffer*)&framebuffer, sizeof(VkFramebuffer));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyFramebuffer(
    VulkanStream* vkStream,
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkFramebuffer*)&framebuffer, sizeof(VkFramebuffer));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    const VkAttachmentDescription* forMarshaling)
{
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription(
    VulkanStream* vkStream,
    VkAttachmentDescription* forUnmarshaling)
{
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference(
    VulkanStream* vkStream,
    const VkAttachmentReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentReference(
    VulkanStream* vkStream,
    VkAttachmentReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
}

void marshal_VkSubpassDescription(
    VulkanStream* vkStream,
    const VkSubpassDescription* forMarshaling)
{
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pColorAttachments + i));
    }
    vkStream->write((const VkAttachmentReference**)&forMarshaling->pResolveAttachments, sizeof(const VkAttachmentReference*));
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pResolveAttachments + i));
        }
    }
    vkStream->write((const VkAttachmentReference**)&forMarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference*));
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription(
    VulkanStream* vkStream,
    VkSubpassDescription* forUnmarshaling)
{
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pColorAttachments + i));
    }
    vkStream->read((VkAttachmentReference**)&forUnmarshaling->pResolveAttachments, sizeof(const VkAttachmentReference*));
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    vkStream->read((VkAttachmentReference**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference*));
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference));
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency(
    VulkanStream* vkStream,
    const VkSubpassDependency* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void unmarshal_VkSubpassDependency(
    VulkanStream* vkStream,
    VkSubpassDependency* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void marshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription(vkStream, (const VkAttachmentDescription*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription(vkStream, (const VkSubpassDescription*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency(vkStream, (const VkSubpassDependency*)(forMarshaling->pDependencies + i));
    }
}

void unmarshal_VkRenderPassCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription(vkStream, (VkAttachmentDescription*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription(vkStream, (VkSubpassDescription*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency(vkStream, (VkSubpassDependency*)(forUnmarshaling->pDependencies + i));
    }
}

VkResult marshal_vkCreateRenderPass(
    VulkanStream* vkStream,
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkRenderPassCreateInfo(vkStream, (const VkRenderPassCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult marshal_vkCreateRenderPass_VkResult_return;
    vkStream->read(&marshal_vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateRenderPass_VkResult_return;
}

VkResult unmarshal_vkCreateRenderPass(
    VulkanStream* vkStream,
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
    unmarshal_VkRenderPassCreateInfo(vkStream, (VkRenderPassCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult unmarshal_vkCreateRenderPass_VkResult_return;
    vkStream->write(&unmarshal_vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateRenderPass_VkResult_return;
}

void marshal_vkDestroyRenderPass(
    VulkanStream* vkStream,
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyRenderPass(
    VulkanStream* vkStream,
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_vkGetRenderAreaGranularity(
    VulkanStream* vkStream,
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
}

void unmarshal_vkGetRenderAreaGranularity(
    VulkanStream* vkStream,
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
}

void marshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    const VkCommandPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkCommandPoolCreateFlags*)&forMarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
}

void unmarshal_VkCommandPoolCreateInfo(
    VulkanStream* vkStream,
    VkCommandPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkCommandPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
}

VkResult marshal_vkCreateCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkCommandPoolCreateInfo(vkStream, (const VkCommandPoolCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
    VkResult marshal_vkCreateCommandPool_VkResult_return;
    vkStream->read(&marshal_vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateCommandPool_VkResult_return;
}

VkResult unmarshal_vkCreateCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
    unmarshal_VkCommandPoolCreateInfo(vkStream, (VkCommandPoolCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
    VkResult unmarshal_vkCreateCommandPool_VkResult_return;
    vkStream->write(&unmarshal_vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateCommandPool_VkResult_return;
}

void marshal_vkDestroyCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkResetCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->write((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
    VkResult marshal_vkResetCommandPool_VkResult_return;
    vkStream->read(&marshal_vkResetCommandPool_VkResult_return, sizeof(VkResult));
    return marshal_vkResetCommandPool_VkResult_return;
}

VkResult unmarshal_vkResetCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->read((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
    VkResult unmarshal_vkResetCommandPool_VkResult_return;
    vkStream->write(&unmarshal_vkResetCommandPool_VkResult_return, sizeof(VkResult));
    return unmarshal_vkResetCommandPool_VkResult_return;
}

void marshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    const VkCommandBufferAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkCommandPool*)&forMarshaling->commandPool, sizeof(VkCommandPool));
    vkStream->write((VkCommandBufferLevel*)&forMarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
}

void unmarshal_VkCommandBufferAllocateInfo(
    VulkanStream* vkStream,
    VkCommandBufferAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkCommandPool*)&forUnmarshaling->commandPool, sizeof(VkCommandPool));
    vkStream->read((VkCommandBufferLevel*)&forUnmarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
}

VkResult marshal_vkAllocateCommandBuffers(
    VulkanStream* vkStream,
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkCommandBufferAllocateInfo(vkStream, (const VkCommandBufferAllocateInfo*)(pAllocateInfo));
    vkStream->read((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
    VkResult marshal_vkAllocateCommandBuffers_VkResult_return;
    vkStream->read(&marshal_vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    return marshal_vkAllocateCommandBuffers_VkResult_return;
}

VkResult unmarshal_vkAllocateCommandBuffers(
    VulkanStream* vkStream,
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
    unmarshal_VkCommandBufferAllocateInfo(vkStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
    vkStream->write((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
    VkResult unmarshal_vkAllocateCommandBuffers_VkResult_return;
    vkStream->write(&unmarshal_vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAllocateCommandBuffers_VkResult_return;
}

void marshal_vkFreeCommandBuffers(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    vkStream->write((const VkCommandBuffer**)&pCommandBuffers, sizeof(const VkCommandBuffer*));
    if (pCommandBuffers)
    {
        vkStream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
}

void unmarshal_vkFreeCommandBuffers(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    vkStream->read((VkCommandBuffer**)&pCommandBuffers, sizeof(const VkCommandBuffer*));
    if (pCommandBuffers)
    {
        vkStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
        vkStream->read((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
}

void marshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    const VkCommandBufferInheritanceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkRenderPass*)&forMarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    vkStream->write((VkFramebuffer*)&forMarshaling->framebuffer, sizeof(VkFramebuffer));
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->write((VkQueryControlFlags*)&forMarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkCommandBufferInheritanceInfo(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkRenderPass*)&forUnmarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    vkStream->read((VkFramebuffer*)&forUnmarshaling->framebuffer, sizeof(VkFramebuffer));
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->read((VkQueryControlFlags*)&forUnmarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void marshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    const VkCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkCommandBufferUsageFlags*)&forMarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    vkStream->write((const VkCommandBufferInheritanceInfo**)&forMarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo*));
    if (forMarshaling->pInheritanceInfo)
    {
        marshal_VkCommandBufferInheritanceInfo(vkStream, (const VkCommandBufferInheritanceInfo*)(forMarshaling->pInheritanceInfo));
    }
}

void unmarshal_VkCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkCommandBufferUsageFlags*)&forUnmarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    vkStream->read((VkCommandBufferInheritanceInfo**)&forUnmarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo*));
    if (forUnmarshaling->pInheritanceInfo)
    {
        vkStream->alloc((void**)&forUnmarshaling->pInheritanceInfo, sizeof(const VkCommandBufferInheritanceInfo));
        unmarshal_VkCommandBufferInheritanceInfo(vkStream, (VkCommandBufferInheritanceInfo*)(forUnmarshaling->pInheritanceInfo));
    }
}

VkResult marshal_vkBeginCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCommandBufferBeginInfo(vkStream, (const VkCommandBufferBeginInfo*)(pBeginInfo));
    VkResult marshal_vkBeginCommandBuffer_VkResult_return;
    vkStream->read(&marshal_vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    return marshal_vkBeginCommandBuffer_VkResult_return;
}

VkResult unmarshal_vkBeginCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
    unmarshal_VkCommandBufferBeginInfo(vkStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
    VkResult unmarshal_vkBeginCommandBuffer_VkResult_return;
    vkStream->write(&unmarshal_vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBeginCommandBuffer_VkResult_return;
}

VkResult marshal_vkEndCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    VkResult marshal_vkEndCommandBuffer_VkResult_return;
    vkStream->read(&marshal_vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    return marshal_vkEndCommandBuffer_VkResult_return;
}

VkResult unmarshal_vkEndCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    VkResult unmarshal_vkEndCommandBuffer_VkResult_return;
    vkStream->write(&unmarshal_vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEndCommandBuffer_VkResult_return;
}

VkResult marshal_vkResetCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
    VkResult marshal_vkResetCommandBuffer_VkResult_return;
    vkStream->read(&marshal_vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    return marshal_vkResetCommandBuffer_VkResult_return;
}

VkResult unmarshal_vkResetCommandBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
    VkResult unmarshal_vkResetCommandBuffer_VkResult_return;
    vkStream->write(&unmarshal_vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    return unmarshal_vkResetCommandBuffer_VkResult_return;
}

void marshal_vkCmdBindPipeline(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
}

void unmarshal_vkCmdBindPipeline(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
}

void marshal_vkCmdSetViewport(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
    vkStream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewport(vkStream, (const VkViewport*)(pViewports + i));
    }
}

void unmarshal_vkCmdSetViewport(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
    vkStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        unmarshal_VkViewport(vkStream, (VkViewport*)(pViewports + i));
    }
}

void marshal_vkCmdSetScissor(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&firstScissor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&scissorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(pScissors + i));
    }
}

void unmarshal_vkCmdSetScissor(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&firstScissor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&scissorCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(pScissors + i));
    }
}

void marshal_vkCmdSetLineWidth(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((float*)&lineWidth, sizeof(float));
}

void unmarshal_vkCmdSetLineWidth(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((float*)&lineWidth, sizeof(float));
}

void marshal_vkCmdSetDepthBias(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((float*)&depthBiasConstantFactor, sizeof(float));
    vkStream->write((float*)&depthBiasClamp, sizeof(float));
    vkStream->write((float*)&depthBiasSlopeFactor, sizeof(float));
}

void unmarshal_vkCmdSetDepthBias(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((float*)&depthBiasConstantFactor, sizeof(float));
    vkStream->read((float*)&depthBiasClamp, sizeof(float));
    vkStream->read((float*)&depthBiasSlopeFactor, sizeof(float));
}

void marshal_vkCmdSetBlendConstants(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const float blendConstants)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((const float*)&blendConstants, 4 * sizeof(const float));
}

void unmarshal_vkCmdSetBlendConstants(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const float blendConstants)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((float*)&blendConstants, 4 * sizeof(const float));
}

void marshal_vkCmdSetDepthBounds(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((float*)&minDepthBounds, sizeof(float));
    vkStream->write((float*)&maxDepthBounds, sizeof(float));
}

void unmarshal_vkCmdSetDepthBounds(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((float*)&minDepthBounds, sizeof(float));
    vkStream->read((float*)&maxDepthBounds, sizeof(float));
}

void marshal_vkCmdSetStencilCompareMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->write((uint32_t*)&compareMask, sizeof(uint32_t));
}

void unmarshal_vkCmdSetStencilCompareMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->read((uint32_t*)&compareMask, sizeof(uint32_t));
}

void marshal_vkCmdSetStencilWriteMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->write((uint32_t*)&writeMask, sizeof(uint32_t));
}

void unmarshal_vkCmdSetStencilWriteMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->read((uint32_t*)&writeMask, sizeof(uint32_t));
}

void marshal_vkCmdSetStencilReference(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->write((uint32_t*)&reference, sizeof(uint32_t));
}

void unmarshal_vkCmdSetStencilReference(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    vkStream->read((uint32_t*)&reference, sizeof(uint32_t));
}

void marshal_vkCmdBindDescriptorSets(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->write((uint32_t*)&firstSet, sizeof(uint32_t));
    vkStream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    vkStream->write((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
}

void unmarshal_vkCmdBindDescriptorSets(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->read((uint32_t*)&firstSet, sizeof(uint32_t));
    vkStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    vkStream->read((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    vkStream->read((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
    vkStream->read((uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
}

void marshal_vkCmdBindIndexBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkIndexType*)&indexType, sizeof(VkIndexType));
}

void unmarshal_vkCmdBindIndexBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkIndexType*)&indexType, sizeof(VkIndexType));
}

void marshal_vkCmdBindVertexBuffers(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&firstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&bindingCount, sizeof(uint32_t));
    vkStream->write((const VkBuffer*)pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    vkStream->write((const VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
}

void unmarshal_vkCmdBindVertexBuffers(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&firstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&bindingCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    vkStream->read((VkBuffer*)pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    vkStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
    vkStream->read((VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
}

void marshal_vkCmdDraw(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&vertexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&firstVertex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void unmarshal_vkCmdDraw(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&vertexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&firstVertex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void marshal_vkCmdDrawIndexed(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&indexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&firstIndex, sizeof(uint32_t));
    vkStream->write((int32_t*)&vertexOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndexed(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&indexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&firstIndex, sizeof(uint32_t));
    vkStream->read((int32_t*)&vertexOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void marshal_vkCmdDrawIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&drawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

void marshal_vkCmdDrawIndexedIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&drawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndexedIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

void marshal_vkCmdDispatch(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void unmarshal_vkCmdDispatch(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void marshal_vkCmdDispatchIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
}

void unmarshal_vkCmdDispatchIndirect(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
}

void marshal_VkBufferCopy(
    VulkanStream* vkStream,
    const VkBufferCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferCopy(
    VulkanStream* vkStream,
    VkBufferCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_vkCmdCopyBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferCopy(vkStream, (const VkBufferCopy*)(pRegions + i));
    }
}

void unmarshal_vkCmdCopyBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkBufferCopy(vkStream, (VkBufferCopy*)(pRegions + i));
    }
}

void marshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    const VkImageSubresourceLayers* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceLayers(
    VulkanStream* vkStream,
    VkImageSubresourceLayers* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageCopy(
    VulkanStream* vkStream,
    const VkImageCopy* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageCopy(
    VulkanStream* vkStream,
    VkImageCopy* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_vkCmdCopyImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->write((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageCopy(vkStream, (const VkImageCopy*)(pRegions + i));
    }
}

void unmarshal_vkCmdCopyImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->read((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkImageCopy(vkStream, (VkImageCopy*)(pRegions + i));
    }
}

void marshal_VkImageBlit(
    VulkanStream* vkStream,
    const VkImageBlit* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->srcOffsets + i));
    }
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->dstOffsets + i));
    }
}

void unmarshal_VkImageBlit(
    VulkanStream* vkStream,
    VkImageBlit* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->srcOffsets + i));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->dstOffsets + i));
    }
}

void marshal_vkCmdBlitImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->write((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageBlit(vkStream, (const VkImageBlit*)(pRegions + i));
    }
    vkStream->write((VkFilter*)&filter, sizeof(VkFilter));
}

void unmarshal_vkCmdBlitImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->read((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkImageBlit(vkStream, (VkImageBlit*)(pRegions + i));
    }
    vkStream->read((VkFilter*)&filter, sizeof(VkFilter));
}

void marshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    const VkBufferImageCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->imageOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkBufferImageCopy(
    VulkanStream* vkStream,
    VkBufferImageCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferImageHeight, sizeof(uint32_t));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->imageOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageExtent));
}

void marshal_vkCmdCopyBufferToImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    vkStream->write((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(vkStream, (const VkBufferImageCopy*)(pRegions + i));
    }
}

void unmarshal_vkCmdCopyBufferToImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    vkStream->read((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkBufferImageCopy(vkStream, (VkBufferImageCopy*)(pRegions + i));
    }
}

void marshal_vkCmdCopyImageToBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(vkStream, (const VkBufferImageCopy*)(pRegions + i));
    }
}

void unmarshal_vkCmdCopyImageToBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkBufferImageCopy(vkStream, (VkBufferImageCopy*)(pRegions + i));
    }
}

void marshal_vkCmdUpdateBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
    vkStream->write((const void*)pData, ((dataSize)) * sizeof(const uint8_t));
}

void unmarshal_vkCmdUpdateBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
    vkStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
    vkStream->read((void*)pData, ((dataSize)) * sizeof(const uint8_t));
}

void marshal_vkCmdFillBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&data, sizeof(uint32_t));
}

void unmarshal_vkCmdFillBuffer(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&data, sizeof(uint32_t));
}

void marshal_VkClearColorValue(
    VulkanStream* vkStream,
    const VkClearColorValue* forMarshaling)
{
    vkStream->write((float*)forMarshaling->float32, 4 * sizeof(float));
    vkStream->write((int32_t*)forMarshaling->int32, 4 * sizeof(int32_t));
    vkStream->write((uint32_t*)forMarshaling->uint32, 4 * sizeof(uint32_t));
}

void unmarshal_VkClearColorValue(
    VulkanStream* vkStream,
    VkClearColorValue* forUnmarshaling)
{
    vkStream->read((float*)forUnmarshaling->float32, 4 * sizeof(float));
    vkStream->read((int32_t*)forUnmarshaling->int32, 4 * sizeof(int32_t));
    vkStream->read((uint32_t*)forUnmarshaling->uint32, 4 * sizeof(uint32_t));
}

void marshal_vkCmdClearColorImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    marshal_VkClearColorValue(vkStream, (const VkClearColorValue*)(pColor));
    vkStream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(vkStream, (const VkImageSubresourceRange*)(pRanges + i));
    }
}

void unmarshal_vkCmdClearColorImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    vkStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
    unmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(pColor));
    vkStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(pRanges + i));
    }
}

void marshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    const VkClearDepthStencilValue* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->depth, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->stencil, sizeof(uint32_t));
}

void unmarshal_VkClearDepthStencilValue(
    VulkanStream* vkStream,
    VkClearDepthStencilValue* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->depth, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->stencil, sizeof(uint32_t));
}

void marshal_vkCmdClearDepthStencilImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&image, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    marshal_VkClearDepthStencilValue(vkStream, (const VkClearDepthStencilValue*)(pDepthStencil));
    vkStream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(vkStream, (const VkImageSubresourceRange*)(pRanges + i));
    }
}

void unmarshal_vkCmdClearDepthStencilImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&image, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    vkStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
    unmarshal_VkClearDepthStencilValue(vkStream, (VkClearDepthStencilValue*)(pDepthStencil));
    vkStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(pRanges + i));
    }
}

void marshal_VkClearValue(
    VulkanStream* vkStream,
    const VkClearValue* forMarshaling)
{
    marshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forMarshaling->color));
    marshal_VkClearDepthStencilValue(vkStream, (VkClearDepthStencilValue*)(&forMarshaling->depthStencil));
}

void unmarshal_VkClearValue(
    VulkanStream* vkStream,
    VkClearValue* forUnmarshaling)
{
    unmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forUnmarshaling->color));
    unmarshal_VkClearDepthStencilValue(vkStream, (VkClearDepthStencilValue*)(&forUnmarshaling->depthStencil));
}

void marshal_VkClearAttachment(
    VulkanStream* vkStream,
    const VkClearAttachment* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->colorAttachment, sizeof(uint32_t));
    marshal_VkClearValue(vkStream, (VkClearValue*)(&forMarshaling->clearValue));
}

void unmarshal_VkClearAttachment(
    VulkanStream* vkStream,
    VkClearAttachment* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachment, sizeof(uint32_t));
    unmarshal_VkClearValue(vkStream, (VkClearValue*)(&forUnmarshaling->clearValue));
}

void marshal_VkClearRect(
    VulkanStream* vkStream,
    const VkClearRect* forMarshaling)
{
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->rect));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkClearRect(
    VulkanStream* vkStream,
    VkClearRect* forUnmarshaling)
{
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->rect));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_vkCmdClearAttachments(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        marshal_VkClearAttachment(vkStream, (const VkClearAttachment*)(pAttachments + i));
    }
    vkStream->write((uint32_t*)&rectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        marshal_VkClearRect(vkStream, (const VkClearRect*)(pRects + i));
    }
}

void unmarshal_vkCmdClearAttachments(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        unmarshal_VkClearAttachment(vkStream, (VkClearAttachment*)(pAttachments + i));
    }
    vkStream->read((uint32_t*)&rectCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        unmarshal_VkClearRect(vkStream, (VkClearRect*)(pRects + i));
    }
}

void marshal_VkImageResolve(
    VulkanStream* vkStream,
    const VkImageResolve* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageResolve(
    VulkanStream* vkStream,
    VkImageResolve* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_vkCmdResolveImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->write((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageResolve(vkStream, (const VkImageResolve*)(pRegions + i));
    }
}

void unmarshal_vkCmdResolveImage(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkImage*)&srcImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    vkStream->read((VkImage*)&dstImage, sizeof(VkImage));
    vkStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        unmarshal_VkImageResolve(vkStream, (VkImageResolve*)(pRegions + i));
    }
}

void marshal_vkCmdSetEvent(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    vkStream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void unmarshal_vkCmdSetEvent(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    vkStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void marshal_vkCmdResetEvent(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkEvent*)&event, sizeof(VkEvent));
    vkStream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void unmarshal_vkCmdResetEvent(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkEvent*)&event, sizeof(VkEvent));
    vkStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void marshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    const VkMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void unmarshal_VkMemoryBarrier(
    VulkanStream* vkStream,
    VkMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void marshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    const VkBufferMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferMemoryBarrier(
    VulkanStream* vkStream,
    VkBufferMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    const VkImageMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkImageLayout*)&forMarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageMemoryBarrier(
    VulkanStream* vkStream,
    VkImageMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkImageLayout*)&forUnmarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

void marshal_vkCmdWaitEvents(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&eventCount, sizeof(uint32_t));
    vkStream->write((const VkEvent*)pEvents, ((eventCount)) * sizeof(const VkEvent));
    vkStream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(vkStream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    vkStream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(vkStream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    vkStream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(vkStream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void unmarshal_vkCmdWaitEvents(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&eventCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
    vkStream->read((VkEvent*)pEvents, ((eventCount)) * sizeof(const VkEvent));
    vkStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        unmarshal_VkMemoryBarrier(vkStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    vkStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        unmarshal_VkBufferMemoryBarrier(vkStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    vkStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        unmarshal_VkImageMemoryBarrier(vkStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void marshal_vkCmdPipelineBarrier(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(vkStream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    vkStream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(vkStream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    vkStream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(vkStream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void unmarshal_vkCmdPipelineBarrier(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        unmarshal_VkMemoryBarrier(vkStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    vkStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        unmarshal_VkBufferMemoryBarrier(vkStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    vkStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        unmarshal_VkImageMemoryBarrier(vkStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void marshal_vkCmdBeginQuery(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&query, sizeof(uint32_t));
    vkStream->write((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
}

void unmarshal_vkCmdBeginQuery(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&query, sizeof(uint32_t));
    vkStream->read((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
}

void marshal_vkCmdEndQuery(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&query, sizeof(uint32_t));
}

void unmarshal_vkCmdEndQuery(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&query, sizeof(uint32_t));
}

void marshal_vkCmdResetQueryPool(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
}

void unmarshal_vkCmdResetQueryPool(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
}

void marshal_vkCmdWriteTimestamp(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&query, sizeof(uint32_t));
}

void unmarshal_vkCmdWriteTimestamp(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&query, sizeof(uint32_t));
}

void marshal_vkCmdCopyQueryPoolResults(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    vkStream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
}

void unmarshal_vkCmdCopyQueryPoolResults(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    vkStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
    vkStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    vkStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
}

void marshal_vkCmdPushConstants(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->write((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((uint32_t*)&offset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&size, sizeof(uint32_t));
    vkStream->write((const void*)pValues, ((size)) * sizeof(const uint8_t));
}

void unmarshal_vkCmdPushConstants(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->read((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((uint32_t*)&offset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&size, sizeof(uint32_t));
    vkStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
    vkStream->read((void*)pValues, ((size)) * sizeof(const uint8_t));
}

void marshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    const VkRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkRenderPass*)&forMarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->write((VkFramebuffer*)&forMarshaling->framebuffer, sizeof(VkFramebuffer));
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->renderArea));
    vkStream->write((uint32_t*)&forMarshaling->clearValueCount, sizeof(uint32_t));
    vkStream->write((const VkClearValue**)&forMarshaling->pClearValues, sizeof(const VkClearValue*));
    if (forMarshaling->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->clearValueCount; ++i)
        {
            marshal_VkClearValue(vkStream, (const VkClearValue*)(forMarshaling->pClearValues + i));
        }
    }
}

void unmarshal_VkRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkRenderPass*)&forUnmarshaling->renderPass, sizeof(VkRenderPass));
    vkStream->read((VkFramebuffer*)&forUnmarshaling->framebuffer, sizeof(VkFramebuffer));
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->renderArea));
    vkStream->read((uint32_t*)&forUnmarshaling->clearValueCount, sizeof(uint32_t));
    vkStream->read((VkClearValue**)&forUnmarshaling->pClearValues, sizeof(const VkClearValue*));
    if (forUnmarshaling->pClearValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pClearValues, forUnmarshaling->clearValueCount * sizeof(const VkClearValue));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->clearValueCount; ++i)
        {
            unmarshal_VkClearValue(vkStream, (VkClearValue*)(forUnmarshaling->pClearValues + i));
        }
    }
}

void marshal_vkCmdBeginRenderPass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkRenderPassBeginInfo(vkStream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
    vkStream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void unmarshal_vkCmdBeginRenderPass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
    unmarshal_VkRenderPassBeginInfo(vkStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
    vkStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void marshal_vkCmdNextSubpass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void unmarshal_vkCmdNextSubpass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void marshal_vkCmdEndRenderPass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void unmarshal_vkCmdEndRenderPass(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void marshal_vkCmdExecuteCommands(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    vkStream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
}

void unmarshal_vkCmdExecuteCommands(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    vkStream->read((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
}

void marshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    const VkDispatchIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->x, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->y, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->z, sizeof(uint32_t));
}

void unmarshal_VkDispatchIndirectCommand(
    VulkanStream* vkStream,
    VkDispatchIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->x, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->y, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->z, sizeof(uint32_t));
}

void marshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    const VkDrawIndexedIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstIndex, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->vertexOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndexedIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndexedIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->indexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstIndex, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->vertexOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    const VkDrawIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndirectCommand(
    VulkanStream* vkStream,
    VkDrawIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->vertexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstVertex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    const VkBaseOutStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((VkBaseOutStructure**)&forMarshaling->pNext, sizeof(VkBaseOutStructure*));
    // TODO: Unsupported : VkBaseOutStructure* pNext
}

void unmarshal_VkBaseOutStructure(
    VulkanStream* vkStream,
    VkBaseOutStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((VkBaseOutStructure**)&forUnmarshaling->pNext, sizeof(VkBaseOutStructure*));
    // TODO: Unsupported : VkBaseOutStructure* pNext
}

void marshal_VkBaseInStructure(
    VulkanStream* vkStream,
    const VkBaseInStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const VkBaseInStructure**)&forMarshaling->pNext, sizeof(const VkBaseInStructure*));
    // TODO: Unsupported : const VkBaseInStructure* pNext
}

void unmarshal_VkBaseInStructure(
    VulkanStream* vkStream,
    VkBaseInStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((VkBaseInStructure**)&forUnmarshaling->pNext, sizeof(const VkBaseInStructure*));
    // TODO: Unsupported : const VkBaseInStructure* pNext
}

#endif
#ifdef VK_VERSION_1_1
VkResult marshal_vkEnumerateInstanceVersion(
    VulkanStream* vkStream,
    uint32_t* pApiVersion)
{
    vkStream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
    VkResult marshal_vkEnumerateInstanceVersion_VkResult_return;
    vkStream->read(&marshal_vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumerateInstanceVersion_VkResult_return;
}

VkResult unmarshal_vkEnumerateInstanceVersion(
    VulkanStream* vkStream,
    uint32_t* pApiVersion)
{
    vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
    VkResult unmarshal_vkEnumerateInstanceVersion_VkResult_return;
    vkStream->write(&unmarshal_vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumerateInstanceVersion_VkResult_return;
}

void marshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSubgroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->write((VkSubgroupFeatureFlags*)&forMarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->write((VkBool32*)&forMarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceSubgroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->read((VkSubgroupFeatureFlags*)&forUnmarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void marshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    const VkBindBufferMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindBufferMemoryInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void marshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    const VkBindImageMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindImageMemoryInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

VkResult marshal_vkBindBufferMemory2(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(vkStream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult marshal_vkBindBufferMemory2_VkResult_return;
    vkStream->read(&marshal_vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    return marshal_vkBindBufferMemory2_VkResult_return;
}

VkResult unmarshal_vkBindBufferMemory2(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        unmarshal_VkBindBufferMemoryInfo(vkStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult unmarshal_vkBindBufferMemory2_VkResult_return;
    vkStream->write(&unmarshal_vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindBufferMemory2_VkResult_return;
}

VkResult marshal_vkBindImageMemory2(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(vkStream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult marshal_vkBindImageMemory2_VkResult_return;
    vkStream->read(&marshal_vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    return marshal_vkBindImageMemory2_VkResult_return;
}

VkResult unmarshal_vkBindImageMemory2(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        unmarshal_VkBindImageMemoryInfo(vkStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult unmarshal_vkBindImageMemory2_VkResult_return;
    vkStream->write(&unmarshal_vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindImageMemory2_VkResult_return;
}

void marshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDevice16BitStorageFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStream* vkStream,
    VkPhysicalDevice16BitStorageFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storageInputOutput16, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    const VkMemoryDedicatedRequirements* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkMemoryDedicatedRequirements(
    VulkanStream* vkStream,
    VkMemoryDedicatedRequirements* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    const VkMemoryDedicatedAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
}

void unmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStream* vkStream,
    VkMemoryDedicatedAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
}

void marshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    const VkMemoryAllocateFlagsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkMemoryAllocateFlags*)&forMarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStream* vkStream,
    VkMemoryAllocateFlagsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkMemoryAllocateFlags*)&forUnmarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->deviceRenderAreaCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDeviceRenderAreas + i));
    }
}

void unmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceRenderAreas, forUnmarshaling->deviceRenderAreaCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->deviceRenderAreaCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDeviceRenderAreas + i));
    }
}

void marshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStream* vkStream,
    VkDeviceGroupCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pWaitSemaphoreDeviceIndices, forMarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCommandBufferDeviceMasks, forMarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pSignalSemaphoreDeviceIndices, forMarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void unmarshal_VkDeviceGroupSubmitInfo(
    VulkanStream* vkStream,
    VkDeviceGroupSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void marshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStream* vkStream,
    VkDeviceGroupBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void marshal_vkGetDeviceGroupPeerMemoryFeatures(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    vkStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void unmarshal_vkGetDeviceGroupPeerMemoryFeatures(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void marshal_vkCmdSetDeviceMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void unmarshal_vkCmdSetDeviceMask(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void marshal_vkCmdDispatchBase(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void unmarshal_vkCmdDispatchBase(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void marshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    const VkBindBufferMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void unmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindBufferMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void marshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    const VkBindImageMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->splitInstanceBindRegionCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pSplitInstanceBindRegions + i));
    }
}

void unmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStream* vkStream,
    VkBindImageMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSplitInstanceBindRegions, forUnmarshaling->splitInstanceBindRegionCount * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->splitInstanceBindRegionCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pSplitInstanceBindRegions + i));
    }
}

void marshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceGroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->write((VkPhysicalDevice*)forMarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->write((VkBool32*)&forMarshaling->subsetAllocation, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceGroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->read((VkPhysicalDevice*)forUnmarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->read((VkBool32*)&forUnmarshaling->subsetAllocation, sizeof(VkBool32));
}

void marshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    const VkDeviceGroupDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->write((const VkPhysicalDevice*)forMarshaling->pPhysicalDevices, forMarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
}

void unmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStream* vkStream,
    VkDeviceGroupDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
    vkStream->read((VkPhysicalDevice*)forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount * sizeof(const VkPhysicalDevice));
}

VkResult marshal_vkEnumeratePhysicalDeviceGroups(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
    {
        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
    }
    VkResult marshal_vkEnumeratePhysicalDeviceGroups_VkResult_return;
    vkStream->read(&marshal_vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

VkResult unmarshal_vkEnumeratePhysicalDeviceGroups(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
    {
        unmarshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
    }
    VkResult unmarshal_vkEnumeratePhysicalDeviceGroups_VkResult_return;
    vkStream->write(&unmarshal_vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void marshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkBufferMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
}

void unmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkBufferMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
}

void marshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkImageMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
}

void unmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
}

void marshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    const VkImageSparseMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
}

void unmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStream* vkStream,
    VkImageSparseMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
}

void marshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    const VkMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkMemoryRequirements2(
    VulkanStream* vkStream,
    VkMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    const VkSparseImageMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkSparseImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkSparseImageMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_vkGetImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageMemoryRequirementsInfo2(vkStream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void unmarshal_vkGetImageMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
    unmarshal_VkImageMemoryRequirementsInfo2(vkStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
    unmarshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void marshal_vkGetBufferMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferMemoryRequirementsInfo2(vkStream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void unmarshal_vkGetBufferMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
    unmarshal_VkBufferMemoryRequirementsInfo2(vkStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
    unmarshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void marshal_vkGetImageSparseMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageSparseMemoryRequirementsInfo2(vkStream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    vkStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
    }
}

void unmarshal_vkGetImageSparseMemoryRequirements2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
    unmarshal_VkImageSparseMemoryRequirementsInfo2(vkStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        unmarshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
    }
}

void marshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceFeatures2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forMarshaling->features));
}

void unmarshal_VkPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkPhysicalDeviceFeatures2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forUnmarshaling->features));
}

void marshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forMarshaling->properties));
}

void unmarshal_VkPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forUnmarshaling->properties));
}

void marshal_VkFormatProperties2(
    VulkanStream* vkStream,
    const VkFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forMarshaling->formatProperties));
}

void unmarshal_VkFormatProperties2(
    VulkanStream* vkStream,
    VkFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forUnmarshaling->formatProperties));
}

void marshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    const VkImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
}

void unmarshal_VkImageFormatProperties2(
    VulkanStream* vkStream,
    VkImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
}

void marshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
}

void unmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
}

void marshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    const VkQueueFamilyProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forMarshaling->queueFamilyProperties));
}

void unmarshal_VkQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkQueueFamilyProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forUnmarshaling->queueFamilyProperties));
}

void marshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMemoryProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forMarshaling->memoryProperties));
}

void unmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkPhysicalDeviceMemoryProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forUnmarshaling->memoryProperties));
}

void marshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    const VkSparseImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->properties));
}

void unmarshal_VkSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkSparseImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->properties));
}

void marshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSparseImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
}

void unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStream* vkStream,
    VkPhysicalDeviceSparseImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
}

void marshal_vkGetPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void unmarshal_vkGetPhysicalDeviceFeatures2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void marshal_vkGetPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void unmarshal_vkGetPhysicalDeviceProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void marshal_vkGetPhysicalDeviceFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
}

void unmarshal_vkGetPhysicalDeviceFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    unmarshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
}

VkResult marshal_vkGetPhysicalDeviceImageFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceImageFormatInfo2(vkStream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult marshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
    unmarshal_VkPhysicalDeviceImageFormatInfo2(vkStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    unmarshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void marshal_vkGetPhysicalDeviceQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceQueueFamilyProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        unmarshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
    }
}

void marshal_vkGetPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void unmarshal_vkGetPhysicalDeviceMemoryProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void marshal_vkGetPhysicalDeviceSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(vkStream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceSparseImageFormatProperties2(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
    unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
    }
}

void marshal_vkTrimCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

void unmarshal_vkTrimCommandPool(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

void marshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    const VkPhysicalDevicePointClippingProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void unmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStream* vkStream,
    VkPhysicalDevicePointClippingProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void marshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    const VkInputAttachmentAspectReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkInputAttachmentAspectReference(
    VulkanStream* vkStream,
    VkInputAttachmentAspectReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassInputAttachmentAspectCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->aspectReferenceCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->aspectReferenceCount; ++i)
    {
        marshal_VkInputAttachmentAspectReference(vkStream, (const VkInputAttachmentAspectReference*)(forMarshaling->pAspectReferences + i));
    }
}

void unmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassInputAttachmentAspectCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->aspectReferenceCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAspectReferences, forUnmarshaling->aspectReferenceCount * sizeof(const VkInputAttachmentAspectReference));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->aspectReferenceCount; ++i)
    {
        unmarshal_VkInputAttachmentAspectReference(vkStream, (VkInputAttachmentAspectReference*)(forUnmarshaling->pAspectReferences + i));
    }
}

void marshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    const VkImageViewUsageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
}

void unmarshal_VkImageViewUsageCreateInfo(
    VulkanStream* vkStream,
    VkImageViewUsageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
}

void marshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    const VkPipelineTessellationDomainOriginStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkTessellationDomainOrigin*)&forMarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void unmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStream* vkStream,
    VkPipelineTessellationDomainOriginStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkTessellationDomainOrigin*)&forUnmarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void marshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    const VkRenderPassMultiviewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pViewMasks, forMarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->write((const int32_t*)forMarshaling->pViewOffsets, forMarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->write((uint32_t*)&forMarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelationMasks, forMarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStream* vkStream,
    VkRenderPassMultiviewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->read((int32_t*)forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void marshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->multiview, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVariablePointerFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceVariablePointerFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointers, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProtectedMemoryFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->protectedMemory, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceProtectedMemoryProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceProtectedMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->protectedNoFault, sizeof(VkBool32));
}

void marshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    const VkDeviceQueueInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceQueueInfo2(
    VulkanStream* vkStream,
    VkDeviceQueueInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueIndex, sizeof(uint32_t));
}

void marshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    const VkProtectedSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->protectedSubmit, sizeof(VkBool32));
}

void unmarshal_VkProtectedSubmitInfo(
    VulkanStream* vkStream,
    VkProtectedSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->protectedSubmit, sizeof(VkBool32));
}

void marshal_vkGetDeviceQueue2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceQueueInfo2(vkStream, (const VkDeviceQueueInfo2*)(pQueueInfo));
    vkStream->read((VkQueue*)pQueue, sizeof(VkQueue));
}

void unmarshal_vkGetDeviceQueue2(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
    unmarshal_VkDeviceQueueInfo2(vkStream, (VkDeviceQueueInfo2*)(pQueueInfo));
    vkStream->write((VkQueue*)pQueue, sizeof(VkQueue));
}

void marshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    vkStream->write((VkChromaLocation*)&forMarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkFilter*)&forMarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->write((VkBool32*)&forMarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void unmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkFilter*)&forUnmarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->read((VkBool32*)&forUnmarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSamplerYcbcrConversion*)&forMarshaling->conversion, sizeof(VkSamplerYcbcrConversion));
}

void unmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSamplerYcbcrConversion*)&forUnmarshaling->conversion, sizeof(VkSamplerYcbcrConversion));
}

void marshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    const VkBindImagePlaneMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStream* vkStream,
    VkBindImagePlaneMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    const VkImagePlaneMemoryRequirementsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStream* vkStream,
    VkImagePlaneMemoryRequirementsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    const VkSamplerYcbcrConversionImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStream* vkStream,
    VkSamplerYcbcrConversionImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

VkResult marshal_vkCreateSamplerYcbcrConversion(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerYcbcrConversionCreateInfo(vkStream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult marshal_vkCreateSamplerYcbcrConversion_VkResult_return;
    vkStream->read(&marshal_vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSamplerYcbcrConversion_VkResult_return;
}

VkResult unmarshal_vkCreateSamplerYcbcrConversion(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
    unmarshal_VkSamplerYcbcrConversionCreateInfo(vkStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult unmarshal_vkCreateSamplerYcbcrConversion_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSamplerYcbcrConversion_VkResult_return;
}

void marshal_vkDestroySamplerYcbcrConversion(
    VulkanStream* vkStream,
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySamplerYcbcrConversion(
    VulkanStream* vkStream,
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    const VkDescriptorUpdateTemplateEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->write((size_t*)&forMarshaling->offset, sizeof(size_t));
    vkStream->write((size_t*)&forMarshaling->stride, sizeof(size_t));
}

void unmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->read((size_t*)&forUnmarshaling->offset, sizeof(size_t));
    vkStream->read((size_t*)&forUnmarshaling->stride, sizeof(size_t));
}

void marshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    const VkDescriptorUpdateTemplateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkDescriptorUpdateTemplateCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorUpdateEntryCount; ++i)
    {
        marshal_VkDescriptorUpdateTemplateEntry(vkStream, (const VkDescriptorUpdateTemplateEntry*)(forMarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->write((VkDescriptorUpdateTemplateType*)&forMarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    vkStream->write((VkDescriptorSetLayout*)&forMarshaling->descriptorSetLayout, sizeof(VkDescriptorSetLayout));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkPipelineLayout*)&forMarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->write((uint32_t*)&forMarshaling->set, sizeof(uint32_t));
}

void unmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStream* vkStream,
    VkDescriptorUpdateTemplateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkDescriptorUpdateTemplateCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorUpdateEntries, forUnmarshaling->descriptorUpdateEntryCount * sizeof(const VkDescriptorUpdateTemplateEntry));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorUpdateEntryCount; ++i)
    {
        unmarshal_VkDescriptorUpdateTemplateEntry(vkStream, (VkDescriptorUpdateTemplateEntry*)(forUnmarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->read((VkDescriptorUpdateTemplateType*)&forUnmarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    vkStream->read((VkDescriptorSetLayout*)&forUnmarshaling->descriptorSetLayout, sizeof(VkDescriptorSetLayout));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkPipelineLayout*)&forUnmarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->set, sizeof(uint32_t));
}

VkResult marshal_vkCreateDescriptorUpdateTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorUpdateTemplateCreateInfo(vkStream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult marshal_vkCreateDescriptorUpdateTemplate_VkResult_return;
    vkStream->read(&marshal_vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDescriptorUpdateTemplate_VkResult_return;
}

VkResult unmarshal_vkCreateDescriptorUpdateTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
    unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult unmarshal_vkCreateDescriptorUpdateTemplate_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void marshal_vkDestroyDescriptorUpdateTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDescriptorUpdateTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_vkUpdateDescriptorSetWithTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    vkStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->write((const void*)pData, sizeof(const uint8_t));
    }
}

void unmarshal_vkUpdateDescriptorSetWithTemplate(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    vkStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->read((void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->alloc((void**)&pData, sizeof(const uint8_t));
        vkStream->read((void*)pData, sizeof(const uint8_t));
    }
}

void marshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    const VkExternalMemoryProperties* forMarshaling)
{
    vkStream->write((VkExternalMemoryFeatureFlags*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryProperties(
    VulkanStream* vkStream,
    VkExternalMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkExternalMemoryFeatureFlags*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalImageFormatInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalImageFormatInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    const VkExternalImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalImageFormatProperties(
    VulkanStream* vkStream,
    VkExternalImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalBufferInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalBufferInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    const VkExternalBufferProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalBufferProperties(
    VulkanStream* vkStream,
    VkExternalBufferProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceIDProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceIDProperties(
    VulkanStream* vkStream,
    VkPhysicalDeviceIDProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint8_t*)forUnmarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void marshal_vkGetPhysicalDeviceExternalBufferProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalBufferInfo(vkStream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalBufferProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
    unmarshal_VkPhysicalDeviceExternalBufferInfo(vkStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    unmarshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

void marshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    const VkExternalMemoryImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    const VkExternalMemoryBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStream* vkStream,
    VkExternalMemoryBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    const VkExportMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExportMemoryAllocateInfo(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalFenceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalFenceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void marshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    const VkExternalFenceProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceFeatureFlags*)&forMarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void unmarshal_VkExternalFenceProperties(
    VulkanStream* vkStream,
    VkExternalFenceProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceFeatureFlags*)&forUnmarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void marshal_vkGetPhysicalDeviceExternalFenceProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalFenceInfo(vkStream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalFenceProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
    unmarshal_VkPhysicalDeviceExternalFenceInfo(vkStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    unmarshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

void marshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    const VkExportFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void unmarshal_VkExportFenceCreateInfo(
    VulkanStream* vkStream,
    VkExportFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void marshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    const VkExportSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void unmarshal_VkExportSemaphoreCreateInfo(
    VulkanStream* vkStream,
    VkExportSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalSemaphoreInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalSemaphoreInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void marshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    const VkExternalSemaphoreProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreFeatureFlags*)&forMarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void unmarshal_VkExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkExternalSemaphoreProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreFeatureFlags*)&forUnmarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void marshal_vkGetPhysicalDeviceExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(vkStream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalSemaphoreProperties(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
    unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    unmarshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

void marshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMaintenance3Properties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStream* vkStream,
    VkPhysicalDeviceMaintenance3Properties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void marshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutSupport* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->supported, sizeof(VkBool32));
}

void unmarshal_VkDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutSupport* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->supported, sizeof(VkBool32));
}

void marshal_vkGetDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(vkStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

void unmarshal_vkGetDescriptorSetLayoutSupport(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
    unmarshal_VkDescriptorSetLayoutCreateInfo(vkStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    unmarshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

void marshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderDrawParameterFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderDrawParameterFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDrawParameters, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_surface
void marshal_vkDestroySurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkGetPhysicalDeviceSurfaceSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult marshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

void marshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    unmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

void marshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    const VkSurfaceFormatKHR* forMarshaling)
{
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

void unmarshal_VkSurfaceFormatKHR(
    VulkanStream* vkStream,
    VkSurfaceFormatKHR* forUnmarshaling)
{
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

VkResult marshal_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
    {
        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
    }
    VkResult marshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
    {
        unmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult marshal_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    vkStream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    VkResult marshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    VkResult unmarshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
void marshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSwapchainCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    vkStream->write((VkSurfaceKHR*)&forMarshaling->surface, sizeof(VkSurfaceKHR));
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->imageFormat, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
    vkStream->write((uint32_t*)&forMarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t**)&forMarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagBitsKHR*)&forMarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->write((VkPresentModeKHR*)&forMarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->write((VkBool32*)&forMarshaling->clipped, sizeof(VkBool32));
    vkStream->write((VkSwapchainKHR*)&forMarshaling->oldSwapchain, sizeof(VkSwapchainKHR));
}

void unmarshal_VkSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSwapchainCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    vkStream->read((VkSurfaceKHR*)&forUnmarshaling->surface, sizeof(VkSurfaceKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->imageFormat, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    vkStream->read((uint32_t**)&forUnmarshaling->pQueueFamilyIndices, sizeof(const uint32_t*));
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagBitsKHR*)&forUnmarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->read((VkPresentModeKHR*)&forUnmarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->clipped, sizeof(VkBool32));
    vkStream->read((VkSwapchainKHR*)&forUnmarshaling->oldSwapchain, sizeof(VkSwapchainKHR));
}

VkResult marshal_vkCreateSwapchainKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSwapchainCreateInfoKHR(vkStream, (const VkSwapchainCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
    VkResult marshal_vkCreateSwapchainKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSwapchainKHR_VkResult_return;
}

VkResult unmarshal_vkCreateSwapchainKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
    unmarshal_VkSwapchainCreateInfoKHR(vkStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
    VkResult unmarshal_vkCreateSwapchainKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSwapchainKHR_VkResult_return;
}

void marshal_vkDestroySwapchainKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySwapchainKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkGetSwapchainImagesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    vkStream->read((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
    VkResult marshal_vkGetSwapchainImagesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult unmarshal_vkGetSwapchainImagesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    vkStream->write((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
    VkResult unmarshal_vkGetSwapchainImagesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult marshal_vkAcquireNextImageKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((uint64_t*)&timeout, sizeof(uint64_t));
    vkStream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    vkStream->write((VkFence*)&fence, sizeof(VkFence));
    vkStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult marshal_vkAcquireNextImageKHR_VkResult_return;
    vkStream->read(&marshal_vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkAcquireNextImageKHR_VkResult_return;
}

VkResult unmarshal_vkAcquireNextImageKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((uint64_t*)&timeout, sizeof(uint64_t));
    vkStream->read((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    vkStream->read((VkFence*)&fence, sizeof(VkFence));
    vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult unmarshal_vkAcquireNextImageKHR_VkResult_return;
    vkStream->write(&unmarshal_vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAcquireNextImageKHR_VkResult_return;
}

void marshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    const VkPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const VkSemaphore*)forMarshaling->pWaitSemaphores, forMarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const VkSwapchainKHR*)forMarshaling->pSwapchains, forMarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    vkStream->write((const uint32_t*)forMarshaling->pImageIndices, forMarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->write((VkResult**)&forMarshaling->pResults, sizeof(VkResult*));
    if (forMarshaling->pResults)
    {
        vkStream->write((VkResult*)forMarshaling->pResults, forMarshaling->swapchainCount * sizeof(VkResult));
    }
}

void unmarshal_VkPresentInfoKHR(
    VulkanStream* vkStream,
    VkPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount * sizeof(const VkSemaphore));
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    vkStream->read((VkSwapchainKHR*)forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount * sizeof(const VkSwapchainKHR));
    vkStream->alloc((void**)&forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((VkResult**)&forUnmarshaling->pResults, sizeof(VkResult*));
    if (forUnmarshaling->pResults)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
        vkStream->read((VkResult*)forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
    }
}

VkResult marshal_vkQueuePresentKHR(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkPresentInfoKHR(vkStream, (const VkPresentInfoKHR*)(pPresentInfo));
    VkResult marshal_vkQueuePresentKHR_VkResult_return;
    vkStream->read(&marshal_vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkQueuePresentKHR_VkResult_return;
}

VkResult unmarshal_vkQueuePresentKHR(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
    unmarshal_VkPresentInfoKHR(vkStream, (VkPresentInfoKHR*)(pPresentInfo));
    VkResult unmarshal_vkQueuePresentKHR_VkResult_return;
    vkStream->write(&unmarshal_vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkQueuePresentKHR_VkResult_return;
}

void marshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkImageSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSwapchainKHR*)&forMarshaling->swapchain, sizeof(VkSwapchainKHR));
}

void unmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkImageSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSwapchainKHR*)&forUnmarshaling->swapchain, sizeof(VkSwapchainKHR));
}

void marshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    const VkBindImageMemorySwapchainInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSwapchainKHR*)&forMarshaling->swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((uint32_t*)&forMarshaling->imageIndex, sizeof(uint32_t));
}

void unmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStream* vkStream,
    VkBindImageMemorySwapchainInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSwapchainKHR*)&forUnmarshaling->swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->imageIndex, sizeof(uint32_t));
}

void marshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    const VkAcquireNextImageInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSwapchainKHR*)&forMarshaling->swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    vkStream->write((VkSemaphore*)&forMarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->write((VkFence*)&forMarshaling->fence, sizeof(VkFence));
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkAcquireNextImageInfoKHR(
    VulkanStream* vkStream,
    VkAcquireNextImageInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSwapchainKHR*)&forUnmarshaling->swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((uint64_t*)&forUnmarshaling->timeout, sizeof(uint64_t));
    vkStream->read((VkSemaphore*)&forUnmarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->read((VkFence*)&forUnmarshaling->fence, sizeof(VkFence));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupPresentCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)forMarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)forUnmarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void marshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceMasks, forMarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagBitsKHR*)&forMarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void unmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagBitsKHR*)&forUnmarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void marshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDeviceGroupSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStream* vkStream,
    VkDeviceGroupSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

VkResult marshal_vkGetDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    VkResult marshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetDeviceGroupPresentCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    VkResult unmarshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult marshal_vkGetDeviceGroupSurfacePresentModesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    VkResult marshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult unmarshal_vkGetDeviceGroupSurfacePresentModesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    VkResult unmarshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult marshal_vkGetPhysicalDevicePresentRectanglesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
    {
        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
    }
    VkResult marshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDevicePresentRectanglesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
    }
    VkResult unmarshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult marshal_vkAcquireNextImage2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkAcquireNextImageInfoKHR(vkStream, (const VkAcquireNextImageInfoKHR*)(pAcquireInfo));
    vkStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult marshal_vkAcquireNextImage2KHR_VkResult_return;
    vkStream->read(&marshal_vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkAcquireNextImage2KHR_VkResult_return;
}

VkResult unmarshal_vkAcquireNextImage2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
    unmarshal_VkAcquireNextImageInfoKHR(vkStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
    vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult unmarshal_vkAcquireNextImage2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
void marshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPropertiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayKHR*)&forMarshaling->display, sizeof(VkDisplayKHR));
    vkStream->putString(forMarshaling->displayName);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalDimensions));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalResolution));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkBool32*)&forMarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->persistentContent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayKHR*)&forUnmarshaling->display, sizeof(VkDisplayKHR));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->displayName);
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalDimensions));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalResolution));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->persistentContent, sizeof(VkBool32));
}

void marshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    const VkDisplayModeParametersKHR* forMarshaling)
{
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->visibleRegion));
    vkStream->write((uint32_t*)&forMarshaling->refreshRate, sizeof(uint32_t));
}

void unmarshal_VkDisplayModeParametersKHR(
    VulkanStream* vkStream,
    VkDisplayModeParametersKHR* forUnmarshaling)
{
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->visibleRegion));
    vkStream->read((uint32_t*)&forUnmarshaling->refreshRate, sizeof(uint32_t));
}

void marshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayModePropertiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayModeKHR*)&forMarshaling->displayMode, sizeof(VkDisplayModeKHR));
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayModePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayModeKHR*)&forUnmarshaling->displayMode, sizeof(VkDisplayModeKHR));
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDisplayModeCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDisplayModeCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplayModeCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDisplayModeCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayPlaneAlphaFlagsKHR*)&forMarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minSrcPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxSrcPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minSrcExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSrcExtent));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minDstPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxDstPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minDstExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxDstExtent));
}

void unmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayPlaneAlphaFlagsKHR*)&forUnmarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minSrcPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxSrcPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minSrcExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSrcExtent));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minDstPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxDstPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minDstExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxDstExtent));
}

void marshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    const VkDisplayPlanePropertiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayKHR*)&forMarshaling->currentDisplay, sizeof(VkDisplayKHR));
    vkStream->write((uint32_t*)&forMarshaling->currentStackIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkDisplayPlanePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayKHR*)&forUnmarshaling->currentDisplay, sizeof(VkDisplayKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->currentStackIndex, sizeof(uint32_t));
}

void marshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkDisplaySurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDisplaySurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    vkStream->write((VkDisplayModeKHR*)&forMarshaling->displayMode, sizeof(VkDisplayModeKHR));
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((float*)&forMarshaling->globalAlpha, sizeof(float));
    vkStream->write((VkDisplayPlaneAlphaFlagBitsKHR*)&forMarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkDisplaySurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDisplaySurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    vkStream->read((VkDisplayModeKHR*)&forUnmarshaling->displayMode, sizeof(VkDisplayModeKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((float*)&forUnmarshaling->globalAlpha, sizeof(float));
    vkStream->read((VkDisplayPlaneAlphaFlagBitsKHR*)&forUnmarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
}

VkResult marshal_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
    }
    VkResult marshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult marshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
    }
    VkResult marshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult marshal_vkGetDisplayPlaneSupportedDisplaysKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    vkStream->read((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
    VkResult marshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
    vkStream->read(&marshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult unmarshal_vkGetDisplayPlaneSupportedDisplaysKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
    vkStream->write((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
    VkResult unmarshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult marshal_vkGetDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
    }
    VkResult marshal_vkGetDisplayModePropertiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetDisplayModePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetDisplayModePropertiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult marshal_vkCreateDisplayModeKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayModeCreateInfoKHR(vkStream, (const VkDisplayModeCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
    VkResult marshal_vkCreateDisplayModeKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDisplayModeKHR_VkResult_return;
}

VkResult unmarshal_vkCreateDisplayModeKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
    unmarshal_VkDisplayModeCreateInfoKHR(vkStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
    VkResult unmarshal_vkCreateDisplayModeKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDisplayModeKHR_VkResult_return;
}

VkResult marshal_vkGetDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkDisplayModeKHR*)&mode, sizeof(VkDisplayModeKHR));
    vkStream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
    marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    VkResult marshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetDisplayPlaneCapabilitiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkDisplayModeKHR*)&mode, sizeof(VkDisplayModeKHR));
    vkStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
    unmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    VkResult unmarshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult marshal_vkCreateDisplayPlaneSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDisplaySurfaceCreateInfoKHR(vkStream, (const VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateDisplayPlaneSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
    unmarshal_VkDisplaySurfaceCreateInfoKHR(vkStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
void marshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    const VkDisplayPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->srcRect));
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->dstRect));
    vkStream->write((VkBool32*)&forMarshaling->persistent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPresentInfoKHR(
    VulkanStream* vkStream,
    VkDisplayPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->srcRect));
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->dstRect));
    vkStream->read((VkBool32*)&forUnmarshaling->persistent, sizeof(VkBool32));
}

VkResult marshal_vkCreateSharedSwapchainsKHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkSwapchainCreateInfoKHR(vkStream, (const VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
    }
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
    VkResult marshal_vkCreateSharedSwapchainsKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSharedSwapchainsKHR_VkResult_return;
}

VkResult unmarshal_vkCreateSharedSwapchainsKHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        unmarshal_VkSwapchainCreateInfoKHR(vkStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
    }
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
    VkResult unmarshal_vkCreateSharedSwapchainsKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
void marshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkXlibSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkXlibSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    vkStream->write((Display**)&forMarshaling->dpy, sizeof(Display*));
    if (forMarshaling->dpy)
    {
        vkStream->write((Display*)forMarshaling->dpy, sizeof(Display));
    }
    vkStream->write((Window*)&forMarshaling->window, sizeof(Window));
}

void unmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXlibSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkXlibSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    vkStream->read((Display**)&forUnmarshaling->dpy, sizeof(Display*));
    if (forUnmarshaling->dpy)
    {
        vkStream->alloc((void**)&forUnmarshaling->dpy, sizeof(Display));
        vkStream->read((Display*)forUnmarshaling->dpy, sizeof(Display));
    }
    vkStream->read((Window*)&forUnmarshaling->window, sizeof(Window));
}

VkResult marshal_vkCreateXlibSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkXlibSurfaceCreateInfoKHR(vkStream, (const VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateXlibSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateXlibSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateXlibSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
    unmarshal_VkXlibSurfaceCreateInfoKHR(vkStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateXlibSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 marshal_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((Display*)dpy, sizeof(Display));
    vkStream->write((VisualID*)&visualID, sizeof(VisualID));
    VkBool32 marshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return marshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

VkBool32 unmarshal_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((Display*)dpy, sizeof(Display));
    vkStream->read((VisualID*)&visualID, sizeof(VisualID));
    VkBool32 unmarshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return unmarshal_vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
void marshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkXcbSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkXcbSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    vkStream->write((xcb_connection_t**)&forMarshaling->connection, sizeof(xcb_connection_t*));
    if (forMarshaling->connection)
    {
        vkStream->write((xcb_connection_t*)forMarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->write((xcb_window_t*)&forMarshaling->window, sizeof(xcb_window_t));
}

void unmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkXcbSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkXcbSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    vkStream->read((xcb_connection_t**)&forUnmarshaling->connection, sizeof(xcb_connection_t*));
    if (forUnmarshaling->connection)
    {
        vkStream->alloc((void**)&forUnmarshaling->connection, sizeof(xcb_connection_t));
        vkStream->read((xcb_connection_t*)forUnmarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->read((xcb_window_t*)&forUnmarshaling->window, sizeof(xcb_window_t));
}

VkResult marshal_vkCreateXcbSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkXcbSurfaceCreateInfoKHR(vkStream, (const VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateXcbSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateXcbSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateXcbSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
    unmarshal_VkXcbSurfaceCreateInfoKHR(vkStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateXcbSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 marshal_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    vkStream->write((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
    VkBool32 marshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return marshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

VkBool32 unmarshal_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    vkStream->read((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
    VkBool32 unmarshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return unmarshal_vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
void marshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkWaylandSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkWaylandSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    vkStream->write((wl_display**)&forMarshaling->display, sizeof(wl_display*));
    if (forMarshaling->display)
    {
        vkStream->write((wl_display*)forMarshaling->display, sizeof(wl_display));
    }
    vkStream->write((wl_surface**)&forMarshaling->surface, sizeof(wl_surface*));
    if (forMarshaling->surface)
    {
        vkStream->write((wl_surface*)forMarshaling->surface, sizeof(wl_surface));
    }
}

void unmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWaylandSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkWaylandSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    vkStream->read((wl_display**)&forUnmarshaling->display, sizeof(wl_display*));
    if (forUnmarshaling->display)
    {
        vkStream->alloc((void**)&forUnmarshaling->display, sizeof(wl_display));
        vkStream->read((wl_display*)forUnmarshaling->display, sizeof(wl_display));
    }
    vkStream->read((wl_surface**)&forUnmarshaling->surface, sizeof(wl_surface*));
    if (forUnmarshaling->surface)
    {
        vkStream->alloc((void**)&forUnmarshaling->surface, sizeof(wl_surface));
        vkStream->read((wl_surface*)forUnmarshaling->surface, sizeof(wl_surface));
    }
}

VkResult marshal_vkCreateWaylandSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkWaylandSurfaceCreateInfoKHR(vkStream, (const VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateWaylandSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateWaylandSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
    unmarshal_VkWaylandSurfaceCreateInfoKHR(vkStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateWaylandSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 marshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((wl_display*)display, sizeof(wl_display));
    VkBool32 marshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return marshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

VkBool32 unmarshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((wl_display*)display, sizeof(wl_display));
    VkBool32 unmarshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return unmarshal_vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_mir_surface
void marshal_VkMirSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkMirSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkMirSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkMirSurfaceCreateFlagsKHR));
    vkStream->write((MirConnection**)&forMarshaling->connection, sizeof(MirConnection*));
    if (forMarshaling->connection)
    {
        vkStream->write((MirConnection*)forMarshaling->connection, sizeof(MirConnection));
    }
    vkStream->write((MirSurface**)&forMarshaling->mirSurface, sizeof(MirSurface*));
    if (forMarshaling->mirSurface)
    {
        vkStream->write((MirSurface*)forMarshaling->mirSurface, sizeof(MirSurface));
    }
}

void unmarshal_VkMirSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkMirSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkMirSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkMirSurfaceCreateFlagsKHR));
    vkStream->read((MirConnection**)&forUnmarshaling->connection, sizeof(MirConnection*));
    if (forUnmarshaling->connection)
    {
        vkStream->alloc((void**)&forUnmarshaling->connection, sizeof(MirConnection));
        vkStream->read((MirConnection*)forUnmarshaling->connection, sizeof(MirConnection));
    }
    vkStream->read((MirSurface**)&forUnmarshaling->mirSurface, sizeof(MirSurface*));
    if (forUnmarshaling->mirSurface)
    {
        vkStream->alloc((void**)&forUnmarshaling->mirSurface, sizeof(MirSurface));
        vkStream->read((MirSurface*)forUnmarshaling->mirSurface, sizeof(MirSurface));
    }
}

VkResult marshal_vkCreateMirSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkMirSurfaceCreateInfoKHR(vkStream, (const VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateMirSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateMirSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateMirSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
    unmarshal_VkMirSurfaceCreateInfoKHR(vkStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateMirSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateMirSurfaceKHR_VkResult_return;
}

VkBool32 marshal_vkGetPhysicalDeviceMirPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((MirConnection*)connection, sizeof(MirConnection));
    VkBool32 marshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return marshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

VkBool32 unmarshal_vkGetPhysicalDeviceMirPresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((MirConnection*)connection, sizeof(MirConnection));
    VkBool32 unmarshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return unmarshal_vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
void marshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkAndroidSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkAndroidSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    vkStream->write((ANativeWindow**)&forMarshaling->window, sizeof(ANativeWindow*));
    if (forMarshaling->window)
    {
        vkStream->write((ANativeWindow*)forMarshaling->window, sizeof(ANativeWindow));
    }
}

void unmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkAndroidSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkAndroidSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    vkStream->read((ANativeWindow**)&forUnmarshaling->window, sizeof(ANativeWindow*));
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(ANativeWindow));
        vkStream->read((ANativeWindow*)forUnmarshaling->window, sizeof(ANativeWindow));
    }
}

VkResult marshal_vkCreateAndroidSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkAndroidSurfaceCreateInfoKHR(vkStream, (const VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateAndroidSurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateAndroidSurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateAndroidSurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
    unmarshal_VkAndroidSurfaceCreateInfoKHR(vkStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateAndroidSurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
void marshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    const VkWin32SurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkWin32SurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->write((HINSTANCE*)&forMarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->write((HWND*)&forMarshaling->hwnd, sizeof(HWND));
}

void unmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStream* vkStream,
    VkWin32SurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkWin32SurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->read((HINSTANCE*)&forUnmarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->read((HWND*)&forUnmarshaling->hwnd, sizeof(HWND));
}

VkResult marshal_vkCreateWin32SurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkWin32SurfaceCreateInfoKHR(vkStream, (const VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateWin32SurfaceKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateWin32SurfaceKHR_VkResult_return;
}

VkResult unmarshal_vkCreateWin32SurfaceKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
    unmarshal_VkWin32SurfaceCreateInfoKHR(vkStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateWin32SurfaceKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 marshal_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    VkBool32 marshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return marshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

VkBool32 unmarshal_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    VkBool32 unmarshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return unmarshal_vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void marshal_vkGetPhysicalDeviceFeatures2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void unmarshal_vkGetPhysicalDeviceFeatures2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void marshal_vkGetPhysicalDeviceProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void unmarshal_vkGetPhysicalDeviceProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void marshal_vkGetPhysicalDeviceFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
}

void unmarshal_vkGetPhysicalDeviceFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    unmarshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
}

VkResult marshal_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceImageFormatInfo2(vkStream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult marshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
    unmarshal_VkPhysicalDeviceImageFormatInfo2(vkStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    unmarshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult unmarshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void marshal_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
    {
        unmarshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
    }
}

void marshal_vkGetPhysicalDeviceMemoryProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void unmarshal_vkGetPhysicalDeviceMemoryProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void marshal_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(vkStream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
    }
}

void unmarshal_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
    unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
    }
}

#endif
#ifdef VK_KHR_device_group
void marshal_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    vkStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void unmarshal_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void marshal_vkCmdSetDeviceMaskKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void unmarshal_vkCmdSetDeviceMaskKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void marshal_vkCmdDispatchBaseKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void unmarshal_vkCmdDispatchBaseKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
    vkStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void marshal_vkTrimCommandPoolKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

void unmarshal_vkTrimCommandPoolKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    vkStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult marshal_vkEnumeratePhysicalDeviceGroupsKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
    {
        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
    }
    VkResult marshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
    vkStream->read(&marshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

VkResult unmarshal_vkEnumeratePhysicalDeviceGroupsKHR(
    VulkanStream* vkStream,
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
    {
        unmarshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
    }
    VkResult unmarshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
    vkStream->write(&unmarshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void marshal_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalBufferInfo(vkStream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
    unmarshal_VkPhysicalDeviceExternalBufferInfo(vkStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    unmarshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((const SECURITY_ATTRIBUTES**)&forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    const VkMemoryWin32HandlePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryWin32HandlePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkMemoryGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

VkResult marshal_vkGetMemoryWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetWin32HandleInfoKHR(vkStream, (const VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult marshal_vkGetMemoryWin32HandleKHR_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult unmarshal_vkGetMemoryWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
    unmarshal_VkMemoryGetWin32HandleInfoKHR(vkStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult unmarshal_vkGetMemoryWin32HandleKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult marshal_vkGetMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((HANDLE*)&handle, sizeof(HANDLE));
    marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    VkResult marshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetMemoryWin32HandlePropertiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((HANDLE*)&handle, sizeof(HANDLE));
    unmarshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    VkResult unmarshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
void marshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportMemoryFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportMemoryFdInfoKHR(
    VulkanStream* vkStream,
    VkImportMemoryFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    const VkMemoryFdPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkMemoryFdPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkMemoryGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetFdInfoKHR(
    VulkanStream* vkStream,
    VkMemoryGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

VkResult marshal_vkGetMemoryFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetFdInfoKHR(vkStream, (const VkMemoryGetFdInfoKHR*)(pGetFdInfo));
    vkStream->read((int*)pFd, sizeof(int));
    VkResult marshal_vkGetMemoryFdKHR_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryFdKHR_VkResult_return;
}

VkResult unmarshal_vkGetMemoryFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
    unmarshal_VkMemoryGetFdInfoKHR(vkStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
    vkStream->write((int*)pFd, sizeof(int));
    VkResult unmarshal_vkGetMemoryFdKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryFdKHR_VkResult_return;
}

VkResult marshal_vkGetMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((int*)&fd, sizeof(int));
    marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    VkResult marshal_vkGetMemoryFdPropertiesKHR_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryFdPropertiesKHR_VkResult_return;
}

VkResult unmarshal_vkGetMemoryFdPropertiesKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((int*)&fd, sizeof(int));
    unmarshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    VkResult unmarshal_vkGetMemoryFdPropertiesKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    vkStream->write((const VkDeviceMemory*)forMarshaling->pAcquireSyncs, forMarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeouts, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    vkStream->write((const VkDeviceMemory*)forMarshaling->pReleaseSyncs, forMarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->read((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->read((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
void marshal_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(vkStream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
    unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    unmarshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void marshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSemaphore*)&forMarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSemaphore*)&forUnmarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((const SECURITY_ATTRIBUTES**)&forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    const VkD3D12FenceSubmitInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    vkStream->write((const uint64_t**)&forMarshaling->pWaitSemaphoreValues, sizeof(const uint64_t*));
    if (forMarshaling->pWaitSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    vkStream->write((const uint64_t**)&forMarshaling->pSignalSemaphoreValues, sizeof(const uint64_t*));
    if (forMarshaling->pSignalSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void unmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStream* vkStream,
    VkD3D12FenceSubmitInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    vkStream->read((uint64_t**)&forUnmarshaling->pWaitSemaphoreValues, sizeof(const uint64_t*));
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    vkStream->read((uint64_t**)&forUnmarshaling->pSignalSemaphoreValues, sizeof(const uint64_t*));
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        vkStream->alloc((void**)&forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        vkStream->read((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void marshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkSemaphoreGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSemaphore*)&forMarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSemaphore*)&forUnmarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

VkResult marshal_vkImportSemaphoreWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportSemaphoreWin32HandleInfoKHR(vkStream, (const VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
    VkResult marshal_vkImportSemaphoreWin32HandleKHR_VkResult_return;
    vkStream->read(&marshal_vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult unmarshal_vkImportSemaphoreWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
    unmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
    VkResult unmarshal_vkImportSemaphoreWin32HandleKHR_VkResult_return;
    vkStream->write(&unmarshal_vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult marshal_vkGetSemaphoreWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreGetWin32HandleInfoKHR(vkStream, (const VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult marshal_vkGetSemaphoreWin32HandleKHR_VkResult_return;
    vkStream->read(&marshal_vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult unmarshal_vkGetSemaphoreWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
    unmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult unmarshal_vkGetSemaphoreWin32HandleKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void marshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportSemaphoreFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSemaphore*)&forMarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStream* vkStream,
    VkImportSemaphoreFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSemaphore*)&forUnmarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkSemaphoreGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSemaphore*)&forMarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStream* vkStream,
    VkSemaphoreGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSemaphore*)&forUnmarshaling->semaphore, sizeof(VkSemaphore));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

VkResult marshal_vkImportSemaphoreFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportSemaphoreFdInfoKHR(vkStream, (const VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
    VkResult marshal_vkImportSemaphoreFdKHR_VkResult_return;
    vkStream->read(&marshal_vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult unmarshal_vkImportSemaphoreFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
    unmarshal_VkImportSemaphoreFdInfoKHR(vkStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
    VkResult unmarshal_vkImportSemaphoreFdKHR_VkResult_return;
    vkStream->write(&unmarshal_vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult marshal_vkGetSemaphoreFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreGetFdInfoKHR(vkStream, (const VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
    vkStream->read((int*)pFd, sizeof(int));
    VkResult marshal_vkGetSemaphoreFdKHR_VkResult_return;
    vkStream->read(&marshal_vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetSemaphoreFdKHR_VkResult_return;
}

VkResult unmarshal_vkGetSemaphoreFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
    unmarshal_VkSemaphoreGetFdInfoKHR(vkStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
    vkStream->write((int*)pFd, sizeof(int));
    VkResult unmarshal_vkGetSemaphoreFdKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void marshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxPushDescriptors, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevicePushDescriptorPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushDescriptors, sizeof(uint32_t));
}

void marshal_vkCmdPushDescriptorSetKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->write((uint32_t*)&set, sizeof(uint32_t));
    vkStream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(vkStream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
}

void unmarshal_vkCmdPushDescriptorSetKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->read((uint32_t*)&set, sizeof(uint32_t));
    vkStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        unmarshal_VkWriteDescriptorSet(vkStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
}

void marshal_vkCmdPushDescriptorSetWithTemplateKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->write((uint32_t*)&set, sizeof(uint32_t));
    vkStream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->write((const void*)pData, sizeof(const uint8_t));
    }
}

void unmarshal_vkCmdPushDescriptorSetWithTemplateKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->read((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    vkStream->read((uint32_t*)&set, sizeof(uint32_t));
    vkStream->read((void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->alloc((void**)&pData, sizeof(const uint8_t));
        vkStream->read((void*)pData, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void marshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    const VkRectLayerKHR* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->layer, sizeof(uint32_t));
}

void unmarshal_VkRectLayerKHR(
    VulkanStream* vkStream,
    VkRectLayerKHR* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->layer, sizeof(uint32_t));
}

void marshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    const VkPresentRegionKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->rectangleCount, sizeof(uint32_t));
    vkStream->write((const VkRectLayerKHR**)&forMarshaling->pRectangles, sizeof(const VkRectLayerKHR*));
    if (forMarshaling->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->rectangleCount; ++i)
        {
            marshal_VkRectLayerKHR(vkStream, (const VkRectLayerKHR*)(forMarshaling->pRectangles + i));
        }
    }
}

void unmarshal_VkPresentRegionKHR(
    VulkanStream* vkStream,
    VkPresentRegionKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->rectangleCount, sizeof(uint32_t));
    vkStream->read((VkRectLayerKHR**)&forUnmarshaling->pRectangles, sizeof(const VkRectLayerKHR*));
    if (forUnmarshaling->pRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRectangles, forUnmarshaling->rectangleCount * sizeof(const VkRectLayerKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->rectangleCount; ++i)
        {
            unmarshal_VkRectLayerKHR(vkStream, (VkRectLayerKHR*)(forUnmarshaling->pRectangles + i));
        }
    }
}

void marshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    const VkPresentRegionsKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const VkPresentRegionKHR**)&forMarshaling->pRegions, sizeof(const VkPresentRegionKHR*));
    if (forMarshaling->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentRegionKHR(vkStream, (const VkPresentRegionKHR*)(forMarshaling->pRegions + i));
        }
    }
}

void unmarshal_VkPresentRegionsKHR(
    VulkanStream* vkStream,
    VkPresentRegionsKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->read((VkPresentRegionKHR**)&forUnmarshaling->pRegions, sizeof(const VkPresentRegionKHR*));
    if (forUnmarshaling->pRegions)
    {
        vkStream->alloc((void**)&forUnmarshaling->pRegions, forUnmarshaling->swapchainCount * sizeof(const VkPresentRegionKHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentRegionKHR(vkStream, (VkPresentRegionKHR*)(forUnmarshaling->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
VkResult marshal_vkCreateDescriptorUpdateTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorUpdateTemplateCreateInfo(vkStream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult marshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

VkResult unmarshal_vkCreateDescriptorUpdateTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
    unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult unmarshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void marshal_vkDestroyDescriptorUpdateTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDescriptorUpdateTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_vkUpdateDescriptorSetWithTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    vkStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->write((const void*)pData, sizeof(const uint8_t));
    }
}

void unmarshal_vkUpdateDescriptorSetWithTemplateKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    vkStream->read((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    vkStream->read((void**)&pData, sizeof(const void*));
    if (pData)
    {
        vkStream->alloc((void**)&pData, sizeof(const uint8_t));
        vkStream->read((void*)pData, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_KHR_create_renderpass2
void marshal_VkAttachmentDescription2KHR(
    VulkanStream* vkStream,
    const VkAttachmentDescription2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription2KHR(
    VulkanStream* vkStream,
    VkAttachmentDescription2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference2KHR(
    VulkanStream* vkStream,
    const VkAttachmentReference2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkAttachmentReference2KHR(
    VulkanStream* vkStream,
    VkAttachmentReference2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkSubpassDescription2KHR(
    VulkanStream* vkStream,
    const VkSubpassDescription2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->viewMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pColorAttachments + i));
    }
    vkStream->write((const VkAttachmentReference2KHR**)&forMarshaling->pResolveAttachments, sizeof(const VkAttachmentReference2KHR*));
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pResolveAttachments + i));
        }
    }
    vkStream->write((const VkAttachmentReference2KHR**)&forMarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2KHR*));
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription2KHR(
    VulkanStream* vkStream,
    VkSubpassDescription2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->viewMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pInputAttachments, forUnmarshaling->inputAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pColorAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pColorAttachments + i));
    }
    vkStream->read((VkAttachmentReference2KHR**)&forUnmarshaling->pResolveAttachments, sizeof(const VkAttachmentReference2KHR*));
    if (forUnmarshaling->pResolveAttachments)
    {
        vkStream->alloc((void**)&forUnmarshaling->pResolveAttachments, forUnmarshaling->colorAttachmentCount * sizeof(const VkAttachmentReference2KHR));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    vkStream->read((VkAttachmentReference2KHR**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2KHR*));
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDepthStencilAttachment, sizeof(const VkAttachmentReference2KHR));
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency2KHR(
    VulkanStream* vkStream,
    const VkSubpassDependency2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->write((int32_t*)&forMarshaling->viewOffset, sizeof(int32_t));
}

void unmarshal_VkSubpassDependency2KHR(
    VulkanStream* vkStream,
    VkSubpassDependency2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->read((int32_t*)&forUnmarshaling->viewOffset, sizeof(int32_t));
}

void marshal_VkRenderPassCreateInfo2KHR(
    VulkanStream* vkStream,
    const VkRenderPassCreateInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription2KHR(vkStream, (const VkAttachmentDescription2KHR*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription2KHR(vkStream, (const VkSubpassDescription2KHR*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency2KHR(vkStream, (const VkSubpassDependency2KHR*)(forMarshaling->pDependencies + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelatedViewMasks, forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassCreateInfo2KHR(
    VulkanStream* vkStream,
    VkRenderPassCreateInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount * sizeof(const VkAttachmentDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription2KHR(vkStream, (VkAttachmentDescription2KHR*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSubpasses, forUnmarshaling->subpassCount * sizeof(const VkSubpassDescription2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription2KHR(vkStream, (VkSubpassDescription2KHR*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDependencies, forUnmarshaling->dependencyCount * sizeof(const VkSubpassDependency2KHR));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency2KHR(vkStream, (VkSubpassDependency2KHR*)(forUnmarshaling->pDependencies + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

VkResult marshal_vkCreateRenderPass2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkRenderPassCreateInfo2KHR(vkStream, (const VkRenderPassCreateInfo2KHR*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult marshal_vkCreateRenderPass2KHR_VkResult_return;
    vkStream->read(&marshal_vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateRenderPass2KHR_VkResult_return;
}

VkResult unmarshal_vkCreateRenderPass2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
    unmarshal_VkRenderPassCreateInfo2KHR(vkStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult unmarshal_vkCreateRenderPass2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateRenderPass2KHR_VkResult_return;
}

void marshal_VkSubpassBeginInfoKHR(
    VulkanStream* vkStream,
    const VkSubpassBeginInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSubpassContents*)&forMarshaling->contents, sizeof(VkSubpassContents));
}

void unmarshal_VkSubpassBeginInfoKHR(
    VulkanStream* vkStream,
    VkSubpassBeginInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSubpassContents*)&forUnmarshaling->contents, sizeof(VkSubpassContents));
}

void marshal_vkCmdBeginRenderPass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkRenderPassBeginInfo(vkStream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
    marshal_VkSubpassBeginInfoKHR(vkStream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
}

void unmarshal_vkCmdBeginRenderPass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
    unmarshal_VkRenderPassBeginInfo(vkStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
    vkStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
    unmarshal_VkSubpassBeginInfoKHR(vkStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
}

void marshal_VkSubpassEndInfoKHR(
    VulkanStream* vkStream,
    const VkSubpassEndInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
}

void unmarshal_VkSubpassEndInfoKHR(
    VulkanStream* vkStream,
    VkSubpassEndInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
}

void marshal_vkCmdNextSubpass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSubpassBeginInfoKHR(vkStream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
    marshal_VkSubpassEndInfoKHR(vkStream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

void unmarshal_vkCmdNextSubpass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
    unmarshal_VkSubpassBeginInfoKHR(vkStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
    vkStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
    unmarshal_VkSubpassEndInfoKHR(vkStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

void marshal_vkCmdEndRenderPass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSubpassEndInfoKHR(vkStream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

void unmarshal_vkCmdEndRenderPass2KHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
    unmarshal_VkSubpassEndInfoKHR(vkStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

#endif
#ifdef VK_KHR_shared_presentable_image
void marshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    const VkSharedPresentSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkImageUsageFlags*)&forMarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStream* vkStream,
    VkSharedPresentSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

VkResult marshal_vkGetSwapchainStatusKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    VkResult marshal_vkGetSwapchainStatusKHR_VkResult_return;
    vkStream->read(&marshal_vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetSwapchainStatusKHR_VkResult_return;
}

VkResult unmarshal_vkGetSwapchainStatusKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    VkResult unmarshal_vkGetSwapchainStatusKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void marshal_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalFenceInfo(vkStream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

void unmarshal_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
    unmarshal_VkPhysicalDeviceExternalFenceInfo(vkStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    unmarshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void marshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkImportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFence*)&forMarshaling->fence, sizeof(VkFence));
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFence*)&forUnmarshaling->fence, sizeof(VkFence));
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkExportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((const SECURITY_ATTRIBUTES**)&forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkExportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    const VkFenceGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFence*)&forMarshaling->fence, sizeof(VkFence));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFence*)&forUnmarshaling->fence, sizeof(VkFence));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

VkResult marshal_vkImportFenceWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportFenceWin32HandleInfoKHR(vkStream, (const VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
    VkResult marshal_vkImportFenceWin32HandleKHR_VkResult_return;
    vkStream->read(&marshal_vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult unmarshal_vkImportFenceWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
    unmarshal_VkImportFenceWin32HandleInfoKHR(vkStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
    VkResult unmarshal_vkImportFenceWin32HandleKHR_VkResult_return;
    vkStream->write(&unmarshal_vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult marshal_vkGetFenceWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceGetWin32HandleInfoKHR(vkStream, (const VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult marshal_vkGetFenceWin32HandleKHR_VkResult_return;
    vkStream->read(&marshal_vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetFenceWin32HandleKHR_VkResult_return;
}

VkResult unmarshal_vkGetFenceWin32HandleKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
    unmarshal_VkFenceGetWin32HandleInfoKHR(vkStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult unmarshal_vkGetFenceWin32HandleKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
void marshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    const VkImportFenceFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFence*)&forMarshaling->fence, sizeof(VkFence));
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportFenceFdInfoKHR(
    VulkanStream* vkStream,
    VkImportFenceFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFence*)&forUnmarshaling->fence, sizeof(VkFence));
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    const VkFenceGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkFence*)&forMarshaling->fence, sizeof(VkFence));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetFdInfoKHR(
    VulkanStream* vkStream,
    VkFenceGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkFence*)&forUnmarshaling->fence, sizeof(VkFence));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

VkResult marshal_vkImportFenceFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportFenceFdInfoKHR(vkStream, (const VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
    VkResult marshal_vkImportFenceFdKHR_VkResult_return;
    vkStream->read(&marshal_vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkImportFenceFdKHR_VkResult_return;
}

VkResult unmarshal_vkImportFenceFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
    unmarshal_VkImportFenceFdInfoKHR(vkStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
    VkResult unmarshal_vkImportFenceFdKHR_VkResult_return;
    vkStream->write(&unmarshal_vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkImportFenceFdKHR_VkResult_return;
}

VkResult marshal_vkGetFenceFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceGetFdInfoKHR(vkStream, (const VkFenceGetFdInfoKHR*)(pGetFdInfo));
    vkStream->read((int*)pFd, sizeof(int));
    VkResult marshal_vkGetFenceFdKHR_VkResult_return;
    vkStream->read(&marshal_vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetFenceFdKHR_VkResult_return;
}

VkResult unmarshal_vkGetFenceFdKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
    unmarshal_VkFenceGetFdInfoKHR(vkStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
    vkStream->write((int*)pFd, sizeof(int));
    VkResult unmarshal_vkGetFenceFdKHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void marshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSurfaceInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSurfaceKHR*)&forMarshaling->surface, sizeof(VkSurfaceKHR));
}

void unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStream* vkStream,
    VkPhysicalDeviceSurfaceInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSurfaceKHR*)&forUnmarshaling->surface, sizeof(VkSurfaceKHR));
}

void marshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    const VkSurfaceCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forMarshaling->surfaceCapabilities));
}

void unmarshal_VkSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forUnmarshaling->surfaceCapabilities));
}

void marshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    const VkSurfaceFormat2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forMarshaling->surfaceFormat));
}

void unmarshal_VkSurfaceFormat2KHR(
    VulkanStream* vkStream,
    VkSurfaceFormat2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forUnmarshaling->surfaceFormat));
}

VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(vkStream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
    unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    unmarshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult marshal_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(vkStream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    vkStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
    {
        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
    }
    VkResult marshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
    unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
    {
        unmarshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void marshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forMarshaling->displayProperties));
}

void unmarshal_VkDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forUnmarshaling->displayProperties));
}

void marshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forMarshaling->displayPlaneProperties));
}

void unmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forUnmarshaling->displayPlaneProperties));
}

void marshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    const VkDisplayModeProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forMarshaling->displayModeProperties));
}

void unmarshal_VkDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkDisplayModeProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forUnmarshaling->displayModeProperties));
}

void marshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDisplayModeKHR*)&forMarshaling->mode, sizeof(VkDisplayModeKHR));
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDisplayModeKHR*)&forUnmarshaling->mode, sizeof(VkDisplayModeKHR));
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
}

void marshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    const VkDisplayPlaneCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forMarshaling->capabilities));
}

void unmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkDisplayPlaneCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forUnmarshaling->capabilities));
}

VkResult marshal_vkGetPhysicalDeviceDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
    }
    VkResult marshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceDisplayProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult marshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
    }
    VkResult marshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult marshal_vkGetDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
    }
    VkResult marshal_vkGetDisplayModeProperties2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult unmarshal_vkGetDisplayModeProperties2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
    {
        unmarshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
    }
    VkResult unmarshal_vkGetDisplayModeProperties2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult marshal_vkGetDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDisplayPlaneInfo2KHR(vkStream, (const VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
    marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    VkResult marshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
    vkStream->read(&marshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

VkResult unmarshal_vkGetDisplayPlaneCapabilities2KHR(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
    unmarshal_VkDisplayPlaneInfo2KHR(vkStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
    unmarshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    VkResult unmarshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void marshal_vkGetImageMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageMemoryRequirementsInfo2(vkStream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void unmarshal_vkGetImageMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
    unmarshal_VkImageMemoryRequirementsInfo2(vkStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
    unmarshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void marshal_vkGetBufferMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferMemoryRequirementsInfo2(vkStream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void unmarshal_vkGetBufferMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
    unmarshal_VkBufferMemoryRequirementsInfo2(vkStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
    unmarshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void marshal_vkGetImageSparseMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageSparseMemoryRequirementsInfo2(vkStream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    vkStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
    }
}

void unmarshal_vkGetImageSparseMemoryRequirements2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
    unmarshal_VkImageSparseMemoryRequirementsInfo2(vkStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
    {
        unmarshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
    }
}

#endif
#ifdef VK_KHR_image_format_list
void marshal_VkImageFormatListCreateInfoKHR(
    VulkanStream* vkStream,
    const VkImageFormatListCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->write((const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
}

void unmarshal_VkImageFormatListCreateInfoKHR(
    VulkanStream* vkStream,
    VkImageFormatListCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
    vkStream->read((VkFormat*)forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult marshal_vkCreateSamplerYcbcrConversionKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerYcbcrConversionCreateInfo(vkStream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult marshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return;
    vkStream->read(&marshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

VkResult unmarshal_vkCreateSamplerYcbcrConversionKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
    unmarshal_VkSamplerYcbcrConversionCreateInfo(vkStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult unmarshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return;
    vkStream->write(&unmarshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void marshal_vkDestroySamplerYcbcrConversionKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroySamplerYcbcrConversionKHR(
    VulkanStream* vkStream,
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult marshal_vkBindBufferMemory2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(vkStream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult marshal_vkBindBufferMemory2KHR_VkResult_return;
    vkStream->read(&marshal_vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkBindBufferMemory2KHR_VkResult_return;
}

VkResult unmarshal_vkBindBufferMemory2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        unmarshal_VkBindBufferMemoryInfo(vkStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult unmarshal_vkBindBufferMemory2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindBufferMemory2KHR_VkResult_return;
}

VkResult marshal_vkBindImageMemory2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(vkStream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult marshal_vkBindImageMemory2KHR_VkResult_return;
    vkStream->read(&marshal_vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    return marshal_vkBindImageMemory2KHR_VkResult_return;
}

VkResult unmarshal_vkBindImageMemory2KHR(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        unmarshal_VkBindImageMemoryInfo(vkStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult unmarshal_vkBindImageMemory2KHR_VkResult_return;
    vkStream->write(&unmarshal_vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    return unmarshal_vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance3
void marshal_vkGetDescriptorSetLayoutSupportKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(vkStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

void unmarshal_vkGetDescriptorSetLayoutSupportKHR(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
    unmarshal_VkDescriptorSetLayoutCreateInfo(vkStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    unmarshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

#endif
#ifdef VK_KHR_draw_indirect_count
void marshal_vkCmdDrawIndirectCountKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndirectCountKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

void marshal_vkCmdDrawIndexedIndirectCountKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndexedIndirectCountKHR(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_8bit_storage
void marshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStream* vkStream,
    const VkPhysicalDevice8BitStorageFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStream* vkStream,
    VkPhysicalDevice8BitStorageFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant8, sizeof(VkBool32));
}

#endif
#ifdef VK_EXT_debug_report
void marshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDebugReportCallbackCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDebugReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    vkStream->write((PFN_vkDebugReportCallbackEXT*)&forMarshaling->pfnCallback, sizeof(PFN_vkDebugReportCallbackEXT));
    vkStream->write((void**)&forMarshaling->pUserData, sizeof(void*));
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugReportCallbackCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDebugReportFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    vkStream->read((PFN_vkDebugReportCallbackEXT*)&forUnmarshaling->pfnCallback, sizeof(PFN_vkDebugReportCallbackEXT));
    vkStream->read((void**)&forUnmarshaling->pUserData, sizeof(void*));
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

VkResult marshal_vkCreateDebugReportCallbackEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDebugReportCallbackCreateInfoEXT(vkStream, (const VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
    VkResult marshal_vkCreateDebugReportCallbackEXT_VkResult_return;
    vkStream->read(&marshal_vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDebugReportCallbackEXT_VkResult_return;
}

VkResult unmarshal_vkCreateDebugReportCallbackEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
    unmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
    VkResult unmarshal_vkCreateDebugReportCallbackEXT_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDebugReportCallbackEXT_VkResult_return;
}

void marshal_vkDestroyDebugReportCallbackEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((VkDebugReportCallbackEXT*)&callback, sizeof(VkDebugReportCallbackEXT));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDebugReportCallbackEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkDebugReportCallbackEXT*)&callback, sizeof(VkDebugReportCallbackEXT));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_vkDebugReportMessageEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
    vkStream->write((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&object, sizeof(uint64_t));
    vkStream->write((size_t*)&location, sizeof(size_t));
    vkStream->write((int32_t*)&messageCode, sizeof(int32_t));
    vkStream->putString(pLayerPrefix);
    vkStream->putString(pMessage);
}

void unmarshal_vkDebugReportMessageEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
    vkStream->read((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&object, sizeof(uint64_t));
    vkStream->read((size_t*)&location, sizeof(size_t));
    vkStream->read((int32_t*)&messageCode, sizeof(int32_t));
    vkStream->loadStringInPlace((char**)&pLayerPrefix);
    vkStream->loadStringInPlace((char**)&pMessage);
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void marshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    const VkPipelineRasterizationStateRasterizationOrderAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkRasterizationOrderAMD*)&forMarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

void unmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStream* vkStream,
    VkPipelineRasterizationStateRasterizationOrderAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkRasterizationOrderAMD*)&forUnmarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void marshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->putString(forMarshaling->pObjectName);
}

void unmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
}

void marshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    vkStream->write((size_t*)&forMarshaling->tagSize, sizeof(size_t));
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    vkStream->read((size_t*)&forUnmarshaling->tagSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

void marshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    const VkDebugMarkerMarkerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->putString(forMarshaling->pMarkerName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStream* vkStream,
    VkDebugMarkerMarkerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMarkerName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

VkResult marshal_vkDebugMarkerSetObjectTagEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugMarkerObjectTagInfoEXT(vkStream, (const VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
    VkResult marshal_vkDebugMarkerSetObjectTagEXT_VkResult_return;
    vkStream->read(&marshal_vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult unmarshal_vkDebugMarkerSetObjectTagEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
    unmarshal_VkDebugMarkerObjectTagInfoEXT(vkStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
    VkResult unmarshal_vkDebugMarkerSetObjectTagEXT_VkResult_return;
    vkStream->write(&unmarshal_vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult marshal_vkDebugMarkerSetObjectNameEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugMarkerObjectNameInfoEXT(vkStream, (const VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
    VkResult marshal_vkDebugMarkerSetObjectNameEXT_VkResult_return;
    vkStream->read(&marshal_vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

VkResult unmarshal_vkDebugMarkerSetObjectNameEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
    unmarshal_VkDebugMarkerObjectNameInfoEXT(vkStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
    VkResult unmarshal_vkDebugMarkerSetObjectNameEXT_VkResult_return;
    vkStream->write(&unmarshal_vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void marshal_vkCmdDebugMarkerBeginEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugMarkerMarkerInfoEXT(vkStream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

void unmarshal_vkCmdDebugMarkerBeginEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
    unmarshal_VkDebugMarkerMarkerInfoEXT(vkStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

void marshal_vkCmdDebugMarkerEndEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void unmarshal_vkCmdDebugMarkerEndEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void marshal_vkCmdDebugMarkerInsertEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugMarkerMarkerInfoEXT(vkStream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

void unmarshal_vkCmdDebugMarkerInsertEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
    unmarshal_VkDebugMarkerMarkerInfoEXT(vkStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void marshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationBufferCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationBufferCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    const VkDedicatedAllocationMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkImage*)&forMarshaling->image, sizeof(VkImage));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
}

void unmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkDedicatedAllocationMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkImage*)&forUnmarshaling->image, sizeof(VkImage));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
}

#endif
#ifdef VK_AMD_draw_indirect_count
void marshal_vkCmdDrawIndirectCountAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndirectCountAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

void marshal_vkCmdDrawIndexedIndirectCountAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void unmarshal_vkCmdDrawIndexedIndirectCountAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    vkStream->read((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&stride, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void marshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    const VkTextureLODGatherFormatPropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

void unmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStream* vkStream,
    VkTextureLODGatherFormatPropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

#endif
#ifdef VK_AMD_shader_info
void marshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    const VkShaderResourceUsageAMD* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    vkStream->write((size_t*)&forMarshaling->ldsUsageSizeInBytes, sizeof(size_t));
    vkStream->write((size_t*)&forMarshaling->scratchMemUsageInBytes, sizeof(size_t));
}

void unmarshal_VkShaderResourceUsageAMD(
    VulkanStream* vkStream,
    VkShaderResourceUsageAMD* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    vkStream->read((size_t*)&forUnmarshaling->ldsUsageSizeInBytes, sizeof(size_t));
    vkStream->read((size_t*)&forUnmarshaling->scratchMemUsageInBytes, sizeof(size_t));
}

void marshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    const VkShaderStatisticsInfoAMD* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    marshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forMarshaling->resourceUsage));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

void unmarshal_VkShaderStatisticsInfoAMD(
    VulkanStream* vkStream,
    VkShaderStatisticsInfoAMD* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    unmarshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forUnmarshaling->resourceUsage));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

VkResult marshal_vkGetShaderInfoAMD(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
    vkStream->write((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
    vkStream->write((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
    vkStream->read((size_t*)pInfoSize, sizeof(size_t));
    vkStream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    VkResult marshal_vkGetShaderInfoAMD_VkResult_return;
    vkStream->read(&marshal_vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    return marshal_vkGetShaderInfoAMD_VkResult_return;
}

VkResult unmarshal_vkGetShaderInfoAMD(
    VulkanStream* vkStream,
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkPipeline*)&pipeline, sizeof(VkPipeline));
    vkStream->read((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
    vkStream->read((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
    vkStream->write((size_t*)pInfoSize, sizeof(size_t));
    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    VkResult unmarshal_vkGetShaderInfoAMD_VkResult_return;
    vkStream->write(&unmarshal_vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void marshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    const VkExternalImageFormatPropertiesNV* forMarshaling)
{
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
    vkStream->write((VkExternalMemoryFeatureFlagsNV*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkExternalImageFormatPropertiesNV* forUnmarshaling)
{
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
    vkStream->read((VkExternalMemoryFeatureFlagsNV*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

VkResult marshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkFormat*)&format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&type, sizeof(VkImageType));
    vkStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    VkResult marshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkFormat*)&format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&type, sizeof(VkImageType));
    vkStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    unmarshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    VkResult unmarshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
void marshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    const VkExternalMemoryImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStream* vkStream,
    VkExternalMemoryImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void marshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    const VkExportMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

#endif
#ifdef VK_NV_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    const VkImportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
}

void unmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkImportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
}

void marshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    const VkExportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((const SECURITY_ATTRIBUTES**)&forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
}

void unmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStream* vkStream,
    VkExportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((SECURITY_ATTRIBUTES**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES*));
    if (forUnmarshaling->pAttributes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
}

VkResult marshal_vkGetMemoryWin32HandleNV(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult marshal_vkGetMemoryWin32HandleNV_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryWin32HandleNV_VkResult_return;
}

VkResult unmarshal_vkGetMemoryWin32HandleNV(
    VulkanStream* vkStream,
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult unmarshal_vkGetMemoryWin32HandleNV_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    vkStream->write((const VkDeviceMemory*)forMarshaling->pAcquireSyncs, forMarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeoutMilliseconds, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    vkStream->write((const VkDeviceMemory*)forMarshaling->pReleaseSyncs, forMarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStream* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->read((VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount * sizeof(const VkDeviceMemory));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->alloc((void**)&forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->read((VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount * sizeof(const VkDeviceMemory));
    vkStream->alloc((void**)&forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_EXT_validation_flags
void marshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    const VkValidationFlagsEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->write((const VkValidationCheckEXT*)forMarshaling->pDisabledValidationChecks, forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

void unmarshal_VkValidationFlagsEXT(
    VulkanStream* vkStream,
    VkValidationFlagsEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    vkStream->read((VkValidationCheckEXT*)forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

#endif
#ifdef VK_NN_vi_surface
void marshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    const VkViSurfaceCreateInfoNN* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkViSurfaceCreateFlagsNN*)&forMarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    vkStream->write((void**)&forMarshaling->window, sizeof(void*));
    if (forMarshaling->window)
    {
        vkStream->write((void*)forMarshaling->window, sizeof(uint8_t));
    }
}

void unmarshal_VkViSurfaceCreateInfoNN(
    VulkanStream* vkStream,
    VkViSurfaceCreateInfoNN* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkViSurfaceCreateFlagsNN*)&forUnmarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    vkStream->read((void**)&forUnmarshaling->window, sizeof(void*));
    if (forUnmarshaling->window)
    {
        vkStream->alloc((void**)&forUnmarshaling->window, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->window, sizeof(uint8_t));
    }
}

VkResult marshal_vkCreateViSurfaceNN(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkViSurfaceCreateInfoNN(vkStream, (const VkViSurfaceCreateInfoNN*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateViSurfaceNN_VkResult_return;
    vkStream->read(&marshal_vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateViSurfaceNN_VkResult_return;
}

VkResult unmarshal_vkCreateViSurfaceNN(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
    unmarshal_VkViSurfaceCreateInfoNN(vkStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateViSurfaceNN_VkResult_return;
    vkStream->write(&unmarshal_vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void marshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    const VkConditionalRenderingBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkConditionalRenderingFlagsEXT*)&forMarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void unmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStream* vkStream,
    VkConditionalRenderingBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkConditionalRenderingFlagsEXT*)&forUnmarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void marshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void marshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

void unmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStream* vkStream,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

void marshal_vkCmdBeginConditionalRenderingEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkConditionalRenderingBeginInfoEXT(vkStream, (const VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
}

void unmarshal_vkCmdBeginConditionalRenderingEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
    unmarshal_VkConditionalRenderingBeginInfoEXT(vkStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
}

void marshal_vkCmdEndConditionalRenderingEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void unmarshal_vkCmdEndConditionalRenderingEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

#endif
#ifdef VK_NVX_device_generated_commands
void marshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStream* vkStream,
    const VkDeviceGeneratedCommandsFeaturesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->computeBindingPointSupport, sizeof(VkBool32));
}

void unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStream* vkStream,
    VkDeviceGeneratedCommandsFeaturesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->computeBindingPointSupport, sizeof(VkBool32));
}

void marshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStream* vkStream,
    const VkDeviceGeneratedCommandsLimitsNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsLayoutTokenCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxObjectEntryCounts, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequenceCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequenceIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minCommandsTokenBufferOffsetAlignment, sizeof(uint32_t));
}

void unmarshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStream* vkStream,
    VkDeviceGeneratedCommandsLimitsNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsLayoutTokenCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxObjectEntryCounts, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequenceCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequenceIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minCommandsTokenBufferOffsetAlignment, sizeof(uint32_t));
}

void marshal_VkIndirectCommandsTokenNVX(
    VulkanStream* vkStream,
    const VkIndirectCommandsTokenNVX* forMarshaling)
{
    vkStream->write((VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
}

void unmarshal_VkIndirectCommandsTokenNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsTokenNVX* forUnmarshaling)
{
    vkStream->read((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
}

void marshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStream* vkStream,
    const VkIndirectCommandsLayoutTokenNVX* forMarshaling)
{
    vkStream->write((VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->write((uint32_t*)&forMarshaling->bindingUnit, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dynamicCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
}

void unmarshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutTokenNVX* forUnmarshaling)
{
    vkStream->read((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->bindingUnit, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dynamicCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->divisor, sizeof(uint32_t));
}

void marshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStream* vkStream,
    const VkIndirectCommandsLayoutCreateInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkIndirectCommandsLayoutUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    vkStream->write((uint32_t*)&forMarshaling->tokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->tokenCount; ++i)
    {
        marshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (const VkIndirectCommandsLayoutTokenNVX*)(forMarshaling->pTokens + i));
    }
}

void unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStream* vkStream,
    VkIndirectCommandsLayoutCreateInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkIndirectCommandsLayoutUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->tokenCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pTokens, forUnmarshaling->tokenCount * sizeof(const VkIndirectCommandsLayoutTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->tokenCount; ++i)
    {
        unmarshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (VkIndirectCommandsLayoutTokenNVX*)(forUnmarshaling->pTokens + i));
    }
}

void marshal_VkCmdProcessCommandsInfoNVX(
    VulkanStream* vkStream,
    const VkCmdProcessCommandsInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkObjectTableNVX*)&forMarshaling->objectTable, sizeof(VkObjectTableNVX));
    vkStream->write((VkIndirectCommandsLayoutNVX*)&forMarshaling->indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->write((uint32_t*)&forMarshaling->indirectCommandsTokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->indirectCommandsTokenCount; ++i)
    {
        marshal_VkIndirectCommandsTokenNVX(vkStream, (const VkIndirectCommandsTokenNVX*)(forMarshaling->pIndirectCommandsTokens + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
    vkStream->write((VkCommandBuffer*)&forMarshaling->targetCommandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkBuffer*)&forMarshaling->sequencesCountBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    vkStream->write((VkBuffer*)&forMarshaling->sequencesIndexBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkCmdProcessCommandsInfoNVX(
    VulkanStream* vkStream,
    VkCmdProcessCommandsInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkObjectTableNVX*)&forUnmarshaling->objectTable, sizeof(VkObjectTableNVX));
    vkStream->read((VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->indirectCommandsTokenCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pIndirectCommandsTokens, forUnmarshaling->indirectCommandsTokenCount * sizeof(const VkIndirectCommandsTokenNVX));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->indirectCommandsTokenCount; ++i)
    {
        unmarshal_VkIndirectCommandsTokenNVX(vkStream, (VkIndirectCommandsTokenNVX*)(forUnmarshaling->pIndirectCommandsTokens + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxSequencesCount, sizeof(uint32_t));
    vkStream->read((VkCommandBuffer*)&forUnmarshaling->targetCommandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkBuffer*)&forUnmarshaling->sequencesCountBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    vkStream->read((VkBuffer*)&forUnmarshaling->sequencesIndexBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void marshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStream* vkStream,
    const VkCmdReserveSpaceForCommandsInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkObjectTableNVX*)&forMarshaling->objectTable, sizeof(VkObjectTableNVX));
    vkStream->write((VkIndirectCommandsLayoutNVX*)&forMarshaling->indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->write((uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
}

void unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStream* vkStream,
    VkCmdReserveSpaceForCommandsInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkObjectTableNVX*)&forUnmarshaling->objectTable, sizeof(VkObjectTableNVX));
    vkStream->read((VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSequencesCount, sizeof(uint32_t));
}

void marshal_VkObjectTableCreateInfoNVX(
    VulkanStream* vkStream,
    const VkObjectTableCreateInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    vkStream->write((const VkObjectEntryTypeNVX*)forMarshaling->pObjectEntryTypes, forMarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    vkStream->write((const uint32_t*)forMarshaling->pObjectEntryCounts, forMarshaling->objectCount * sizeof(const uint32_t));
    vkStream->write((const VkObjectEntryUsageFlagsNVX*)forMarshaling->pObjectEntryUsageFlags, forMarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    vkStream->write((uint32_t*)&forMarshaling->maxUniformBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageImagesPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSampledImagesPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPipelineLayouts, sizeof(uint32_t));
}

void unmarshal_VkObjectTableCreateInfoNVX(
    VulkanStream* vkStream,
    VkObjectTableCreateInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->objectCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryTypes, forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryTypeNVX*)forUnmarshaling->pObjectEntryTypes, forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryCounts, forUnmarshaling->objectCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pObjectEntryCounts, forUnmarshaling->objectCount * sizeof(const uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pObjectEntryUsageFlags, forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)forUnmarshaling->pObjectEntryUsageFlags, forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUniformBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageImagesPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSampledImagesPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPipelineLayouts, sizeof(uint32_t));
}

void marshal_VkObjectTableEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTableEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
}

void unmarshal_VkObjectTableEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
}

void marshal_VkObjectTablePipelineEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTablePipelineEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->write((VkPipeline*)&forMarshaling->pipeline, sizeof(VkPipeline));
}

void unmarshal_VkObjectTablePipelineEntryNVX(
    VulkanStream* vkStream,
    VkObjectTablePipelineEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkPipeline*)&forUnmarshaling->pipeline, sizeof(VkPipeline));
}

void marshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTableDescriptorSetEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->write((VkPipelineLayout*)&forMarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->write((VkDescriptorSet*)&forMarshaling->descriptorSet, sizeof(VkDescriptorSet));
}

void unmarshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableDescriptorSetEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkPipelineLayout*)&forUnmarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->read((VkDescriptorSet*)&forUnmarshaling->descriptorSet, sizeof(VkDescriptorSet));
}

void marshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTableVertexBufferEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
}

void unmarshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableVertexBufferEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
}

void marshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTableIndexBufferEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->write((VkBuffer*)&forMarshaling->buffer, sizeof(VkBuffer));
    vkStream->write((VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
}

void unmarshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStream* vkStream,
    VkObjectTableIndexBufferEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkBuffer*)&forUnmarshaling->buffer, sizeof(VkBuffer));
    vkStream->read((VkIndexType*)&forUnmarshaling->indexType, sizeof(VkIndexType));
}

void marshal_VkObjectTablePushConstantEntryNVX(
    VulkanStream* vkStream,
    const VkObjectTablePushConstantEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->write((VkPipelineLayout*)&forMarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
}

void unmarshal_VkObjectTablePushConstantEntryNVX(
    VulkanStream* vkStream,
    VkObjectTablePushConstantEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    vkStream->read((VkPipelineLayout*)&forUnmarshaling->pipelineLayout, sizeof(VkPipelineLayout));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
}

void marshal_vkCmdProcessCommandsNVX(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCmdProcessCommandsInfoNVX(vkStream, (const VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
}

void unmarshal_vkCmdProcessCommandsNVX(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
    unmarshal_VkCmdProcessCommandsInfoNVX(vkStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
}

void marshal_vkCmdReserveSpaceForCommandsNVX(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCmdReserveSpaceForCommandsInfoNVX(vkStream, (const VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
}

void unmarshal_vkCmdReserveSpaceForCommandsNVX(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
    unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
}

VkResult marshal_vkCreateIndirectCommandsLayoutNVX(
    VulkanStream* vkStream,
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkIndirectCommandsLayoutCreateInfoNVX(vkStream, (const VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    VkResult marshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return;
    vkStream->read(&marshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

VkResult unmarshal_vkCreateIndirectCommandsLayoutNVX(
    VulkanStream* vkStream,
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
    unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    VkResult unmarshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return;
    vkStream->write(&unmarshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

void marshal_vkDestroyIndirectCommandsLayoutNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyIndirectCommandsLayoutNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkCreateObjectTableNVX(
    VulkanStream* vkStream,
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkObjectTableCreateInfoNVX(vkStream, (const VkObjectTableCreateInfoNVX*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
    VkResult marshal_vkCreateObjectTableNVX_VkResult_return;
    vkStream->read(&marshal_vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateObjectTableNVX_VkResult_return;
}

VkResult unmarshal_vkCreateObjectTableNVX(
    VulkanStream* vkStream,
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
    unmarshal_VkObjectTableCreateInfoNVX(vkStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
    VkResult unmarshal_vkCreateObjectTableNVX_VkResult_return;
    vkStream->write(&unmarshal_vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateObjectTableNVX_VkResult_return;
}

void marshal_vkDestroyObjectTableNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyObjectTableNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkRegisterObjectsNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->write((uint32_t*)&objectCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult marshal_vkRegisterObjectsNVX_VkResult_return;
    vkStream->read(&marshal_vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return marshal_vkRegisterObjectsNVX_VkResult_return;
}

VkResult unmarshal_vkRegisterObjectsNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    vkStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult unmarshal_vkRegisterObjectsNVX_VkResult_return;
    vkStream->write(&unmarshal_vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return unmarshal_vkRegisterObjectsNVX_VkResult_return;
}

VkResult marshal_vkUnregisterObjectsNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->write((uint32_t*)&objectCount, sizeof(uint32_t));
    vkStream->write((const VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    vkStream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult marshal_vkUnregisterObjectsNVX_VkResult_return;
    vkStream->read(&marshal_vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return marshal_vkUnregisterObjectsNVX_VkResult_return;
}

VkResult unmarshal_vkUnregisterObjectsNVX(
    VulkanStream* vkStream,
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    vkStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    vkStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    vkStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult unmarshal_vkUnregisterObjectsNVX_VkResult_return;
    vkStream->write(&unmarshal_vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return unmarshal_vkUnregisterObjectsNVX_VkResult_return;
}

void marshal_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
}

void unmarshal_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    unmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void marshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    const VkViewportWScalingNV* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->xcoeff, sizeof(float));
    vkStream->write((float*)&forMarshaling->ycoeff, sizeof(float));
}

void unmarshal_VkViewportWScalingNV(
    VulkanStream* vkStream,
    VkViewportWScalingNV* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->xcoeff, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->ycoeff, sizeof(float));
}

void marshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportWScalingStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    vkStream->write((const VkViewportWScalingNV**)&forMarshaling->pViewportWScalings, sizeof(const VkViewportWScalingNV*));
    if (forMarshaling->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportWScalingNV(vkStream, (const VkViewportWScalingNV*)(forMarshaling->pViewportWScalings + i));
        }
    }
}

void unmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportWScalingStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    vkStream->read((VkViewportWScalingNV**)&forUnmarshaling->pViewportWScalings, sizeof(const VkViewportWScalingNV*));
    if (forUnmarshaling->pViewportWScalings)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportWScalings, forUnmarshaling->viewportCount * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportWScalingNV(vkStream, (VkViewportWScalingNV*)(forUnmarshaling->pViewportWScalings + i));
        }
    }
}

void marshal_vkCmdSetViewportWScalingNV(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
    vkStream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewportWScalingNV(vkStream, (const VkViewportWScalingNV*)(pViewportWScalings + i));
    }
}

void unmarshal_vkCmdSetViewportWScalingNV(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
    vkStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        unmarshal_VkViewportWScalingNV(vkStream, (VkViewportWScalingNV*)(pViewportWScalings + i));
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult marshal_vkReleaseDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    VkResult marshal_vkReleaseDisplayEXT_VkResult_return;
    vkStream->read(&marshal_vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkReleaseDisplayEXT_VkResult_return;
}

VkResult unmarshal_vkReleaseDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    VkResult unmarshal_vkReleaseDisplayEXT_VkResult_return;
    vkStream->write(&unmarshal_vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult marshal_vkAcquireXlibDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((Display*)dpy, sizeof(Display));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    VkResult marshal_vkAcquireXlibDisplayEXT_VkResult_return;
    vkStream->read(&marshal_vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult unmarshal_vkAcquireXlibDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((Display*)dpy, sizeof(Display));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    VkResult unmarshal_vkAcquireXlibDisplayEXT_VkResult_return;
    vkStream->write(&unmarshal_vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult marshal_vkGetRandROutputDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((Display*)dpy, sizeof(Display));
    vkStream->write((RROutput*)&rrOutput, sizeof(RROutput));
    vkStream->read((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
    VkResult marshal_vkGetRandROutputDisplayEXT_VkResult_return;
    vkStream->read(&marshal_vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkGetRandROutputDisplayEXT_VkResult_return;
}

VkResult unmarshal_vkGetRandROutputDisplayEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((Display*)dpy, sizeof(Display));
    vkStream->read((RROutput*)&rrOutput, sizeof(RROutput));
    vkStream->write((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
    VkResult unmarshal_vkGetRandROutputDisplayEXT_VkResult_return;
    vkStream->write(&unmarshal_vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
void marshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    const VkSurfaceCapabilities2EXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkSurfaceCapabilities2EXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    VkResult marshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
    vkStream->read(&marshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    unmarshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    VkResult unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
    vkStream->write(&unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
void marshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    const VkDisplayPowerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDisplayPowerStateEXT*)&forMarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void unmarshal_VkDisplayPowerInfoEXT(
    VulkanStream* vkStream,
    VkDisplayPowerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDisplayPowerStateEXT*)&forUnmarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void marshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    const VkDeviceEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceEventTypeEXT*)&forMarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void unmarshal_VkDeviceEventInfoEXT(
    VulkanStream* vkStream,
    VkDeviceEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceEventTypeEXT*)&forUnmarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void marshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    const VkDisplayEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDisplayEventTypeEXT*)&forMarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void unmarshal_VkDisplayEventInfoEXT(
    VulkanStream* vkStream,
    VkDisplayEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDisplayEventTypeEXT*)&forUnmarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void marshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    const VkSwapchainCounterCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStream* vkStream,
    VkSwapchainCounterCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

VkResult marshal_vkDisplayPowerControlEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayPowerInfoEXT(vkStream, (const VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
    VkResult marshal_vkDisplayPowerControlEXT_VkResult_return;
    vkStream->read(&marshal_vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkDisplayPowerControlEXT_VkResult_return;
}

VkResult unmarshal_vkDisplayPowerControlEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
    unmarshal_VkDisplayPowerInfoEXT(vkStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
    VkResult unmarshal_vkDisplayPowerControlEXT_VkResult_return;
    vkStream->write(&unmarshal_vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkDisplayPowerControlEXT_VkResult_return;
}

VkResult marshal_vkRegisterDeviceEventEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceEventInfoEXT(vkStream, (const VkDeviceEventInfoEXT*)(pDeviceEventInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult marshal_vkRegisterDeviceEventEXT_VkResult_return;
    vkStream->read(&marshal_vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult unmarshal_vkRegisterDeviceEventEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
    unmarshal_VkDeviceEventInfoEXT(vkStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkFence*)pFence, sizeof(VkFence));
    VkResult unmarshal_vkRegisterDeviceEventEXT_VkResult_return;
    vkStream->write(&unmarshal_vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult marshal_vkRegisterDisplayEventEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayEventInfoEXT(vkStream, (const VkDisplayEventInfoEXT*)(pDisplayEventInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult marshal_vkRegisterDisplayEventEXT_VkResult_return;
    vkStream->read(&marshal_vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult unmarshal_vkRegisterDisplayEventEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    vkStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
    unmarshal_VkDisplayEventInfoEXT(vkStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkFence*)pFence, sizeof(VkFence));
    VkResult unmarshal_vkRegisterDisplayEventEXT_VkResult_return;
    vkStream->write(&unmarshal_vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult marshal_vkGetSwapchainCounterEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    vkStream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult marshal_vkGetSwapchainCounterEXT_VkResult_return;
    vkStream->read(&marshal_vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkGetSwapchainCounterEXT_VkResult_return;
}

VkResult unmarshal_vkGetSwapchainCounterEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult unmarshal_vkGetSwapchainCounterEXT_VkResult_return;
    vkStream->write(&unmarshal_vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
void marshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    const VkRefreshCycleDurationGOOGLE* forMarshaling)
{
    vkStream->write((uint64_t*)&forMarshaling->refreshDuration, sizeof(uint64_t));
}

void unmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkRefreshCycleDurationGOOGLE* forUnmarshaling)
{
    vkStream->read((uint64_t*)&forUnmarshaling->refreshDuration, sizeof(uint64_t));
}

void marshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    const VkPastPresentationTimingGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->presentMargin, sizeof(uint64_t));
}

void unmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkPastPresentationTimingGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->presentMargin, sizeof(uint64_t));
}

void marshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    const VkPresentTimeGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
}

void unmarshal_VkPresentTimeGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimeGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
}

void marshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    const VkPresentTimesInfoGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const VkPresentTimeGOOGLE**)&forMarshaling->pTimes, sizeof(const VkPresentTimeGOOGLE*));
    if (forMarshaling->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentTimeGOOGLE(vkStream, (const VkPresentTimeGOOGLE*)(forMarshaling->pTimes + i));
        }
    }
}

void unmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStream* vkStream,
    VkPresentTimesInfoGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->read((VkPresentTimeGOOGLE**)&forUnmarshaling->pTimes, sizeof(const VkPresentTimeGOOGLE*));
    if (forUnmarshaling->pTimes)
    {
        vkStream->alloc((void**)&forUnmarshaling->pTimes, forUnmarshaling->swapchainCount * sizeof(const VkPresentTimeGOOGLE));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentTimeGOOGLE(vkStream, (VkPresentTimeGOOGLE*)(forUnmarshaling->pTimes + i));
        }
    }
}

VkResult marshal_vkGetRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    VkResult marshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return;
    vkStream->read(&marshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    return marshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult unmarshal_vkGetRefreshCycleDurationGOOGLE(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    unmarshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    VkResult unmarshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return;
    vkStream->write(&unmarshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult marshal_vkGetPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
    {
        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
    }
    VkResult marshal_vkGetPastPresentationTimingGOOGLE_VkResult_return;
    vkStream->read(&marshal_vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    return marshal_vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

VkResult unmarshal_vkGetPastPresentationTimingGOOGLE(
    VulkanStream* vkStream,
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
    {
        unmarshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
    }
    VkResult unmarshal_vkGetPastPresentationTimingGOOGLE_VkResult_return;
    vkStream->write(&unmarshal_vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void marshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStream* vkStream,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_viewport_swizzle
void marshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    const VkViewportSwizzleNV* forMarshaling)
{
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void unmarshal_VkViewportSwizzleNV(
    VulkanStream* vkStream,
    VkViewportSwizzleNV* forUnmarshaling)
{
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void marshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineViewportSwizzleStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    vkStream->write((const VkViewportSwizzleNV**)&forMarshaling->pViewportSwizzles, sizeof(const VkViewportSwizzleNV*));
    if (forMarshaling->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportSwizzleNV(vkStream, (const VkViewportSwizzleNV*)(forMarshaling->pViewportSwizzles + i));
        }
    }
}

void unmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineViewportSwizzleStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    vkStream->read((VkViewportSwizzleNV**)&forUnmarshaling->pViewportSwizzles, sizeof(const VkViewportSwizzleNV*));
    if (forUnmarshaling->pViewportSwizzles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pViewportSwizzles, forUnmarshaling->viewportCount * sizeof(const VkViewportSwizzleNV));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportSwizzleNV(vkStream, (VkViewportSwizzleNV*)(forUnmarshaling->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void marshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void marshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->write((VkDiscardRectangleModeEXT*)&forMarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->write((uint32_t*)&forMarshaling->discardRectangleCount, sizeof(uint32_t));
    vkStream->write((const VkRect2D**)&forMarshaling->pDiscardRectangles, sizeof(const VkRect2D*));
    if (forMarshaling->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->discardRectangleCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDiscardRectangles + i));
        }
    }
}

void unmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineDiscardRectangleStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->read((VkDiscardRectangleModeEXT*)&forUnmarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->read((uint32_t*)&forUnmarshaling->discardRectangleCount, sizeof(uint32_t));
    vkStream->read((VkRect2D**)&forUnmarshaling->pDiscardRectangles, sizeof(const VkRect2D*));
    if (forUnmarshaling->pDiscardRectangles)
    {
        vkStream->alloc((void**)&forUnmarshaling->pDiscardRectangles, forUnmarshaling->discardRectangleCount * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->discardRectangleCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDiscardRectangles + i));
        }
    }
}

void marshal_vkCmdSetDiscardRectangleEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
    vkStream->write((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(pDiscardRectangles + i));
    }
}

void unmarshal_vkCmdSetDiscardRectangleEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
    vkStream->read((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(pDiscardRectangles + i));
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void marshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((float*)&forMarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((float*)&forUnmarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void marshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->write((VkConservativeRasterizationModeEXT*)&forMarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

void unmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->read((VkConservativeRasterizationModeEXT*)&forUnmarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void marshal_VkXYColorEXT(
    VulkanStream* vkStream,
    const VkXYColorEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkXYColorEXT(
    VulkanStream* vkStream,
    VkXYColorEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    const VkHdrMetadataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryRed));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryGreen));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryBlue));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->whitePoint));
    vkStream->write((float*)&forMarshaling->maxLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->minLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxContentLightLevel, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxFrameAverageLightLevel, sizeof(float));
}

void unmarshal_VkHdrMetadataEXT(
    VulkanStream* vkStream,
    VkHdrMetadataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryRed));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryGreen));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryBlue));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->whitePoint));
    vkStream->read((float*)&forUnmarshaling->maxLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxContentLightLevel, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxFrameAverageLightLevel, sizeof(float));
}

void marshal_vkSetHdrMetadataEXT(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
    vkStream->write((const VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkHdrMetadataEXT(vkStream, (const VkHdrMetadataEXT*)(pMetadata + i));
    }
}

void unmarshal_vkSetHdrMetadataEXT(
    VulkanStream* vkStream,
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    vkStream->read((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    vkStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        unmarshal_VkHdrMetadataEXT(vkStream, (VkHdrMetadataEXT*)(pMetadata + i));
    }
}

#endif
#ifdef VK_MVK_ios_surface
void marshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    const VkIOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkIOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    vkStream->write((const void**)&forMarshaling->pView, sizeof(const void*));
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkIOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkIOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    vkStream->read((void**)&forUnmarshaling->pView, sizeof(const void*));
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

VkResult marshal_vkCreateIOSSurfaceMVK(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkIOSSurfaceCreateInfoMVK(vkStream, (const VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateIOSSurfaceMVK_VkResult_return;
    vkStream->read(&marshal_vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateIOSSurfaceMVK_VkResult_return;
}

VkResult unmarshal_vkCreateIOSSurfaceMVK(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
    unmarshal_VkIOSSurfaceCreateInfoMVK(vkStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateIOSSurfaceMVK_VkResult_return;
    vkStream->write(&unmarshal_vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
void marshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    const VkMacOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkMacOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    vkStream->write((const void**)&forMarshaling->pView, sizeof(const void*));
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStream* vkStream,
    VkMacOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkMacOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    vkStream->read((void**)&forUnmarshaling->pView, sizeof(const void*));
    if (forUnmarshaling->pView)
    {
        vkStream->alloc((void**)&forUnmarshaling->pView, sizeof(const uint8_t));
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

VkResult marshal_vkCreateMacOSSurfaceMVK(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkMacOSSurfaceCreateInfoMVK(vkStream, (const VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult marshal_vkCreateMacOSSurfaceMVK_VkResult_return;
    vkStream->read(&marshal_vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateMacOSSurfaceMVK_VkResult_return;
}

VkResult unmarshal_vkCreateMacOSSurfaceMVK(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
    unmarshal_VkMacOSSurfaceCreateInfoMVK(vkStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult unmarshal_vkCreateMacOSSurfaceMVK_VkResult_return;
    vkStream->write(&unmarshal_vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void marshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->putString(forMarshaling->pObjectName);
}

void unmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
}

void marshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    vkStream->write((size_t*)&forMarshaling->tagSize, sizeof(size_t));
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    vkStream->read((size_t*)&forUnmarshaling->tagSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

void marshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsLabelEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->putString(forMarshaling->pLabelName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkDebugUtilsLabelEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pLabelName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

void marshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsMessengerCallbackDataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    vkStream->putString(forMarshaling->pMessageIdName);
    vkStream->write((int32_t*)&forMarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->putString(forMarshaling->pMessage);
    vkStream->write((uint32_t*)&forMarshaling->queueLabelCount, sizeof(uint32_t));
    vkStream->write((VkDebugUtilsLabelEXT**)&forMarshaling->pQueueLabels, sizeof(VkDebugUtilsLabelEXT*));
    if (forMarshaling->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pQueueLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->cmdBufLabelCount, sizeof(uint32_t));
    vkStream->write((VkDebugUtilsLabelEXT**)&forMarshaling->pCmdBufLabels, sizeof(VkDebugUtilsLabelEXT*));
    if (forMarshaling->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->cmdBufLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    vkStream->write((VkDebugUtilsObjectNameInfoEXT**)&forMarshaling->pObjects, sizeof(VkDebugUtilsObjectNameInfoEXT*));
    if (forMarshaling->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->objectCount; ++i)
        {
            marshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forMarshaling->pObjects + i));
        }
    }
}

void unmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCallbackDataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessageIdName);
    vkStream->read((int32_t*)&forUnmarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessage);
    vkStream->read((uint32_t*)&forUnmarshaling->queueLabelCount, sizeof(uint32_t));
    vkStream->read((VkDebugUtilsLabelEXT**)&forUnmarshaling->pQueueLabels, sizeof(VkDebugUtilsLabelEXT*));
    if (forUnmarshaling->pQueueLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pQueueLabels, forUnmarshaling->queueLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pQueueLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->cmdBufLabelCount, sizeof(uint32_t));
    vkStream->read((VkDebugUtilsLabelEXT**)&forUnmarshaling->pCmdBufLabels, sizeof(VkDebugUtilsLabelEXT*));
    if (forUnmarshaling->pCmdBufLabels)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCmdBufLabels, forUnmarshaling->cmdBufLabelCount * sizeof(VkDebugUtilsLabelEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->cmdBufLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->objectCount, sizeof(uint32_t));
    vkStream->read((VkDebugUtilsObjectNameInfoEXT**)&forUnmarshaling->pObjects, sizeof(VkDebugUtilsObjectNameInfoEXT*));
    if (forUnmarshaling->pObjects)
    {
        vkStream->alloc((void**)&forUnmarshaling->pObjects, forUnmarshaling->objectCount * sizeof(VkDebugUtilsObjectNameInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->objectCount; ++i)
        {
            unmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forUnmarshaling->pObjects + i));
        }
    }
}

void marshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDebugUtilsMessengerCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDebugUtilsMessengerCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->write((VkDebugUtilsMessageSeverityFlagsEXT*)&forMarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&forMarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    vkStream->write((PFN_vkDebugUtilsMessengerCallbackEXT*)&forMarshaling->pfnUserCallback, sizeof(PFN_vkDebugUtilsMessengerCallbackEXT));
    vkStream->write((void**)&forMarshaling->pUserData, sizeof(void*));
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStream* vkStream,
    VkDebugUtilsMessengerCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDebugUtilsMessengerCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->read((VkDebugUtilsMessageSeverityFlagsEXT*)&forUnmarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&forUnmarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    vkStream->read((PFN_vkDebugUtilsMessengerCallbackEXT*)&forUnmarshaling->pfnUserCallback, sizeof(PFN_vkDebugUtilsMessengerCallbackEXT));
    vkStream->read((void**)&forUnmarshaling->pUserData, sizeof(void*));
    if (forUnmarshaling->pUserData)
    {
        vkStream->alloc((void**)&forUnmarshaling->pUserData, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

VkResult marshal_vkSetDebugUtilsObjectNameEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (const VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
    VkResult marshal_vkSetDebugUtilsObjectNameEXT_VkResult_return;
    vkStream->read(&marshal_vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult unmarshal_vkSetDebugUtilsObjectNameEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
    unmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
    VkResult unmarshal_vkSetDebugUtilsObjectNameEXT_VkResult_return;
    vkStream->write(&unmarshal_vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult marshal_vkSetDebugUtilsObjectTagEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugUtilsObjectTagInfoEXT(vkStream, (const VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
    VkResult marshal_vkSetDebugUtilsObjectTagEXT_VkResult_return;
    vkStream->read(&marshal_vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

VkResult unmarshal_vkSetDebugUtilsObjectTagEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
    unmarshal_VkDebugUtilsObjectTagInfoEXT(vkStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
    VkResult unmarshal_vkSetDebugUtilsObjectTagEXT_VkResult_return;
    vkStream->write(&unmarshal_vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void marshal_vkQueueBeginDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkDebugUtilsLabelEXT(vkStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void unmarshal_vkQueueBeginDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
    unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void marshal_vkQueueEndDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
}

void unmarshal_vkQueueEndDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
}

void marshal_vkQueueInsertDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkDebugUtilsLabelEXT(vkStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void unmarshal_vkQueueInsertDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
    unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void marshal_vkCmdBeginDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugUtilsLabelEXT(vkStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void unmarshal_vkCmdBeginDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
    unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void marshal_vkCmdEndDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void unmarshal_vkCmdEndDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void marshal_vkCmdInsertDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugUtilsLabelEXT(vkStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void unmarshal_vkCmdInsertDebugUtilsLabelEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
    unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
}

VkResult marshal_vkCreateDebugUtilsMessengerEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, (const VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
    VkResult marshal_vkCreateDebugUtilsMessengerEXT_VkResult_return;
    vkStream->read(&marshal_vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

VkResult unmarshal_vkCreateDebugUtilsMessengerEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
    unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
    VkResult unmarshal_vkCreateDebugUtilsMessengerEXT_VkResult_return;
    vkStream->write(&unmarshal_vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void marshal_vkDestroyDebugUtilsMessengerEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((VkDebugUtilsMessengerEXT*)&messenger, sizeof(VkDebugUtilsMessengerEXT));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyDebugUtilsMessengerEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkDebugUtilsMessengerEXT*)&messenger, sizeof(VkDebugUtilsMessengerEXT));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

void marshal_vkSubmitDebugUtilsMessageEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    vkStream->write((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    vkStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    marshal_VkDebugUtilsMessengerCallbackDataEXT(vkStream, (const VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
}

void unmarshal_vkSubmitDebugUtilsMessageEXT(
    VulkanStream* vkStream,
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    vkStream->read((VkInstance*)&instance, sizeof(VkInstance));
    vkStream->read((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    vkStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    vkStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
    unmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void marshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferUsageANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint64_t*)&forMarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void unmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferUsageANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint64_t*)&forUnmarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void marshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->samplerYcbcrConversionComponents));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void unmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStream* vkStream,
    VkAndroidHardwareBufferFormatPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->samplerYcbcrConversionComponents));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void marshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    const VkImportAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((AHardwareBuffer*)forMarshaling->buffer, sizeof(AHardwareBuffer));
}

void unmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkImportAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->alloc((void**)&forUnmarshaling->buffer, sizeof(AHardwareBuffer));
    vkStream->read((AHardwareBuffer*)forUnmarshaling->buffer, sizeof(AHardwareBuffer));
}

void marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkDeviceMemory*)&forMarshaling->memory, sizeof(VkDeviceMemory));
}

void unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStream* vkStream,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkDeviceMemory*)&forUnmarshaling->memory, sizeof(VkDeviceMemory));
}

void marshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    const VkExternalFormatANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
}

void unmarshal_VkExternalFormatANDROID(
    VulkanStream* vkStream,
    VkExternalFormatANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
}

VkResult marshal_vkGetAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((const AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
    marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    VkResult marshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
    vkStream->read(&marshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    return marshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult unmarshal_vkGetAndroidHardwareBufferPropertiesANDROID(
    VulkanStream* vkStream,
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
    vkStream->read((AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    VkResult unmarshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
    vkStream->write(&unmarshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult marshal_vkGetMemoryAndroidHardwareBufferANDROID(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkStream, (const VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
    vkStream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult marshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

VkResult unmarshal_vkGetMemoryAndroidHardwareBufferANDROID(
    VulkanStream* vkStream,
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
    unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
    vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult unmarshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void marshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStream* vkStream,
    const VkSamplerReductionModeCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSamplerReductionModeEXT*)&forMarshaling->reductionMode, sizeof(VkSamplerReductionModeEXT));
}

void unmarshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStream* vkStream,
    VkSamplerReductionModeCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSamplerReductionModeEXT*)&forUnmarshaling->reductionMode, sizeof(VkSamplerReductionModeEXT));
}

void marshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void marshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    const VkSampleLocationEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkSampleLocationEXT(
    VulkanStream* vkStream,
    VkSampleLocationEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    const VkSampleLocationsInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->sampleLocationGridSize));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationsCount; ++i)
    {
        marshal_VkSampleLocationEXT(vkStream, (const VkSampleLocationEXT*)(forMarshaling->pSampleLocations + i));
    }
}

void unmarshal_VkSampleLocationsInfoEXT(
    VulkanStream* vkStream,
    VkSampleLocationsInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->sampleLocationGridSize));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pSampleLocations, forUnmarshaling->sampleLocationsCount * sizeof(const VkSampleLocationEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationsCount; ++i)
    {
        unmarshal_VkSampleLocationEXT(vkStream, (VkSampleLocationEXT*)(forUnmarshaling->pSampleLocations + i));
    }
}

void marshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    const VkAttachmentSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachmentIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStream* vkStream,
    VkAttachmentSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    const VkSubpassSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpassIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkSubpassSampleLocationsEXT(
    VulkanStream* vkStream,
    VkSubpassSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpassIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    const VkRenderPassSampleLocationsBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        marshal_VkAttachmentSampleLocationsEXT(vkStream, (const VkAttachmentSampleLocationsEXT*)(forMarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->postSubpassSampleLocationsCount; ++i)
    {
        marshal_VkSubpassSampleLocationsEXT(vkStream, (const VkSubpassSampleLocationsEXT*)(forMarshaling->pPostSubpassSampleLocations + i));
    }
}

void unmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStream* vkStream,
    VkRenderPassSampleLocationsBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pAttachmentInitialSampleLocations, forUnmarshaling->attachmentInitialSampleLocationsCount * sizeof(const VkAttachmentSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        unmarshal_VkAttachmentSampleLocationsEXT(vkStream, (VkAttachmentSampleLocationsEXT*)(forUnmarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pPostSubpassSampleLocations, forUnmarshaling->postSubpassSampleLocationsCount * sizeof(const VkSubpassSampleLocationsEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->postSubpassSampleLocationsCount; ++i)
    {
        unmarshal_VkSubpassSampleLocationsEXT(vkStream, (VkSubpassSampleLocationsEXT*)(forUnmarshaling->pPostSubpassSampleLocations + i));
    }
}

void marshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineSampleLocationsStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->sampleLocationsEnable, sizeof(VkBool32));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineSampleLocationsStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->sampleLocationsEnable, sizeof(VkBool32));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
    vkStream->write((float*)forMarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->variableSampleLocations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
    vkStream->read((float*)forUnmarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->variableSampleLocations, sizeof(VkBool32));
}

void marshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    const VkMultisamplePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
}

void unmarshal_VkMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkMultisamplePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
}

void marshal_vkCmdSetSampleLocationsEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSampleLocationsInfoEXT(vkStream, (const VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
}

void unmarshal_vkCmdSetSampleLocationsEXT(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
}

void marshal_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    vkStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
}

void unmarshal_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    vkStream->read((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    vkStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    unmarshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void marshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void marshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkBool32*)&forMarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBlendOverlapEXT*)&forMarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

void unmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBlendOverlapEXT*)&forUnmarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void marshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineCoverageToColorStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineCoverageToColorStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageToColorLocation, sizeof(uint32_t));
}

void unmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageToColorStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineCoverageToColorStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageToColorLocation, sizeof(uint32_t));
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void marshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    const VkPipelineCoverageModulationStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkPipelineCoverageModulationStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->write((VkCoverageModulationModeNV*)&forMarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageModulationTableCount, sizeof(uint32_t));
    vkStream->write((const float**)&forMarshaling->pCoverageModulationTable, sizeof(const float*));
    if (forMarshaling->pCoverageModulationTable)
    {
        vkStream->write((const float*)forMarshaling->pCoverageModulationTable, forMarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

void unmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStream* vkStream,
    VkPipelineCoverageModulationStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkPipelineCoverageModulationStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->read((VkCoverageModulationModeNV*)&forUnmarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageModulationTableCount, sizeof(uint32_t));
    vkStream->read((float**)&forUnmarshaling->pCoverageModulationTable, sizeof(const float*));
    if (forUnmarshaling->pCoverageModulationTable)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
        vkStream->read((float*)forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void marshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    const VkValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkValidationCacheCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    vkStream->write((size_t*)&forMarshaling->initialDataSize, sizeof(size_t));
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkValidationCacheCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    vkStream->read((size_t*)&forUnmarshaling->initialDataSize, sizeof(size_t));
    vkStream->alloc((void**)&forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

void marshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    const VkShaderModuleValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkValidationCacheEXT*)&forMarshaling->validationCache, sizeof(VkValidationCacheEXT));
}

void unmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStream* vkStream,
    VkShaderModuleValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkValidationCacheEXT*)&forUnmarshaling->validationCache, sizeof(VkValidationCacheEXT));
}

VkResult marshal_vkCreateValidationCacheEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkValidationCacheCreateInfoEXT(vkStream, (const VkValidationCacheCreateInfoEXT*)(pCreateInfo));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->read((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
    VkResult marshal_vkCreateValidationCacheEXT_VkResult_return;
    vkStream->read(&marshal_vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkCreateValidationCacheEXT_VkResult_return;
}

VkResult unmarshal_vkCreateValidationCacheEXT(
    VulkanStream* vkStream,
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
    unmarshal_VkValidationCacheCreateInfoEXT(vkStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
    vkStream->write((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
    VkResult unmarshal_vkCreateValidationCacheEXT_VkResult_return;
    vkStream->write(&unmarshal_vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkCreateValidationCacheEXT_VkResult_return;
}

void marshal_vkDestroyValidationCacheEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    vkStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(vkStream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void unmarshal_vkDestroyValidationCacheEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    vkStream->read((VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        vkStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
        unmarshal_VkAllocationCallbacks(vkStream, (VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult marshal_vkMergeValidationCachesEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkValidationCacheEXT*)&dstCache, sizeof(VkValidationCacheEXT));
    vkStream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    vkStream->write((const VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    VkResult marshal_vkMergeValidationCachesEXT_VkResult_return;
    vkStream->read(&marshal_vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkMergeValidationCachesEXT_VkResult_return;
}

VkResult unmarshal_vkMergeValidationCachesEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkValidationCacheEXT*)&dstCache, sizeof(VkValidationCacheEXT));
    vkStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    vkStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    vkStream->read((VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    VkResult unmarshal_vkMergeValidationCachesEXT_VkResult_return;
    vkStream->write(&unmarshal_vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkMergeValidationCachesEXT_VkResult_return;
}

VkResult marshal_vkGetValidationCacheDataEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    vkStream->read((size_t*)pDataSize, sizeof(size_t));
    vkStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    VkResult marshal_vkGetValidationCacheDataEXT_VkResult_return;
    vkStream->read(&marshal_vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkGetValidationCacheDataEXT_VkResult_return;
}

VkResult unmarshal_vkGetValidationCacheDataEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    vkStream->write((size_t*)pDataSize, sizeof(size_t));
    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    VkResult unmarshal_vkGetValidationCacheDataEXT_VkResult_return;
    vkStream->write(&unmarshal_vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
void marshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorBindingFlagsEXT*)forMarshaling->pBindingFlags, forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
}

void unmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStream* vkStream,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
    vkStream->read((VkDescriptorBindingFlagsEXT*)forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
}

void marshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStream* vkStream,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDescriptorCounts, forMarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStream* vkStream,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStream* vkStream,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void marshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkQueueGlobalPriorityEXT*)&forMarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

void unmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStream* vkStream,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkQueueGlobalPriorityEXT*)&forUnmarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

#endif
#ifdef VK_EXT_external_memory_host
void marshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    const VkImportMemoryHostPointerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((void**)&forMarshaling->pHostPointer, sizeof(void*));
    if (forMarshaling->pHostPointer)
    {
        vkStream->write((void*)forMarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void unmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStream* vkStream,
    VkImportMemoryHostPointerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((void**)&forUnmarshaling->pHostPointer, sizeof(void*));
    if (forUnmarshaling->pHostPointer)
    {
        vkStream->alloc((void**)&forUnmarshaling->pHostPointer, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void marshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    const VkMemoryHostPointerPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkMemoryHostPointerPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkDeviceSize*)&forMarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

VkResult marshal_vkGetMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    vkStream->write((VkDevice*)&device, sizeof(VkDevice));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((const void**)&pHostPointer, sizeof(const void*));
    if (pHostPointer)
    {
        vkStream->write((const void*)pHostPointer, sizeof(const uint8_t));
    }
    marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    VkResult marshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
    vkStream->read(&marshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    return marshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

VkResult unmarshal_vkGetMemoryHostPointerPropertiesEXT(
    VulkanStream* vkStream,
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    vkStream->read((VkDevice*)&device, sizeof(VkDevice));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((void**)&pHostPointer, sizeof(const void*));
    if (pHostPointer)
    {
        vkStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
        vkStream->read((void*)pHostPointer, sizeof(const uint8_t));
    }
    unmarshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    VkResult unmarshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
    vkStream->write(&unmarshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    return unmarshal_vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void marshal_vkCmdWriteBufferMarkerAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    vkStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&marker, sizeof(uint32_t));
}

void unmarshal_vkCmdWriteBufferMarkerAMD(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    vkStream->read((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    vkStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&marker, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_core_properties
void marshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    const VkPhysicalDeviceShaderCorePropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStream* vkStream,
    VkPhysicalDeviceShaderCorePropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void marshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((uint32_t*)&forMarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStream* vkStream,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void marshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    const VkVertexInputBindingDivisorDescriptionEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
}

void unmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStream* vkStream,
    VkVertexInputBindingDivisorDescriptionEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->divisor, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((const void**)&forMarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDivisorCount; ++i)
    {
        marshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (const VkVertexInputBindingDivisorDescriptionEXT*)(forMarshaling->pVertexBindingDivisors + i));
    }
}

void unmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStream* vkStream,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(const void*));
    // TODO: Unsupported : const void* pNext
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    vkStream->alloc((void**)&forUnmarshaling->pVertexBindingDivisors, forUnmarshaling->vertexBindingDivisorCount * sizeof(const VkVertexInputBindingDivisorDescriptionEXT));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDivisorCount; ++i)
    {
        unmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (VkVertexInputBindingDivisorDescriptionEXT*)(forUnmarshaling->pVertexBindingDivisors + i));
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void marshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    const VkQueueFamilyCheckpointPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void unmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStream* vkStream,
    VkQueueFamilyCheckpointPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void marshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    const VkCheckpointDataNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    vkStream->write((void**)&forMarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->write((VkPipelineStageFlagBits*)&forMarshaling->stage, sizeof(VkPipelineStageFlagBits));
    vkStream->write((void**)&forMarshaling->pCheckpointMarker, sizeof(void*));
    if (forMarshaling->pCheckpointMarker)
    {
        vkStream->write((void*)forMarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

void unmarshal_VkCheckpointDataNV(
    VulkanStream* vkStream,
    VkCheckpointDataNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    vkStream->read((void**)&forUnmarshaling->pNext, sizeof(void*));
    // TODO: Unsupported : void* pNext
    vkStream->read((VkPipelineStageFlagBits*)&forUnmarshaling->stage, sizeof(VkPipelineStageFlagBits));
    vkStream->read((void**)&forUnmarshaling->pCheckpointMarker, sizeof(void*));
    if (forUnmarshaling->pCheckpointMarker)
    {
        vkStream->alloc((void**)&forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
        vkStream->read((void*)forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

void marshal_vkCmdSetCheckpointNV(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    vkStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->write((const void**)&pCheckpointMarker, sizeof(const void*));
    if (pCheckpointMarker)
    {
        vkStream->write((const void*)pCheckpointMarker, sizeof(const uint8_t));
    }
}

void unmarshal_vkCmdSetCheckpointNV(
    VulkanStream* vkStream,
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    vkStream->read((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    vkStream->read((void**)&pCheckpointMarker, sizeof(const void*));
    if (pCheckpointMarker)
    {
        vkStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
        vkStream->read((void*)pCheckpointMarker, sizeof(const uint8_t));
    }
}

void marshal_vkGetQueueCheckpointDataNV(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    vkStream->write((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
    {
        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
    }
}

void unmarshal_vkGetQueueCheckpointDataNV(
    VulkanStream* vkStream,
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    vkStream->read((VkQueue*)&queue, sizeof(VkQueue));
    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
    {
        unmarshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
    }
}

#endif

} // namespace goldfish_vk
