// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"
#include "common/goldfish_vk_private_defs.h"

#include "android/base/system/System.h"

#include "IOStream.h"
#include "emugl/common/logging.h"

#include "VkDecoderGlobalState.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>





using emugl::vkDispatch;

using namespace goldfish_vk;

using android::base::System;

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(System::get()->envGet("ANDROID_EMU_VK_LOG_CALLS") == "1"), m_vk(vkDispatch()), m_state(VkDecoderGlobalState::get()) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    size_t decode(void* buf, size_t bufsize, IOStream* stream);

private:
    bool m_logCalls;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()) { }

VkDecoder::~VkDecoder() = default;

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* stream) {
    return mImpl->decode(buf, bufsize, stream);
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream)
{
    if (len < 8) return 0;;
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateInstance\n");;
                }
                const VkInstanceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                unmarshal_VkInstanceCreateInfo(vkReadStream, (VkInstanceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                uint64_t cgen_var_1;
                vkReadStream->read((uint64_t*)&cgen_var_1, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_1, (VkInstance*)pInstance, 1);
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(pCreateInfo, pAllocator, pInstance);
                uint64_t cgen_var_2;
                vkStream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_2, 1);
                vkStream->write((uint64_t*)&cgen_var_2, 8);
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyInstance:
            {
                VkInstance instance;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_3;
                vkReadStream->read((uint64_t*)&cgen_var_3, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_3, (VkInstance*)&instance, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyInstance\n");;
                }
                m_vk->vkDestroyInstance(instance, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                uint64_t cgen_var_5;
                vkReadStream->read((uint64_t*)&cgen_var_5, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_5, (VkInstance*)&instance, 1);
                // WARNING PTR CHECK
                pPhysicalDeviceCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_8;
                        vkReadStream->alloc((void**)&cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_8, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDevices\n");;
                }
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_vk->vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
                // WARNING PTR CHECK
                uint64_t cgen_var_9 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
                vkStream->putBe64(cgen_var_9);
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDevices;
                vkStream->putBe64(cgen_var_10);
                if (pPhysicalDevices)
                {
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_11;
                        vkStream->alloc((void**)&cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_11, (*(pPhysicalDeviceCount)));
                        vkStream->write((uint64_t*)cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                if (m_logCalls) {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures\n");
                    ;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                uint64_t cgen_var_12;
                vkReadStream->read((uint64_t*)&cgen_var_12, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_12, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                unmarshal_VkPhysicalDeviceFeatures(vkReadStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                m_state->on_vkGetPhysicalDeviceFeatures(physicalDevice,
                                                        pFeatures);
                marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                uint64_t cgen_var_13;
                vkReadStream->read((uint64_t*)&cgen_var_13, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_13, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                unmarshal_VkFormatProperties(vkReadStream, (VkFormatProperties*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                uint64_t cgen_var_14;
                vkReadStream->read((uint64_t*)&cgen_var_14, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_14, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                unmarshal_VkImageFormatProperties(vkReadStream, (VkImageFormatProperties*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                uint64_t cgen_var_15;
                vkReadStream->read((uint64_t*)&cgen_var_15, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_15, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                unmarshal_VkPhysicalDeviceProperties(vkReadStream, (VkPhysicalDeviceProperties*)(pProperties));
                m_state->on_vkGetPhysicalDeviceProperties(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                uint64_t cgen_var_16;
                vkReadStream->read((uint64_t*)&cgen_var_16, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_16, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties(vkReadStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_19 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_19);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_20 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_20);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                uint64_t cgen_var_21;
                vkReadStream->read((uint64_t*)&cgen_var_21, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_21, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                unmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                m_state->on_vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                VkInstance instance;
                const char* pName;
                uint64_t cgen_var_22;
                vkReadStream->read((uint64_t*)&cgen_var_22, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_22, (VkInstance*)&instance, 1);
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetInstanceProcAddr\n");;
                }
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = m_vk->vkGetInstanceProcAddr(instance, pName);
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                VkDevice device;
                const char* pName;
                uint64_t cgen_var_23;
                vkReadStream->read((uint64_t*)&cgen_var_23, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_23, (VkDevice*)&device, 1);
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceProcAddr\n");;
                }
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = m_vk->vkGetDeviceProcAddr(device, pName);
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDevice:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDevice\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkDeviceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                uint64_t cgen_var_24;
                vkReadStream->read((uint64_t*)&cgen_var_24, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_24, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                unmarshal_VkDeviceCreateInfo(vkReadStream, (VkDeviceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                uint64_t cgen_var_26;
                vkReadStream->read((uint64_t*)&cgen_var_26, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_26, (VkDevice*)pDevice, 1);
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
                uint64_t cgen_var_27;
                vkStream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_27, 1);
                vkStream->write((uint64_t*)&cgen_var_27, 8);
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDevice:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDevice\n");;
                }
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_28;
                vkReadStream->read((uint64_t*)&cgen_var_28, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_28, (VkDevice*)&device, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyDevice(device, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceExtensionProperties\n");;
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = m_vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_32 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_32);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_33);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                VkPhysicalDevice physicalDevice;
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                uint64_t cgen_var_34;
                vkReadStream->read((uint64_t*)&cgen_var_34, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_34, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateDeviceExtensionProperties\n");;
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = m_vk->vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_37 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_37);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_38 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_38);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceLayerProperties\n");;
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = m_vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_41 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_41);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_42 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_42);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                uint64_t cgen_var_43;
                vkReadStream->read((uint64_t*)&cgen_var_43, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_43, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateDeviceLayerProperties\n");;
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = m_vk->vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_46 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_46);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_47 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_47);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceQueue\n");;
                }
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                uint64_t cgen_var_48;
                vkReadStream->read((uint64_t*)&cgen_var_48, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_48, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queueIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_49;
                vkReadStream->read((uint64_t*)&cgen_var_49, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_49, (VkQueue*)pQueue, 1);
                m_state->on_vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
                uint64_t cgen_var_50;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_50, 1);
                vkStream->write((uint64_t*)&cgen_var_50, 8);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueSubmit:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueSubmit\n");;
                }
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                uint64_t cgen_var_51;
                vkReadStream->read((uint64_t*)&cgen_var_51, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_51, (VkQueue*)&queue, 1);
                vkReadStream->read((uint32_t*)&submitCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    unmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i));
                }
                uint64_t cgen_var_52;
                vkReadStream->read((uint64_t*)&cgen_var_52, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_52, (VkFence*)&fence, 1);
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(queue, submitCount, pSubmits, fence);
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                VkQueue queue;
                uint64_t cgen_var_53;
                vkReadStream->read((uint64_t*)&cgen_var_53, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_53, (VkQueue*)&queue, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueWaitIdle\n");;
                }
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = m_vk->vkQueueWaitIdle(queue);
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                VkDevice device;
                uint64_t cgen_var_54;
                vkReadStream->read((uint64_t*)&cgen_var_54, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_54, (VkDevice*)&device, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDeviceWaitIdle\n");;
                }
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = m_vk->vkDeviceWaitIdle(device);
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateMemory\n");;
                }
                VkDevice device;
                const VkMemoryAllocateInfo* pAllocateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                uint64_t cgen_var_55;
                vkReadStream->read((uint64_t*)&cgen_var_55, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_55, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                unmarshal_VkMemoryAllocateInfo(vkReadStream, (VkMemoryAllocateInfo*)(pAllocateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                uint64_t cgen_var_57;
                vkReadStream->read((uint64_t*)&cgen_var_57, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_57, (VkDeviceMemory*)pMemory, 1);
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
                uint64_t cgen_var_58;
                vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_58, 1);
                vkStream->write((uint64_t*)&cgen_var_58, 8);
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_59;
                vkReadStream->read((uint64_t*)&cgen_var_59, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_59, (VkDevice*)&device, 1);
                uint64_t cgen_var_60;
                vkReadStream->read((uint64_t*)&cgen_var_60, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_60, (VkDeviceMemory*)&memory, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkFreeMemory(device, memory, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMapMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMapMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                uint64_t cgen_var_62;
                vkReadStream->read((uint64_t*)&cgen_var_62, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_62, (VkDevice*)&device, 1);
                uint64_t cgen_var_63;
                vkReadStream->read((uint64_t*)&cgen_var_63, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_63, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
                // WARNING PTR CHECK
                ppData = (void**)(uintptr_t)vkReadStream->getBe64();
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    vkReadStream->read((void**)ppData, sizeof(void*));
                }
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(device, memory, offset, size, flags, ppData);
                // WARNING PTR CHECK
                uint64_t cgen_var_65 = (uint64_t)(uintptr_t)ppData;
                vkStream->putBe64(cgen_var_65);
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUnmapMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUnmapMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t cgen_var_66;
                vkReadStream->read((uint64_t*)&cgen_var_66, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_66, (VkDevice*)&device, 1);
                uint64_t cgen_var_67;
                vkReadStream->read((uint64_t*)&cgen_var_67, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_67, (VkDeviceMemory*)&memory, 1);
                m_state->on_vkUnmapMemory(device, memory);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFlushMappedMemoryRanges\n");;
                }
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                uint64_t cgen_var_68;
                vkReadStream->read((uint64_t*)&cgen_var_68, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_68, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = pMemoryRanges[i].memory;
                        auto size = pMemoryRanges[i].size;
                        auto offset = pMemoryRanges[i].offset;
                        uint64_t readStream = 0;
                        vkReadStream->read(&readStream, sizeof(uint64_t));
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        if (!hostPtr && readStream > 0) abort();
                        if (!hostPtr) continue;
                        uint8_t* targetRange = hostPtr + offset;
                        vkReadStream->read(targetRange, readStream);
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFlushMappedMemoryRanges\n");;
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = m_vk->vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkInvalidateMappedMemoryRanges\n");;
                }
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                uint64_t cgen_var_69;
                vkReadStream->read((uint64_t*)&cgen_var_69, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_69, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkInvalidateMappedMemoryRanges\n");;
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = m_vk->vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = range.memory;
                        auto size = range.size;
                        auto offset = range.offset;
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                        uint64_t writeStream = 0;
                        if (!hostPtr) { vkStream->write(&writeStream, sizeof(uint64_t)); continue; };
                        uint8_t* targetRange = hostPtr + offset;
                        writeStream = actualSize;
                        vkStream->write(&writeStream, sizeof(uint64_t));
                        vkStream->write(targetRange, actualSize);
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                uint64_t cgen_var_70;
                vkReadStream->read((uint64_t*)&cgen_var_70, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_70, (VkDevice*)&device, 1);
                uint64_t cgen_var_71;
                vkReadStream->read((uint64_t*)&cgen_var_71, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_71, (VkDeviceMemory*)&memory, 1);
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceMemoryCommitment\n");;
                }
                m_vk->vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindBufferMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory\n");;
                }
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                uint64_t cgen_var_72;
                vkReadStream->read((uint64_t*)&cgen_var_72, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_72, (VkDevice*)&device, 1);
                uint64_t cgen_var_73;
                vkReadStream->read((uint64_t*)&cgen_var_73, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_73, (VkBuffer*)&buffer, 1);
                uint64_t cgen_var_74;
                vkReadStream->read((uint64_t*)&cgen_var_74, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_74, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(device, buffer, memory, memoryOffset);
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory:
            {
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                uint64_t cgen_var_75;
                vkReadStream->read((uint64_t*)&cgen_var_75, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_75, (VkDevice*)&device, 1);
                uint64_t cgen_var_76;
                vkReadStream->read((uint64_t*)&cgen_var_76, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_76, (VkImage*)&image, 1);
                uint64_t cgen_var_77;
                vkReadStream->read((uint64_t*)&cgen_var_77, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_77, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory\n");;
                }
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_vk->vkBindImageMemory(device, image, memory, memoryOffset);
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                uint64_t cgen_var_78;
                vkReadStream->read((uint64_t*)&cgen_var_78, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_78, (VkDevice*)&device, 1);
                uint64_t cgen_var_79;
                vkReadStream->read((uint64_t*)&cgen_var_79, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_79, (VkBuffer*)&buffer, 1);
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements\n");;
                }
                m_vk->vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements\n");;
                }
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                uint64_t cgen_var_80;
                vkReadStream->read((uint64_t*)&cgen_var_80, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_80, (VkDevice*)&device, 1);
                uint64_t cgen_var_81;
                vkReadStream->read((uint64_t*)&cgen_var_81, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_81, (VkImage*)&image, 1);
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                m_state->on_vkGetImageMemoryRequirements(device, image, pMemoryRequirements);
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                uint64_t cgen_var_82;
                vkReadStream->read((uint64_t*)&cgen_var_82, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_82, (VkDevice*)&device, 1);
                uint64_t cgen_var_83;
                vkReadStream->read((uint64_t*)&cgen_var_83, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_83, (VkImage*)&image, 1);
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements(vkReadStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                // WARNING PTR CHECK
                uint64_t cgen_var_86 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_86);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_87 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_87);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                uint64_t cgen_var_88;
                vkReadStream->read((uint64_t*)&cgen_var_88, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_88, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties(vkReadStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_91 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_91);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_92 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_92);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueBindSparse:
            {
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                uint64_t cgen_var_93;
                vkReadStream->read((uint64_t*)&cgen_var_93, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_93, (VkQueue*)&queue, 1);
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i));
                }
                uint64_t cgen_var_94;
                vkReadStream->read((uint64_t*)&cgen_var_94, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_94, (VkFence*)&fence, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueBindSparse\n");;
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = m_vk->vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateFence:
            {
                VkDevice device;
                const VkFenceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                uint64_t cgen_var_95;
                vkReadStream->read((uint64_t*)&cgen_var_95, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_95, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                unmarshal_VkFenceCreateInfo(vkReadStream, (VkFenceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_97;
                vkReadStream->read((uint64_t*)&cgen_var_97, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_97, (VkFence*)pFence, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateFence\n");;
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = m_vk->vkCreateFence(device, pCreateInfo, pAllocator, pFence);
                uint64_t cgen_var_98;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_98, 1);
                vkStream->write((uint64_t*)&cgen_var_98, 8);
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyFence:
            {
                VkDevice device;
                VkFence fence;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_99;
                vkReadStream->read((uint64_t*)&cgen_var_99, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_99, (VkDevice*)&device, 1);
                uint64_t cgen_var_100;
                vkReadStream->read((uint64_t*)&cgen_var_100, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_100, (VkFence*)&fence, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyFence\n");;
                }
                m_vk->vkDestroyFence(device, fence, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                uint64_t cgen_var_102;
                vkReadStream->read((uint64_t*)&cgen_var_102, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_102, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_103;
                    vkReadStream->alloc((void**)&cgen_var_103, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_103, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_103, (VkFence*)pFences, ((fenceCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetFences\n");;
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = m_vk->vkResetFences(device, fenceCount, pFences);
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceStatus:
            {
                VkDevice device;
                VkFence fence;
                uint64_t cgen_var_104;
                vkReadStream->read((uint64_t*)&cgen_var_104, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_104, (VkDevice*)&device, 1);
                uint64_t cgen_var_105;
                vkReadStream->read((uint64_t*)&cgen_var_105, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_105, (VkFence*)&fence, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceStatus\n");;
                }
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = m_vk->vkGetFenceStatus(device, fence);
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkWaitForFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                uint64_t cgen_var_106;
                vkReadStream->read((uint64_t*)&cgen_var_106, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_106, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_107;
                    vkReadStream->alloc((void**)&cgen_var_107, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_107, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_107, (VkFence*)pFences, ((fenceCount)));
                }
                vkReadStream->read((VkBool32*)&waitAll, sizeof(VkBool32));
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkWaitForFences\n");;
                }
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = m_vk->vkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSemaphore:
            {
                VkDevice device;
                const VkSemaphoreCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                uint64_t cgen_var_108;
                vkReadStream->read((uint64_t*)&cgen_var_108, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_108, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                unmarshal_VkSemaphoreCreateInfo(vkReadStream, (VkSemaphoreCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                uint64_t cgen_var_110;
                vkReadStream->read((uint64_t*)&cgen_var_110, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_110, (VkSemaphore*)pSemaphore, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSemaphore\n");;
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_vk->vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
                uint64_t cgen_var_111;
                vkStream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_111, 1);
                vkStream->write((uint64_t*)&cgen_var_111, 8);
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySemaphore:
            {
                VkDevice device;
                VkSemaphore semaphore;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_112;
                vkReadStream->read((uint64_t*)&cgen_var_112, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_112, (VkDevice*)&device, 1);
                uint64_t cgen_var_113;
                vkReadStream->read((uint64_t*)&cgen_var_113, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_113, (VkSemaphore*)&semaphore, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySemaphore\n");;
                }
                m_vk->vkDestroySemaphore(device, semaphore, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateEvent:
            {
                VkDevice device;
                const VkEventCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                uint64_t cgen_var_115;
                vkReadStream->read((uint64_t*)&cgen_var_115, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_115, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                unmarshal_VkEventCreateInfo(vkReadStream, (VkEventCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                uint64_t cgen_var_117;
                vkReadStream->read((uint64_t*)&cgen_var_117, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_117, (VkEvent*)pEvent, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateEvent\n");;
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = m_vk->vkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
                uint64_t cgen_var_118;
                vkStream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_118, 1);
                vkStream->write((uint64_t*)&cgen_var_118, 8);
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyEvent:
            {
                VkDevice device;
                VkEvent event;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_119;
                vkReadStream->read((uint64_t*)&cgen_var_119, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_119, (VkDevice*)&device, 1);
                uint64_t cgen_var_120;
                vkReadStream->read((uint64_t*)&cgen_var_120, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_120, (VkEvent*)&event, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyEvent\n");;
                }
                m_vk->vkDestroyEvent(device, event, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetEventStatus:
            {
                VkDevice device;
                VkEvent event;
                uint64_t cgen_var_122;
                vkReadStream->read((uint64_t*)&cgen_var_122, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_122, (VkDevice*)&device, 1);
                uint64_t cgen_var_123;
                vkReadStream->read((uint64_t*)&cgen_var_123, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_123, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetEventStatus\n");;
                }
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = m_vk->vkGetEventStatus(device, event);
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSetEvent:
            {
                VkDevice device;
                VkEvent event;
                uint64_t cgen_var_124;
                vkReadStream->read((uint64_t*)&cgen_var_124, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_124, (VkDevice*)&device, 1);
                uint64_t cgen_var_125;
                vkReadStream->read((uint64_t*)&cgen_var_125, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_125, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetEvent\n");;
                }
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = m_vk->vkSetEvent(device, event);
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetEvent:
            {
                VkDevice device;
                VkEvent event;
                uint64_t cgen_var_126;
                vkReadStream->read((uint64_t*)&cgen_var_126, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_126, (VkDevice*)&device, 1);
                uint64_t cgen_var_127;
                vkReadStream->read((uint64_t*)&cgen_var_127, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_127, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetEvent\n");;
                }
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = m_vk->vkResetEvent(device, event);
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateQueryPool:
            {
                VkDevice device;
                const VkQueryPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                uint64_t cgen_var_128;
                vkReadStream->read((uint64_t*)&cgen_var_128, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_128, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                unmarshal_VkQueryPoolCreateInfo(vkReadStream, (VkQueryPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                uint64_t cgen_var_130;
                vkReadStream->read((uint64_t*)&cgen_var_130, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_130, (VkQueryPool*)pQueryPool, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateQueryPool\n");;
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = m_vk->vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
                uint64_t cgen_var_131;
                vkStream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_131, 1);
                vkStream->write((uint64_t*)&cgen_var_131, 8);
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                VkDevice device;
                VkQueryPool queryPool;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_132;
                vkReadStream->read((uint64_t*)&cgen_var_132, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_132, (VkDevice*)&device, 1);
                uint64_t cgen_var_133;
                vkReadStream->read((uint64_t*)&cgen_var_133, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_133, (VkQueryPool*)&queryPool, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyQueryPool\n");;
                }
                m_vk->vkDestroyQueryPool(device, queryPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                uint64_t cgen_var_135;
                vkReadStream->read((uint64_t*)&cgen_var_135, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_135, (VkDevice*)&device, 1);
                uint64_t cgen_var_136;
                vkReadStream->read((uint64_t*)&cgen_var_136, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_136, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                dataSize = (size_t)vkReadStream->getBe64();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetQueryPoolResults\n");;
                }
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = m_vk->vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateBuffer\n");;
                }
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                uint64_t cgen_var_138;
                vkReadStream->read((uint64_t*)&cgen_var_138, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_138, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                unmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_140;
                vkReadStream->read((uint64_t*)&cgen_var_140, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_140, (VkBuffer*)pBuffer, 1);
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
                uint64_t cgen_var_141;
                vkStream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_141, 1);
                vkStream->write((uint64_t*)&cgen_var_141, 8);
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyBuffer:
            {
                VkDevice device;
                VkBuffer buffer;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_142;
                vkReadStream->read((uint64_t*)&cgen_var_142, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_142, (VkDevice*)&device, 1);
                uint64_t cgen_var_143;
                vkReadStream->read((uint64_t*)&cgen_var_143, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_143, (VkBuffer*)&buffer, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyBuffer\n");;
                }
                m_vk->vkDestroyBuffer(device, buffer, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateBufferView:
            {
                VkDevice device;
                const VkBufferViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                uint64_t cgen_var_145;
                vkReadStream->read((uint64_t*)&cgen_var_145, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_145, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                unmarshal_VkBufferViewCreateInfo(vkReadStream, (VkBufferViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                uint64_t cgen_var_147;
                vkReadStream->read((uint64_t*)&cgen_var_147, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_147, (VkBufferView*)pView, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateBufferView\n");;
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = m_vk->vkCreateBufferView(device, pCreateInfo, pAllocator, pView);
                uint64_t cgen_var_148;
                vkStream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_148, 1);
                vkStream->write((uint64_t*)&cgen_var_148, 8);
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyBufferView:
            {
                VkDevice device;
                VkBufferView bufferView;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_149;
                vkReadStream->read((uint64_t*)&cgen_var_149, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_149, (VkDevice*)&device, 1);
                uint64_t cgen_var_150;
                vkReadStream->read((uint64_t*)&cgen_var_150, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_150, (VkBufferView*)&bufferView, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyBufferView\n");;
                }
                m_vk->vkDestroyBufferView(device, bufferView, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImage\n");;
                }
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                uint64_t cgen_var_152;
                vkReadStream->read((uint64_t*)&cgen_var_152, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_152, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                unmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_154;
                vkReadStream->read((uint64_t*)&cgen_var_154, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_154, (VkImage*)pImage, 1);
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_state->on_vkCreateImage(device, pCreateInfo, pAllocator, pImage);
                uint64_t cgen_var_155;
                vkStream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_155, 1);
                vkStream->write((uint64_t*)&cgen_var_155, 8);
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImage\n");;
                }
                VkDevice device;
                VkImage image;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_156;
                vkReadStream->read((uint64_t*)&cgen_var_156, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_156, (VkDevice*)&device, 1);
                uint64_t cgen_var_157;
                vkReadStream->read((uint64_t*)&cgen_var_157, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_157, (VkImage*)&image, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyImage(device, image, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                VkDevice device;
                VkImage image;
                const VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                uint64_t cgen_var_159;
                vkReadStream->read((uint64_t*)&cgen_var_159, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_159, (VkDevice*)&device, 1);
                uint64_t cgen_var_160;
                vkReadStream->read((uint64_t*)&cgen_var_160, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_160, (VkImage*)&image, 1);
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                unmarshal_VkImageSubresource(vkReadStream, (VkImageSubresource*)(pSubresource));
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                unmarshal_VkSubresourceLayout(vkReadStream, (VkSubresourceLayout*)(pLayout));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSubresourceLayout\n");;
                }
                m_vk->vkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
                marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateImageView:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImageView\n");;
                }
                VkDevice device;
                const VkImageViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                uint64_t cgen_var_161;
                vkReadStream->read((uint64_t*)&cgen_var_161, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_161, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                unmarshal_VkImageViewCreateInfo(vkReadStream, (VkImageViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                uint64_t cgen_var_163;
                vkReadStream->read((uint64_t*)&cgen_var_163, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_163, (VkImageView*)pView, 1);
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(device, pCreateInfo, pAllocator, pView);
                uint64_t cgen_var_164;
                vkStream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_164, 1);
                vkStream->write((uint64_t*)&cgen_var_164, 8);
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyImageView:
            {
                VkDevice device;
                VkImageView imageView;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_165;
                vkReadStream->read((uint64_t*)&cgen_var_165, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_165, (VkDevice*)&device, 1);
                uint64_t cgen_var_166;
                vkReadStream->read((uint64_t*)&cgen_var_166, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_166, (VkImageView*)&imageView, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImageView\n");;
                }
                m_vk->vkDestroyImageView(device, imageView, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateShaderModule:
            {
                VkDevice device;
                const VkShaderModuleCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                uint64_t cgen_var_168;
                vkReadStream->read((uint64_t*)&cgen_var_168, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_168, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                unmarshal_VkShaderModuleCreateInfo(vkReadStream, (VkShaderModuleCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                uint64_t cgen_var_170;
                vkReadStream->read((uint64_t*)&cgen_var_170, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_170, (VkShaderModule*)pShaderModule, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateShaderModule\n");;
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = m_vk->vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
                uint64_t cgen_var_171;
                vkStream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_171, 1);
                vkStream->write((uint64_t*)&cgen_var_171, 8);
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                VkDevice device;
                VkShaderModule shaderModule;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_172;
                vkReadStream->read((uint64_t*)&cgen_var_172, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_172, (VkDevice*)&device, 1);
                uint64_t cgen_var_173;
                vkReadStream->read((uint64_t*)&cgen_var_173, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_173, (VkShaderModule*)&shaderModule, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyShaderModule\n");;
                }
                m_vk->vkDestroyShaderModule(device, shaderModule, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                VkDevice device;
                const VkPipelineCacheCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                uint64_t cgen_var_175;
                vkReadStream->read((uint64_t*)&cgen_var_175, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_175, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                unmarshal_VkPipelineCacheCreateInfo(vkReadStream, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                uint64_t cgen_var_177;
                vkReadStream->read((uint64_t*)&cgen_var_177, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_177, (VkPipelineCache*)pPipelineCache, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreatePipelineCache\n");;
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = m_vk->vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
                uint64_t cgen_var_178;
                vkStream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_178, 1);
                vkStream->write((uint64_t*)&cgen_var_178, 8);
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_179;
                vkReadStream->read((uint64_t*)&cgen_var_179, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_179, (VkDevice*)&device, 1);
                uint64_t cgen_var_180;
                vkReadStream->read((uint64_t*)&cgen_var_180, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_180, (VkPipelineCache*)&pipelineCache, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipelineCache\n");;
                }
                m_vk->vkDestroyPipelineCache(device, pipelineCache, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                uint64_t cgen_var_182;
                vkReadStream->read((uint64_t*)&cgen_var_182, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_182, (VkDevice*)&device, 1);
                uint64_t cgen_var_183;
                vkReadStream->read((uint64_t*)&cgen_var_183, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_183, (VkPipelineCache*)&pipelineCache, 1);
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPipelineCacheData\n");;
                }
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = m_vk->vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
                // WARNING PTR CHECK
                uint64_t cgen_var_187 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_187);
                if (pDataSize)
                {
                    uint64_t cgen_var_188 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_188);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_189 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_189);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                const VkPipelineCache* pSrcCaches;
                uint64_t cgen_var_190;
                vkReadStream->read((uint64_t*)&cgen_var_190, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_190, (VkDevice*)&device, 1);
                uint64_t cgen_var_191;
                vkReadStream->read((uint64_t*)&cgen_var_191, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_191, (VkPipelineCache*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_192;
                    vkReadStream->alloc((void**)&cgen_var_192, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_192, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(cgen_var_192, (VkPipelineCache*)pSrcCaches, ((srcCacheCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMergePipelineCaches\n");;
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = m_vk->vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkGraphicsPipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                uint64_t cgen_var_193;
                vkReadStream->read((uint64_t*)&cgen_var_193, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_193, (VkDevice*)&device, 1);
                uint64_t cgen_var_194;
                vkReadStream->read((uint64_t*)&cgen_var_194, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_194, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_196;
                    vkReadStream->alloc((void**)&cgen_var_196, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_196, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_196, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateGraphicsPipelines\n");;
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = m_vk->vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_197;
                    vkStream->alloc((void**)&cgen_var_197, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_197, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_197, ((createInfoCount)) * 8);
                }
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkComputePipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                uint64_t cgen_var_198;
                vkReadStream->read((uint64_t*)&cgen_var_198, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_198, (VkDevice*)&device, 1);
                uint64_t cgen_var_199;
                vkReadStream->read((uint64_t*)&cgen_var_199, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_199, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkComputePipelineCreateInfo(vkReadStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_201;
                    vkReadStream->alloc((void**)&cgen_var_201, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_201, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_201, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateComputePipelines\n");;
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = m_vk->vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_202;
                    vkStream->alloc((void**)&cgen_var_202, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_202, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_202, ((createInfoCount)) * 8);
                }
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipeline:
            {
                VkDevice device;
                VkPipeline pipeline;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_203;
                vkReadStream->read((uint64_t*)&cgen_var_203, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_203, (VkDevice*)&device, 1);
                uint64_t cgen_var_204;
                vkReadStream->read((uint64_t*)&cgen_var_204, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_204, (VkPipeline*)&pipeline, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipeline\n");;
                }
                m_vk->vkDestroyPipeline(device, pipeline, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                VkDevice device;
                const VkPipelineLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                uint64_t cgen_var_206;
                vkReadStream->read((uint64_t*)&cgen_var_206, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_206, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                unmarshal_VkPipelineLayoutCreateInfo(vkReadStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                uint64_t cgen_var_208;
                vkReadStream->read((uint64_t*)&cgen_var_208, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_208, (VkPipelineLayout*)pPipelineLayout, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreatePipelineLayout\n");;
                }
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = m_vk->vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
                uint64_t cgen_var_209;
                vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_209, 1);
                vkStream->write((uint64_t*)&cgen_var_209, 8);
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_210;
                vkReadStream->read((uint64_t*)&cgen_var_210, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_210, (VkDevice*)&device, 1);
                uint64_t cgen_var_211;
                vkReadStream->read((uint64_t*)&cgen_var_211, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_211, (VkPipelineLayout*)&pipelineLayout, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyPipelineLayout\n");;
                }
                m_vk->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSampler:
            {
                VkDevice device;
                const VkSamplerCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                uint64_t cgen_var_213;
                vkReadStream->read((uint64_t*)&cgen_var_213, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_213, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                unmarshal_VkSamplerCreateInfo(vkReadStream, (VkSamplerCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                uint64_t cgen_var_215;
                vkReadStream->read((uint64_t*)&cgen_var_215, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_215, (VkSampler*)pSampler, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSampler\n");;
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_vk->vkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
                uint64_t cgen_var_216;
                vkStream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_216, 1);
                vkStream->write((uint64_t*)&cgen_var_216, 8);
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySampler:
            {
                VkDevice device;
                VkSampler sampler;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_217;
                vkReadStream->read((uint64_t*)&cgen_var_217, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_217, (VkDevice*)&device, 1);
                uint64_t cgen_var_218;
                vkReadStream->read((uint64_t*)&cgen_var_218, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_218, (VkSampler*)&sampler, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySampler\n");;
                }
                m_vk->vkDestroySampler(device, sampler, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                uint64_t cgen_var_220;
                vkReadStream->read((uint64_t*)&cgen_var_220, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_220, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                uint64_t cgen_var_222;
                vkReadStream->read((uint64_t*)&cgen_var_222, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_222, (VkDescriptorSetLayout*)pSetLayout, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorSetLayout\n");;
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = m_vk->vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
                uint64_t cgen_var_223;
                vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_223, 1);
                vkStream->write((uint64_t*)&cgen_var_223, 8);
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_224;
                vkReadStream->read((uint64_t*)&cgen_var_224, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_224, (VkDevice*)&device, 1);
                uint64_t cgen_var_225;
                vkReadStream->read((uint64_t*)&cgen_var_225, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_225, (VkDescriptorSetLayout*)&descriptorSetLayout, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorSetLayout\n");;
                }
                m_vk->vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                VkDevice device;
                const VkDescriptorPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                uint64_t cgen_var_227;
                vkReadStream->read((uint64_t*)&cgen_var_227, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_227, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                unmarshal_VkDescriptorPoolCreateInfo(vkReadStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                uint64_t cgen_var_229;
                vkReadStream->read((uint64_t*)&cgen_var_229, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_229, (VkDescriptorPool*)pDescriptorPool, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorPool\n");;
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = m_vk->vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
                uint64_t cgen_var_230;
                vkStream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_230, 1);
                vkStream->write((uint64_t*)&cgen_var_230, 8);
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_231;
                vkReadStream->read((uint64_t*)&cgen_var_231, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_231, (VkDevice*)&device, 1);
                uint64_t cgen_var_232;
                vkReadStream->read((uint64_t*)&cgen_var_232, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_232, (VkDescriptorPool*)&descriptorPool, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorPool\n");;
                }
                m_vk->vkDestroyDescriptorPool(device, descriptorPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                uint64_t cgen_var_234;
                vkReadStream->read((uint64_t*)&cgen_var_234, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_234, (VkDevice*)&device, 1);
                uint64_t cgen_var_235;
                vkReadStream->read((uint64_t*)&cgen_var_235, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_235, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetDescriptorPool\n");;
                }
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = m_vk->vkResetDescriptorPool(device, descriptorPool, flags);
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                VkDevice device;
                const VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                uint64_t cgen_var_236;
                vkReadStream->read((uint64_t*)&cgen_var_236, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_236, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                unmarshal_VkDescriptorSetAllocateInfo(vkReadStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_237;
                    vkReadStream->alloc((void**)&cgen_var_237, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_237, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_237, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateDescriptorSets\n");;
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = m_vk->vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_238;
                    vkStream->alloc((void**)&cgen_var_238, pAllocateInfo->descriptorSetCount * 8);
                    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_238, pAllocateInfo->descriptorSetCount);
                    vkStream->write((uint64_t*)cgen_var_238, pAllocateInfo->descriptorSetCount * 8);
                }
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint64_t cgen_var_239;
                vkReadStream->read((uint64_t*)&cgen_var_239, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_239, (VkDevice*)&device, 1);
                uint64_t cgen_var_240;
                vkReadStream->read((uint64_t*)&cgen_var_240, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_240, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pDescriptorSets = (const VkDescriptorSet*)(uintptr_t)vkReadStream->getBe64();
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    if (((descriptorSetCount)))
                    {
                        uint64_t* cgen_var_242;
                        vkReadStream->alloc((void**)&cgen_var_242, ((descriptorSetCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_242, ((descriptorSetCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_242, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeDescriptorSets\n");;
                }
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = m_vk->vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                VkDevice device;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                const VkCopyDescriptorSet* pDescriptorCopies;
                uint64_t cgen_var_243;
                vkReadStream->read((uint64_t*)&cgen_var_243, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_243, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                vkReadStream->read((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    unmarshal_VkCopyDescriptorSet(vkReadStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSets\n");;
                }
                m_vk->vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                VkDevice device;
                const VkFramebufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                uint64_t cgen_var_244;
                vkReadStream->read((uint64_t*)&cgen_var_244, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_244, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                unmarshal_VkFramebufferCreateInfo(vkReadStream, (VkFramebufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                uint64_t cgen_var_246;
                vkReadStream->read((uint64_t*)&cgen_var_246, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_246, (VkFramebuffer*)pFramebuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateFramebuffer\n");;
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = m_vk->vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
                uint64_t cgen_var_247;
                vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_247, 1);
                vkStream->write((uint64_t*)&cgen_var_247, 8);
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                VkDevice device;
                VkFramebuffer framebuffer;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_248;
                vkReadStream->read((uint64_t*)&cgen_var_248, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_248, (VkDevice*)&device, 1);
                uint64_t cgen_var_249;
                vkReadStream->read((uint64_t*)&cgen_var_249, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_249, (VkFramebuffer*)&framebuffer, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyFramebuffer\n");;
                }
                m_vk->vkDestroyFramebuffer(device, framebuffer, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateRenderPass:
            {
                VkDevice device;
                const VkRenderPassCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                uint64_t cgen_var_251;
                vkReadStream->read((uint64_t*)&cgen_var_251, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_251, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                unmarshal_VkRenderPassCreateInfo(vkReadStream, (VkRenderPassCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_253;
                vkReadStream->read((uint64_t*)&cgen_var_253, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_253, (VkRenderPass*)pRenderPass, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateRenderPass\n");;
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = m_vk->vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
                uint64_t cgen_var_254;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_254, 1);
                vkStream->write((uint64_t*)&cgen_var_254, 8);
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                VkDevice device;
                VkRenderPass renderPass;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_255;
                vkReadStream->read((uint64_t*)&cgen_var_255, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_255, (VkDevice*)&device, 1);
                uint64_t cgen_var_256;
                vkReadStream->read((uint64_t*)&cgen_var_256, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_256, (VkRenderPass*)&renderPass, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyRenderPass\n");;
                }
                m_vk->vkDestroyRenderPass(device, renderPass, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                uint64_t cgen_var_258;
                vkReadStream->read((uint64_t*)&cgen_var_258, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_258, (VkDevice*)&device, 1);
                uint64_t cgen_var_259;
                vkReadStream->read((uint64_t*)&cgen_var_259, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_259, (VkRenderPass*)&renderPass, 1);
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                unmarshal_VkExtent2D(vkReadStream, (VkExtent2D*)(pGranularity));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRenderAreaGranularity\n");;
                }
                m_vk->vkGetRenderAreaGranularity(device, renderPass, pGranularity);
                marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateCommandPool:
            {
                VkDevice device;
                const VkCommandPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                uint64_t cgen_var_260;
                vkReadStream->read((uint64_t*)&cgen_var_260, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_260, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                unmarshal_VkCommandPoolCreateInfo(vkReadStream, (VkCommandPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                uint64_t cgen_var_262;
                vkReadStream->read((uint64_t*)&cgen_var_262, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_262, (VkCommandPool*)pCommandPool, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateCommandPool\n");;
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_vk->vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
                uint64_t cgen_var_263;
                vkStream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_263, 1);
                vkStream->write((uint64_t*)&cgen_var_263, 8);
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_264;
                vkReadStream->read((uint64_t*)&cgen_var_264, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_264, (VkDevice*)&device, 1);
                uint64_t cgen_var_265;
                vkReadStream->read((uint64_t*)&cgen_var_265, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_265, (VkCommandPool*)&commandPool, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyCommandPool\n");;
                }
                m_vk->vkDestroyCommandPool(device, commandPool, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                uint64_t cgen_var_267;
                vkReadStream->read((uint64_t*)&cgen_var_267, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_267, (VkDevice*)&device, 1);
                uint64_t cgen_var_268;
                vkReadStream->read((uint64_t*)&cgen_var_268, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_268, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandPool\n");;
                }
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_vk->vkResetCommandPool(device, commandPool, flags);
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateCommandBuffers\n");;
                }
                VkDevice device;
                const VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                uint64_t cgen_var_269;
                vkReadStream->read((uint64_t*)&cgen_var_269, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_269, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                unmarshal_VkCommandBufferAllocateInfo(vkReadStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_270;
                    vkReadStream->alloc((void**)&cgen_var_270, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_270, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_270, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_271;
                    vkStream->alloc((void**)&cgen_var_271, pAllocateInfo->commandBufferCount * 8);
                    vkStream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_271, pAllocateInfo->commandBufferCount);
                    vkStream->write((uint64_t*)cgen_var_271, pAllocateInfo->commandBufferCount * 8);
                }
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                if (m_logCalls) {
                    fprintf(stderr, "call vkFreeCommandBuffers\n");
                    ;
                }
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                uint64_t cgen_var_272;
                vkReadStream->read((uint64_t*)&cgen_var_272, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_272, (VkDevice*)&device, 1);
                uint64_t cgen_var_273;
                vkReadStream->read((uint64_t*)&cgen_var_273, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_273, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pCommandBuffers = (const VkCommandBuffer*)(uintptr_t)vkReadStream->getBe64();
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    if (((commandBufferCount)))
                    {
                        uint64_t* cgen_var_275;
                        vkReadStream->alloc((void**)&cgen_var_275, ((commandBufferCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_275, ((commandBufferCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_275, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                    }
                }
                m_state->on_vkFreeCommandBuffers(device, commandPool,
                                                 commandBufferCount,
                                                 pCommandBuffers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                uint64_t cgen_var_276;
                vkReadStream->read((uint64_t*)&cgen_var_276, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_276, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBeginCommandBuffer\n");;
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_vk->vkBeginCommandBuffer(commandBuffer, pBeginInfo);
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                uint64_t cgen_var_277;
                vkReadStream->read((uint64_t*)&cgen_var_277, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_277, (VkCommandBuffer*)&commandBuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEndCommandBuffer\n");;
                }
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = m_vk->vkEndCommandBuffer(commandBuffer);
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                if (m_logCalls) {
                    fprintf(stderr, "call vkResetCommandBuffer\n");
                    ;
                }
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                uint64_t cgen_var_278;
                vkReadStream->read((uint64_t*)&cgen_var_278, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_278, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return =
                        m_state->on_vkResetCommandBuffer(commandBuffer, flags);
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                uint64_t cgen_var_279;
                vkReadStream->read((uint64_t*)&cgen_var_279, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_279, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_280;
                vkReadStream->read((uint64_t*)&cgen_var_280, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_280, (VkPipeline*)&pipeline, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindPipeline\n");;
                }
                m_vk->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetViewport:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                uint64_t cgen_var_281;
                vkReadStream->read((uint64_t*)&cgen_var_281, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_281, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewport(vkReadStream, (VkViewport*)(pViewports + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetViewport\n");;
                }
                m_vk->vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetScissor:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                uint64_t cgen_var_282;
                vkReadStream->read((uint64_t*)&cgen_var_282, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_282, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&firstScissor, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&scissorCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pScissors + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetScissor\n");;
                }
                m_vk->vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                VkCommandBuffer commandBuffer;
                float lineWidth;
                uint64_t cgen_var_283;
                vkReadStream->read((uint64_t*)&cgen_var_283, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_283, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((float*)&lineWidth, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetLineWidth\n");;
                }
                m_vk->vkCmdSetLineWidth(commandBuffer, lineWidth);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                uint64_t cgen_var_284;
                vkReadStream->read((uint64_t*)&cgen_var_284, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_284, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((float*)&depthBiasConstantFactor, sizeof(float));
                vkReadStream->read((float*)&depthBiasClamp, sizeof(float));
                vkReadStream->read((float*)&depthBiasSlopeFactor, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDepthBias\n");;
                }
                m_vk->vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                uint64_t cgen_var_285;
                vkReadStream->read((uint64_t*)&cgen_var_285, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_285, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((float*)&blendConstants, 4 * sizeof(const float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetBlendConstants\n");;
                }
                m_vk->vkCmdSetBlendConstants(commandBuffer, blendConstants);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                uint64_t cgen_var_286;
                vkReadStream->read((uint64_t*)&cgen_var_286, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_286, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((float*)&minDepthBounds, sizeof(float));
                vkReadStream->read((float*)&maxDepthBounds, sizeof(float));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDepthBounds\n");;
                }
                m_vk->vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                uint64_t cgen_var_287;
                vkReadStream->read((uint64_t*)&cgen_var_287, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_287, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&compareMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilCompareMask\n");;
                }
                m_vk->vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                uint64_t cgen_var_288;
                vkReadStream->read((uint64_t*)&cgen_var_288, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_288, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&writeMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilWriteMask\n");;
                }
                m_vk->vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                uint64_t cgen_var_289;
                vkReadStream->read((uint64_t*)&cgen_var_289, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_289, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&reference, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetStencilReference\n");;
                }
                m_vk->vkCmdSetStencilReference(commandBuffer, faceMask, reference);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                uint64_t cgen_var_290;
                vkReadStream->read((uint64_t*)&cgen_var_290, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_290, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_291;
                vkReadStream->read((uint64_t*)&cgen_var_291, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_291, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&firstSet, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                if (((descriptorSetCount)))
                {
                    uint64_t* cgen_var_292;
                    vkReadStream->alloc((void**)&cgen_var_292, ((descriptorSetCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_292, ((descriptorSetCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_292, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                }
                vkReadStream->read((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindDescriptorSets\n");;
                }
                m_vk->vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                uint64_t cgen_var_293;
                vkReadStream->read((uint64_t*)&cgen_var_293, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_293, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_294;
                vkReadStream->read((uint64_t*)&cgen_var_294, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_294, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkIndexType*)&indexType, sizeof(VkIndexType));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindIndexBuffer\n");;
                }
                m_vk->vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                uint64_t cgen_var_295;
                vkReadStream->read((uint64_t*)&cgen_var_295, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_295, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&firstBinding, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bindingCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint64_t* cgen_var_296;
                    vkReadStream->alloc((void**)&cgen_var_296, ((bindingCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_296, ((bindingCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(cgen_var_296, (VkBuffer*)pBuffers, ((bindingCount)));
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindVertexBuffers\n");;
                }
                m_vk->vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDraw:
            {
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                uint64_t cgen_var_297;
                vkReadStream->read((uint64_t*)&cgen_var_297, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_297, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&vertexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstVertex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDraw\n");;
                }
                m_vk->vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                uint64_t cgen_var_298;
                vkReadStream->read((uint64_t*)&cgen_var_298, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_298, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&indexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstIndex, sizeof(uint32_t));
                vkReadStream->read((int32_t*)&vertexOffset, sizeof(int32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexed\n");;
                }
                m_vk->vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                uint64_t cgen_var_299;
                vkReadStream->read((uint64_t*)&cgen_var_299, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_299, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_300;
                vkReadStream->read((uint64_t*)&cgen_var_300, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_300, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirect\n");;
                }
                m_vk->vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                uint64_t cgen_var_301;
                vkReadStream->read((uint64_t*)&cgen_var_301, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_301, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_302;
                vkReadStream->read((uint64_t*)&cgen_var_302, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_302, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirect\n");;
                }
                m_vk->vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatch:
            {
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                uint64_t cgen_var_303;
                vkReadStream->read((uint64_t*)&cgen_var_303, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_303, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatch\n");;
                }
                m_vk->vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint64_t cgen_var_304;
                vkReadStream->read((uint64_t*)&cgen_var_304, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_304, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_305;
                vkReadStream->read((uint64_t*)&cgen_var_305, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_305, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchIndirect\n");;
                }
                m_vk->vkCmdDispatchIndirect(commandBuffer, buffer, offset);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                uint64_t cgen_var_306;
                vkReadStream->read((uint64_t*)&cgen_var_306, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_306, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_307;
                vkReadStream->read((uint64_t*)&cgen_var_307, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_307, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_308;
                vkReadStream->read((uint64_t*)&cgen_var_308, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_308, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferCopy(vkReadStream, (VkBufferCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyBuffer\n");;
                }
                m_vk->vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                uint64_t cgen_var_309;
                vkReadStream->read((uint64_t*)&cgen_var_309, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_309, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_310;
                vkReadStream->read((uint64_t*)&cgen_var_310, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_310, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_311;
                vkReadStream->read((uint64_t*)&cgen_var_311, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_311, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageCopy(vkReadStream, (VkImageCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyImage\n");;
                }
                m_vk->vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBlitImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkFilter filter;
                uint64_t cgen_var_312;
                vkReadStream->read((uint64_t*)&cgen_var_312, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_312, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_313;
                vkReadStream->read((uint64_t*)&cgen_var_313, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_313, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_314;
                vkReadStream->read((uint64_t*)&cgen_var_314, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_314, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageBlit(vkReadStream, (VkImageBlit*)(pRegions + i));
                }
                vkReadStream->read((VkFilter*)&filter, sizeof(VkFilter));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBlitImage\n");;
                }
                m_vk->vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyBufferToImage\n");;
                }
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                uint64_t cgen_var_315;
                vkReadStream->read((uint64_t*)&cgen_var_315, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_315, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_316;
                vkReadStream->read((uint64_t*)&cgen_var_316, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_316, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_317;
                vkReadStream->read((uint64_t*)&cgen_var_317, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_317, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                m_state->on_vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                uint64_t cgen_var_318;
                vkReadStream->read((uint64_t*)&cgen_var_318, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_318, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_319;
                vkReadStream->read((uint64_t*)&cgen_var_319, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_319, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_320;
                vkReadStream->read((uint64_t*)&cgen_var_320, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_320, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyImageToBuffer\n");;
                }
                m_vk->vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                uint64_t cgen_var_321;
                vkReadStream->read((uint64_t*)&cgen_var_321, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_321, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_322;
                vkReadStream->read((uint64_t*)&cgen_var_322, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_322, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdUpdateBuffer\n");;
                }
                m_vk->vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                uint64_t cgen_var_323;
                vkReadStream->read((uint64_t*)&cgen_var_323, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_323, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_324;
                vkReadStream->read((uint64_t*)&cgen_var_324, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_324, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&data, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdFillBuffer\n");;
                }
                m_vk->vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                uint64_t cgen_var_325;
                vkReadStream->read((uint64_t*)&cgen_var_325, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_325, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_326;
                vkReadStream->read((uint64_t*)&cgen_var_326, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_326, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                unmarshal_VkClearColorValue(vkReadStream, (VkClearColorValue*)(pColor));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearColorImage\n");;
                }
                m_vk->vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                uint64_t cgen_var_327;
                vkReadStream->read((uint64_t*)&cgen_var_327, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_327, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_328;
                vkReadStream->read((uint64_t*)&cgen_var_328, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_328, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                unmarshal_VkClearDepthStencilValue(vkReadStream, (VkClearDepthStencilValue*)(pDepthStencil));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearDepthStencilImage\n");;
                }
                m_vk->vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                uint32_t rectCount;
                const VkClearRect* pRects;
                uint64_t cgen_var_329;
                vkReadStream->read((uint64_t*)&cgen_var_329, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_329, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&attachmentCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    unmarshal_VkClearAttachment(vkReadStream, (VkClearAttachment*)(pAttachments + i));
                }
                vkReadStream->read((uint32_t*)&rectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    unmarshal_VkClearRect(vkReadStream, (VkClearRect*)(pRects + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdClearAttachments\n");;
                }
                m_vk->vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResolveImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                uint64_t cgen_var_330;
                vkReadStream->read((uint64_t*)&cgen_var_330, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_330, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_331;
                vkReadStream->read((uint64_t*)&cgen_var_331, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_331, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_332;
                vkReadStream->read((uint64_t*)&cgen_var_332, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_332, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageResolve(vkReadStream, (VkImageResolve*)(pRegions + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResolveImage\n");;
                }
                m_vk->vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                uint64_t cgen_var_333;
                vkReadStream->read((uint64_t*)&cgen_var_333, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_333, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_334;
                vkReadStream->read((uint64_t*)&cgen_var_334, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_334, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetEvent\n");;
                }
                m_vk->vkCmdSetEvent(commandBuffer, event, stageMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                uint64_t cgen_var_335;
                vkReadStream->read((uint64_t*)&cgen_var_335, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_335, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_336;
                vkReadStream->read((uint64_t*)&cgen_var_336, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_336, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResetEvent\n");;
                }
                m_vk->vkCmdResetEvent(commandBuffer, event, stageMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                uint64_t cgen_var_337;
                vkReadStream->read((uint64_t*)&cgen_var_337, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_337, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&eventCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                if (((eventCount)))
                {
                    uint64_t* cgen_var_338;
                    vkReadStream->alloc((void**)&cgen_var_338, ((eventCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_338, ((eventCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkEvent(cgen_var_338, (VkEvent*)pEvents, ((eventCount)));
                }
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWaitEvents\n");;
                }
                m_vk->vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                uint64_t cgen_var_339;
                vkReadStream->read((uint64_t*)&cgen_var_339, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_339, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPipelineBarrier\n");;
                }
                m_vk->vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                uint64_t cgen_var_340;
                vkReadStream->read((uint64_t*)&cgen_var_340, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_340, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_341;
                vkReadStream->read((uint64_t*)&cgen_var_341, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_341, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vkReadStream->read((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginQuery\n");;
                }
                m_vk->vkCmdBeginQuery(commandBuffer, queryPool, query, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                uint64_t cgen_var_342;
                vkReadStream->read((uint64_t*)&cgen_var_342, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_342, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_343;
                vkReadStream->read((uint64_t*)&cgen_var_343, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_343, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndQuery\n");;
                }
                m_vk->vkCmdEndQuery(commandBuffer, queryPool, query);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                uint64_t cgen_var_344;
                vkReadStream->read((uint64_t*)&cgen_var_344, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_344, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_345;
                vkReadStream->read((uint64_t*)&cgen_var_345, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_345, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdResetQueryPool\n");;
                }
                m_vk->vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                uint64_t cgen_var_346;
                vkReadStream->read((uint64_t*)&cgen_var_346, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_346, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_347;
                vkReadStream->read((uint64_t*)&cgen_var_347, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_347, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWriteTimestamp\n");;
                }
                m_vk->vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                uint64_t cgen_var_348;
                vkReadStream->read((uint64_t*)&cgen_var_348, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_348, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_349;
                vkReadStream->read((uint64_t*)&cgen_var_349, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_349, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                uint64_t cgen_var_350;
                vkReadStream->read((uint64_t*)&cgen_var_350, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_350, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyQueryPoolResults\n");;
                }
                m_vk->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPushConstants:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                uint64_t cgen_var_351;
                vkReadStream->read((uint64_t*)&cgen_var_351, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_351, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_352;
                vkReadStream->read((uint64_t*)&cgen_var_352, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_352, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
                vkReadStream->read((uint32_t*)&offset, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&size, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pValues, ((size)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushConstants\n");;
                }
                m_vk->vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                uint64_t cgen_var_353;
                vkReadStream->read((uint64_t*)&cgen_var_353, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_353, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginRenderPass\n");;
                }
                m_vk->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                uint64_t cgen_var_354;
                vkReadStream->read((uint64_t*)&cgen_var_354, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_354, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdNextSubpass\n");;
                }
                m_vk->vkCmdNextSubpass(commandBuffer, contents);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                VkCommandBuffer commandBuffer;
                uint64_t cgen_var_355;
                vkReadStream->read((uint64_t*)&cgen_var_355, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_355, (VkCommandBuffer*)&commandBuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndRenderPass\n");;
                }
                m_vk->vkCmdEndRenderPass(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdExecuteCommands\n");;
                }
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                uint64_t cgen_var_356;
                vkReadStream->read((uint64_t*)&cgen_var_356, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_356, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (((commandBufferCount)))
                {
                    uint64_t* cgen_var_357;
                    vkReadStream->alloc((void**)&cgen_var_357, ((commandBufferCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_357, ((commandBufferCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_357, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                }
                m_state->on_vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                uint32_t* pApiVersion;
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceVersion\n");;
                }
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_vk->vkEnumerateInstanceVersion(pApiVersion);
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                uint64_t cgen_var_358;
                vkReadStream->read((uint64_t*)&cgen_var_358, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_358, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2\n");;
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_vk->vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                uint64_t cgen_var_359;
                vkReadStream->read((uint64_t*)&cgen_var_359, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_359, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory2\n");;
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = m_vk->vkBindImageMemory2(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                uint64_t cgen_var_360;
                vkReadStream->read((uint64_t*)&cgen_var_360, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_360, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPeerMemoryFeatures\n");;
                }
                m_vk->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                uint64_t cgen_var_361;
                vkReadStream->read((uint64_t*)&cgen_var_361, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_361, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDeviceMask\n");;
                }
                m_vk->vkCmdSetDeviceMask(commandBuffer, deviceMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                uint64_t cgen_var_362;
                vkReadStream->read((uint64_t*)&cgen_var_362, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_362, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchBase\n");;
                }
                m_vk->vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                uint64_t cgen_var_363;
                vkReadStream->read((uint64_t*)&cgen_var_363, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_363, (VkInstance*)&instance, 1);
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDeviceGroups\n");;
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = m_vk->vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_366 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_366);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_367 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_367);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                uint64_t cgen_var_368;
                vkReadStream->read((uint64_t*)&cgen_var_368, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_368, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2\n");;
                }
                m_vk->vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                uint64_t cgen_var_369;
                vkReadStream->read((uint64_t*)&cgen_var_369, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_369, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements2\n");;
                }
                m_vk->vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                uint64_t cgen_var_370;
                vkReadStream->read((uint64_t*)&cgen_var_370, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_370, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements2\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                // WARNING PTR CHECK
                uint64_t cgen_var_373 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_373);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_374 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_374);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                uint64_t cgen_var_375;
                vkReadStream->read((uint64_t*)&cgen_var_375, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_375, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2\n");;
                }
                m_vk->vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                uint64_t cgen_var_376;
                vkReadStream->read((uint64_t*)&cgen_var_376, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_376, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                uint64_t cgen_var_377;
                vkReadStream->read((uint64_t*)&cgen_var_377, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_377, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                uint64_t cgen_var_378;
                vkReadStream->read((uint64_t*)&cgen_var_378, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_378, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                uint64_t cgen_var_379;
                vkReadStream->read((uint64_t*)&cgen_var_379, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_379, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_382 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_382);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_383 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_383);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                uint64_t cgen_var_384;
                vkReadStream->read((uint64_t*)&cgen_var_384, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_384, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                uint64_t cgen_var_385;
                vkReadStream->read((uint64_t*)&cgen_var_385, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_385, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties2\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_388 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_388);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_389 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_389);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkTrimCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                uint64_t cgen_var_390;
                vkReadStream->read((uint64_t*)&cgen_var_390, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_390, (VkDevice*)&device, 1);
                uint64_t cgen_var_391;
                vkReadStream->read((uint64_t*)&cgen_var_391, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_391, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkTrimCommandPool\n");;
                }
                m_vk->vkTrimCommandPool(device, commandPool, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                VkDevice device;
                const VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                uint64_t cgen_var_392;
                vkReadStream->read((uint64_t*)&cgen_var_392, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_392, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                unmarshal_VkDeviceQueueInfo2(vkReadStream, (VkDeviceQueueInfo2*)(pQueueInfo));
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_393;
                vkReadStream->read((uint64_t*)&cgen_var_393, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_393, (VkQueue*)pQueue, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceQueue2\n");;
                }
                m_vk->vkGetDeviceQueue2(device, pQueueInfo, pQueue);
                uint64_t cgen_var_394;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_394, 1);
                vkStream->write((uint64_t*)&cgen_var_394, 8);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                uint64_t cgen_var_395;
                vkReadStream->read((uint64_t*)&cgen_var_395, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_395, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_397;
                vkReadStream->read((uint64_t*)&cgen_var_397, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_397, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSamplerYcbcrConversion\n");;
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = m_vk->vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
                uint64_t cgen_var_398;
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_398, 1);
                vkStream->write((uint64_t*)&cgen_var_398, 8);
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_399;
                vkReadStream->read((uint64_t*)&cgen_var_399, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_399, (VkDevice*)&device, 1);
                uint64_t cgen_var_400;
                vkReadStream->read((uint64_t*)&cgen_var_400, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_400, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySamplerYcbcrConversion\n");;
                }
                m_vk->vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                uint64_t cgen_var_402;
                vkReadStream->read((uint64_t*)&cgen_var_402, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_402, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_404;
                vkReadStream->read((uint64_t*)&cgen_var_404, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_404, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplate\n");;
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_vk->vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                uint64_t cgen_var_405;
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_405, 1);
                vkStream->write((uint64_t*)&cgen_var_405, 8);
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_406;
                vkReadStream->read((uint64_t*)&cgen_var_406, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_406, (VkDevice*)&device, 1);
                uint64_t cgen_var_407;
                vkReadStream->read((uint64_t*)&cgen_var_407, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_407, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplate\n");;
                }
                m_vk->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                uint64_t cgen_var_409;
                vkReadStream->read((uint64_t*)&cgen_var_409, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_409, (VkDevice*)&device, 1);
                uint64_t cgen_var_410;
                vkReadStream->read((uint64_t*)&cgen_var_410, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_410, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_411;
                vkReadStream->read((uint64_t*)&cgen_var_411, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_411, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSetWithTemplate\n");;
                }
                m_vk->vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                uint64_t cgen_var_413;
                vkReadStream->read((uint64_t*)&cgen_var_413, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_413, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalBufferProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                uint64_t cgen_var_414;
                vkReadStream->read((uint64_t*)&cgen_var_414, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_414, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalFenceProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                uint64_t cgen_var_415;
                vkReadStream->read((uint64_t*)&cgen_var_415, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_415, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphoreProperties\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                uint64_t cgen_var_416;
                vkReadStream->read((uint64_t*)&cgen_var_416, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_416, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDescriptorSetLayoutSupport\n");;
                }
                m_vk->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                VkInstance instance;
                VkSurfaceKHR surface;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_417;
                vkReadStream->read((uint64_t*)&cgen_var_417, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_417, (VkInstance*)&instance, 1);
                uint64_t cgen_var_418;
                vkReadStream->read((uint64_t*)&cgen_var_418, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_418, (VkSurfaceKHR*)&surface, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySurfaceKHR\n");;
                }
                m_vk->vkDestroySurfaceKHR(instance, surface, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                uint64_t cgen_var_420;
                vkReadStream->read((uint64_t*)&cgen_var_420, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_420, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                uint64_t cgen_var_421;
                vkReadStream->read((uint64_t*)&cgen_var_421, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_421, (VkSurfaceKHR*)&surface, 1);
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                vkReadStream->read((VkBool32*)pSupported, sizeof(VkBool32));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceSupportKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                uint64_t cgen_var_422;
                vkReadStream->read((uint64_t*)&cgen_var_422, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_422, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_423;
                vkReadStream->read((uint64_t*)&cgen_var_423, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_423, (VkSurfaceKHR*)&surface, 1);
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                unmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilitiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                uint64_t cgen_var_424;
                vkReadStream->read((uint64_t*)&cgen_var_424, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_424, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_425;
                vkReadStream->read((uint64_t*)&cgen_var_425, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_425, (VkSurfaceKHR*)&surface, 1);
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormatKHR(vkReadStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceFormatsKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                // WARNING PTR CHECK
                uint64_t cgen_var_428 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_428);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_429 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_429);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                uint64_t cgen_var_430;
                vkReadStream->read((uint64_t*)&cgen_var_430, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_430, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_431;
                vkReadStream->read((uint64_t*)&cgen_var_431, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_431, (VkSurfaceKHR*)&surface, 1);
                // WARNING PTR CHECK
                pPresentModeCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pPresentModes = (VkPresentModeKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    vkReadStream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfacePresentModesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
                // WARNING PTR CHECK
                uint64_t cgen_var_434 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_434);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_435 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_435);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                VkDevice device;
                const VkSwapchainCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                uint64_t cgen_var_436;
                vkReadStream->read((uint64_t*)&cgen_var_436, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_436, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                uint64_t cgen_var_438;
                vkReadStream->read((uint64_t*)&cgen_var_438, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_438, (VkSwapchainKHR*)pSwapchain, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSwapchainKHR\n");;
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = m_vk->vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
                uint64_t cgen_var_439;
                vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_439, 1);
                vkStream->write((uint64_t*)&cgen_var_439, 8);
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_440;
                vkReadStream->read((uint64_t*)&cgen_var_440, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_440, (VkDevice*)&device, 1);
                uint64_t cgen_var_441;
                vkReadStream->read((uint64_t*)&cgen_var_441, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_441, (VkSwapchainKHR*)&swapchain, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySwapchainKHR\n");;
                }
                m_vk->vkDestroySwapchainKHR(device, swapchain, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                uint64_t cgen_var_443;
                vkReadStream->read((uint64_t*)&cgen_var_443, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_443, (VkDevice*)&device, 1);
                uint64_t cgen_var_444;
                vkReadStream->read((uint64_t*)&cgen_var_444, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_444, (VkSwapchainKHR*)&swapchain, 1);
                // WARNING PTR CHECK
                pSwapchainImageCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSwapchainImages = (VkImage*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_447;
                        vkReadStream->alloc((void**)&cgen_var_447, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_447, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkImage(cgen_var_447, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainImagesKHR\n");;
                }
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = m_vk->vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
                // WARNING PTR CHECK
                uint64_t cgen_var_448 = (uint64_t)(uintptr_t)pSwapchainImageCount;
                vkStream->putBe64(cgen_var_448);
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_449 = (uint64_t)(uintptr_t)pSwapchainImages;
                vkStream->putBe64(cgen_var_449);
                if (pSwapchainImages)
                {
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_450;
                        vkStream->alloc((void**)&cgen_var_450, (*(pSwapchainImageCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_450, (*(pSwapchainImageCount)));
                        vkStream->write((uint64_t*)cgen_var_450, (*(pSwapchainImageCount)) * 8);
                    }
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                uint64_t cgen_var_451;
                vkReadStream->read((uint64_t*)&cgen_var_451, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_451, (VkDevice*)&device, 1);
                uint64_t cgen_var_452;
                vkReadStream->read((uint64_t*)&cgen_var_452, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_452, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                uint64_t cgen_var_453;
                vkReadStream->read((uint64_t*)&cgen_var_453, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_453, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_454;
                vkReadStream->read((uint64_t*)&cgen_var_454, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_454, (VkFence*)&fence, 1);
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireNextImageKHR\n");;
                }
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = m_vk->vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                VkQueue queue;
                const VkPresentInfoKHR* pPresentInfo;
                uint64_t cgen_var_455;
                vkReadStream->read((uint64_t*)&cgen_var_455, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_455, (VkQueue*)&queue, 1);
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                unmarshal_VkPresentInfoKHR(vkReadStream, (VkPresentInfoKHR*)(pPresentInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueuePresentKHR\n");;
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = m_vk->vkQueuePresentKHR(queue, pPresentInfo);
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                uint64_t cgen_var_456;
                vkReadStream->read((uint64_t*)&cgen_var_456, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_456, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                unmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPresentCapabilitiesKHR\n");;
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = m_vk->vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                uint64_t cgen_var_457;
                vkReadStream->read((uint64_t*)&cgen_var_457, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_457, (VkDevice*)&device, 1);
                uint64_t cgen_var_458;
                vkReadStream->read((uint64_t*)&cgen_var_458, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_458, (VkSurfaceKHR*)&surface, 1);
                // WARNING PTR CHECK
                pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    vkReadStream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupSurfacePresentModesKHR\n");;
                }
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = m_vk->vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
                // WARNING PTR CHECK
                uint64_t cgen_var_460 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_460);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                uint64_t cgen_var_461;
                vkReadStream->read((uint64_t*)&cgen_var_461, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_461, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_462;
                vkReadStream->read((uint64_t*)&cgen_var_462, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_462, (VkSurfaceKHR*)&surface, 1);
                // WARNING PTR CHECK
                pRectCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pRects = (VkRect2D*)(uintptr_t)vkReadStream->getBe64();
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDevicePresentRectanglesKHR\n");;
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = m_vk->vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
                // WARNING PTR CHECK
                uint64_t cgen_var_465 = (uint64_t)(uintptr_t)pRectCount;
                vkStream->putBe64(cgen_var_465);
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_466 = (uint64_t)(uintptr_t)pRects;
                vkStream->putBe64(cgen_var_466);
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                VkDevice device;
                const VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                uint64_t cgen_var_467;
                vkReadStream->read((uint64_t*)&cgen_var_467, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_467, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                unmarshal_VkAcquireNextImageInfoKHR(vkReadStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireNextImage2KHR\n");;
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = m_vk->vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                uint64_t cgen_var_468;
                vkReadStream->read((uint64_t*)&cgen_var_468, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_468, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPropertiesKHR(vkReadStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPropertiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_471 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_471);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_472 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_472);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                uint64_t cgen_var_473;
                vkReadStream->read((uint64_t*)&cgen_var_473, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_473, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPlanePropertiesKHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_476 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_476);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_477 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_477);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                uint64_t cgen_var_478;
                vkReadStream->read((uint64_t*)&cgen_var_478, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_478, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                // WARNING PTR CHECK
                pDisplayCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pDisplays = (VkDisplayKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_481;
                        vkReadStream->alloc((void**)&cgen_var_481, (*(pDisplayCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_481, (*(pDisplayCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_481, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneSupportedDisplaysKHR\n");;
                }
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = m_vk->vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
                // WARNING PTR CHECK
                uint64_t cgen_var_482 = (uint64_t)(uintptr_t)pDisplayCount;
                vkStream->putBe64(cgen_var_482);
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_483 = (uint64_t)(uintptr_t)pDisplays;
                vkStream->putBe64(cgen_var_483);
                if (pDisplays)
                {
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_484;
                        vkStream->alloc((void**)&cgen_var_484, (*(pDisplayCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_484, (*(pDisplayCount)));
                        vkStream->write((uint64_t*)cgen_var_484, (*(pDisplayCount)) * 8);
                    }
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                uint64_t cgen_var_485;
                vkReadStream->read((uint64_t*)&cgen_var_485, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_485, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_486;
                vkReadStream->read((uint64_t*)&cgen_var_486, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_486, (VkDisplayKHR*)&display, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModePropertiesKHR(vkReadStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayModePropertiesKHR\n");;
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = m_vk->vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_489 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_489);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_490 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_490);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                const VkDisplayModeCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                uint64_t cgen_var_491;
                vkReadStream->read((uint64_t*)&cgen_var_491, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_491, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_492;
                vkReadStream->read((uint64_t*)&cgen_var_492, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_492, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                unmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                uint64_t cgen_var_494;
                vkReadStream->read((uint64_t*)&cgen_var_494, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_494, (VkDisplayModeKHR*)pMode, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDisplayModeKHR\n");;
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = m_vk->vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
                uint64_t cgen_var_495;
                vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_495, 1);
                vkStream->write((uint64_t*)&cgen_var_495, 8);
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                uint64_t cgen_var_496;
                vkReadStream->read((uint64_t*)&cgen_var_496, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_496, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_497;
                vkReadStream->read((uint64_t*)&cgen_var_497, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_497, (VkDisplayModeKHR*)&mode, 1);
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                unmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneCapabilitiesKHR\n");;
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = m_vk->vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                VkInstance instance;
                const VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_498;
                vkReadStream->read((uint64_t*)&cgen_var_498, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_498, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                unmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_500;
                vkReadStream->read((uint64_t*)&cgen_var_500, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_500, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDisplayPlaneSurfaceKHR\n");;
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = m_vk->vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_501;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_501, 1);
                vkStream->write((uint64_t*)&cgen_var_501, 8);
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                uint64_t cgen_var_502;
                vkReadStream->read((uint64_t*)&cgen_var_502, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_502, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_504;
                    vkReadStream->alloc((void**)&cgen_var_504, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_504, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_504, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSharedSwapchainsKHR\n");;
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = m_vk->vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_505;
                    vkStream->alloc((void**)&cgen_var_505, ((swapchainCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_505, ((swapchainCount)));
                    vkStream->write((uint64_t*)cgen_var_505, ((swapchainCount)) * 8);
                }
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                VkInstance instance;
                const VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_506;
                vkReadStream->read((uint64_t*)&cgen_var_506, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_506, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                unmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_508;
                vkReadStream->read((uint64_t*)&cgen_var_508, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_508, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateXlibSurfaceKHR\n");;
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = m_vk->vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_509;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_509, 1);
                vkStream->write((uint64_t*)&cgen_var_509, 8);
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                uint64_t cgen_var_510;
                vkReadStream->read((uint64_t*)&cgen_var_510, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_510, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->read((VisualID*)&visualID, sizeof(VisualID));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceXlibPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                VkInstance instance;
                const VkXcbSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_511;
                vkReadStream->read((uint64_t*)&cgen_var_511, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_511, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
                unmarshal_VkXcbSurfaceCreateInfoKHR(vkReadStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_513;
                vkReadStream->read((uint64_t*)&cgen_var_513, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_513, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateXcbSurfaceKHR\n");;
                }
                VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXcbSurfaceKHR_VkResult_return = m_vk->vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_514;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_514, 1);
                vkStream->write((uint64_t*)&cgen_var_514, 8);
                vkStream->write(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                xcb_connection_t* connection;
                xcb_visualid_t visual_id;
                uint64_t cgen_var_515;
                vkReadStream->read((uint64_t*)&cgen_var_515, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_515, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceXcbPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
                vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkStream->write(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                VkInstance instance;
                const VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_516;
                vkReadStream->read((uint64_t*)&cgen_var_516, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_516, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                unmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_518;
                vkReadStream->read((uint64_t*)&cgen_var_518, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_518, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateWaylandSurfaceKHR\n");;
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = m_vk->vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_519;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_519, 1);
                vkStream->write((uint64_t*)&cgen_var_519, 8);
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                uint64_t cgen_var_520;
                vkReadStream->read((uint64_t*)&cgen_var_520, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_520, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                vkReadStream->read((wl_display*)display, sizeof(wl_display));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceWaylandPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_mir_surface
            case OP_vkCreateMirSurfaceKHR:
            {
                VkInstance instance;
                const VkMirSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_521;
                vkReadStream->read((uint64_t*)&cgen_var_521, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_521, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
                unmarshal_VkMirSurfaceCreateInfoKHR(vkReadStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_523;
                vkReadStream->read((uint64_t*)&cgen_var_523, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_523, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateMirSurfaceKHR\n");;
                }
                VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateMirSurfaceKHR_VkResult_return = m_vk->vkCreateMirSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_524;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_524, 1);
                vkStream->write((uint64_t*)&cgen_var_524, 8);
                vkStream->write(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMirPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                MirConnection* connection;
                uint64_t cgen_var_525;
                vkReadStream->read((uint64_t*)&cgen_var_525, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_525, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&connection, sizeof(MirConnection));
                vkReadStream->read((MirConnection*)connection, sizeof(MirConnection));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMirPresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceMirPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection);
                vkStream->write((MirConnection*)connection, sizeof(MirConnection));
                vkStream->write(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                VkInstance instance;
                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_526;
                vkReadStream->read((uint64_t*)&cgen_var_526, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_526, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                unmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_528;
                vkReadStream->read((uint64_t*)&cgen_var_528, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_528, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateAndroidSurfaceKHR\n");;
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = m_vk->vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_529;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_529, 1);
                vkStream->write((uint64_t*)&cgen_var_529, 8);
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                VkInstance instance;
                const VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_530;
                vkReadStream->read((uint64_t*)&cgen_var_530, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_530, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                unmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_532;
                vkReadStream->read((uint64_t*)&cgen_var_532, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_532, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateWin32SurfaceKHR\n");;
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = m_vk->vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_533;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_533, 1);
                vkStream->write((uint64_t*)&cgen_var_533, 8);
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                uint64_t cgen_var_534;
                vkReadStream->read((uint64_t*)&cgen_var_534, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_534, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceWin32PresentationSupportKHR\n");;
                }
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = m_vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                uint64_t cgen_var_535;
                vkReadStream->read((uint64_t*)&cgen_var_535, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_535, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                uint64_t cgen_var_536;
                vkReadStream->read((uint64_t*)&cgen_var_536, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_536, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                uint64_t cgen_var_537;
                vkReadStream->read((uint64_t*)&cgen_var_537, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_537, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                uint64_t cgen_var_538;
                vkReadStream->read((uint64_t*)&cgen_var_538, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_538, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                uint64_t cgen_var_539;
                vkReadStream->read((uint64_t*)&cgen_var_539, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_539, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceQueueFamilyProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_542 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_542);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_543 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_543);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                uint64_t cgen_var_544;
                vkReadStream->read((uint64_t*)&cgen_var_544, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_544, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                uint64_t cgen_var_545;
                vkReadStream->read((uint64_t*)&cgen_var_545, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_545, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSparseImageFormatProperties2KHR\n");;
                }
                m_vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_548 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_548);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_549 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_549);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                uint64_t cgen_var_550;
                vkReadStream->read((uint64_t*)&cgen_var_550, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_550, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceGroupPeerMemoryFeaturesKHR\n");;
                }
                m_vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                uint64_t cgen_var_551;
                vkReadStream->read((uint64_t*)&cgen_var_551, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_551, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDeviceMaskKHR\n");;
                }
                m_vk->vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                uint64_t cgen_var_552;
                vkReadStream->read((uint64_t*)&cgen_var_552, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_552, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDispatchBaseKHR\n");;
                }
                m_vk->vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                uint64_t cgen_var_553;
                vkReadStream->read((uint64_t*)&cgen_var_553, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_553, (VkDevice*)&device, 1);
                uint64_t cgen_var_554;
                vkReadStream->read((uint64_t*)&cgen_var_554, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_554, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkTrimCommandPoolKHR\n");;
                }
                m_vk->vkTrimCommandPoolKHR(device, commandPool, flags);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                uint64_t cgen_var_555;
                vkReadStream->read((uint64_t*)&cgen_var_555, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_555, (VkInstance*)&instance, 1);
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDeviceGroupsKHR\n");;
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = m_vk->vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_558 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_558);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_559 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_559);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                uint64_t cgen_var_560;
                vkReadStream->read((uint64_t*)&cgen_var_560, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_560, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalBufferPropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                VkDevice device;
                const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                uint64_t cgen_var_561;
                vkReadStream->read((uint64_t*)&cgen_var_561, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_561, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                unmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandleKHR\n");;
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = m_vk->vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                uint64_t cgen_var_562;
                vkReadStream->read((uint64_t*)&cgen_var_562, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_562, (VkDevice*)&device, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((HANDLE*)&handle, sizeof(HANDLE));
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                unmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandlePropertiesKHR\n");;
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = m_vk->vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                VkDevice device;
                const VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                uint64_t cgen_var_563;
                vkReadStream->read((uint64_t*)&cgen_var_563, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_563, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                unmarshal_VkMemoryGetFdInfoKHR(vkReadStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryFdKHR\n");;
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = m_vk->vkGetMemoryFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                uint64_t cgen_var_564;
                vkReadStream->read((uint64_t*)&cgen_var_564, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_564, (VkDevice*)&device, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((int*)&fd, sizeof(int));
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                unmarshal_VkMemoryFdPropertiesKHR(vkReadStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryFdPropertiesKHR\n");;
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = m_vk->vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
                marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                uint64_t cgen_var_565;
                vkReadStream->read((uint64_t*)&cgen_var_565, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_565, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                uint64_t cgen_var_566;
                vkReadStream->read((uint64_t*)&cgen_var_566, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_566, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                unmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportSemaphoreWin32HandleKHR\n");;
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = m_vk->vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                uint64_t cgen_var_567;
                vkReadStream->read((uint64_t*)&cgen_var_567, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_567, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                unmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSemaphoreWin32HandleKHR\n");;
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = m_vk->vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                VkDevice device;
                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                uint64_t cgen_var_568;
                vkReadStream->read((uint64_t*)&cgen_var_568, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_568, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                unmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportSemaphoreFdKHR\n");;
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_vk->vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                VkDevice device;
                const VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                uint64_t cgen_var_569;
                vkReadStream->read((uint64_t*)&cgen_var_569, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_569, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                unmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSemaphoreFdKHR\n");;
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_vk->vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint64_t cgen_var_570;
                vkReadStream->read((uint64_t*)&cgen_var_570, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_570, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_571;
                vkReadStream->read((uint64_t*)&cgen_var_571, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_571, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushDescriptorSetKHR\n");;
                }
                m_vk->vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                const void* pData;
                uint64_t cgen_var_572;
                vkReadStream->read((uint64_t*)&cgen_var_572, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_572, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_573;
                vkReadStream->read((uint64_t*)&cgen_var_573, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_573, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                uint64_t cgen_var_574;
                vkReadStream->read((uint64_t*)&cgen_var_574, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_574, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPushDescriptorSetWithTemplateKHR\n");;
                }
                m_vk->vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                uint64_t cgen_var_576;
                vkReadStream->read((uint64_t*)&cgen_var_576, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_576, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_578;
                vkReadStream->read((uint64_t*)&cgen_var_578, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_578, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplateKHR\n");;
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_vk->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                uint64_t cgen_var_579;
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_579, 1);
                vkStream->write((uint64_t*)&cgen_var_579, 8);
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_580;
                vkReadStream->read((uint64_t*)&cgen_var_580, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_580, (VkDevice*)&device, 1);
                uint64_t cgen_var_581;
                vkReadStream->read((uint64_t*)&cgen_var_581, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_581, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplateKHR\n");;
                }
                m_vk->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                uint64_t cgen_var_583;
                vkReadStream->read((uint64_t*)&cgen_var_583, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_583, (VkDevice*)&device, 1);
                uint64_t cgen_var_584;
                vkReadStream->read((uint64_t*)&cgen_var_584, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_584, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_585;
                vkReadStream->read((uint64_t*)&cgen_var_585, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_585, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSetWithTemplateKHR\n");;
                }
                m_vk->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                VkDevice device;
                const VkRenderPassCreateInfo2KHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                uint64_t cgen_var_587;
                vkReadStream->read((uint64_t*)&cgen_var_587, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_587, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
                unmarshal_VkRenderPassCreateInfo2KHR(vkReadStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_589;
                vkReadStream->read((uint64_t*)&cgen_var_589, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_589, (VkRenderPass*)pRenderPass, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateRenderPass2KHR\n");;
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = m_vk->vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
                uint64_t cgen_var_590;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_590, 1);
                vkStream->write((uint64_t*)&cgen_var_590, 8);
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                uint64_t cgen_var_591;
                vkReadStream->read((uint64_t*)&cgen_var_591, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_591, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginRenderPass2KHR\n");;
                }
                m_vk->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                uint64_t cgen_var_592;
                vkReadStream->read((uint64_t*)&cgen_var_592, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_592, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdNextSubpass2KHR\n");;
                }
                m_vk->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                uint64_t cgen_var_593;
                vkReadStream->read((uint64_t*)&cgen_var_593, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_593, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndRenderPass2KHR\n");;
                }
                m_vk->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t cgen_var_594;
                vkReadStream->read((uint64_t*)&cgen_var_594, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_594, (VkDevice*)&device, 1);
                uint64_t cgen_var_595;
                vkReadStream->read((uint64_t*)&cgen_var_595, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_595, (VkSwapchainKHR*)&swapchain, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainStatusKHR\n");;
                }
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = m_vk->vkGetSwapchainStatusKHR(device, swapchain);
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                uint64_t cgen_var_596;
                vkReadStream->read((uint64_t*)&cgen_var_596, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_596, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalFencePropertiesKHR\n");;
                }
                m_vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                uint64_t cgen_var_597;
                vkReadStream->read((uint64_t*)&cgen_var_597, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_597, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                unmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportFenceWin32HandleKHR\n");;
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = m_vk->vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                uint64_t cgen_var_598;
                vkReadStream->read((uint64_t*)&cgen_var_598, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_598, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                unmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceWin32HandleKHR\n");;
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = m_vk->vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                VkDevice device;
                const VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                uint64_t cgen_var_599;
                vkReadStream->read((uint64_t*)&cgen_var_599, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_599, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                unmarshal_VkImportFenceFdInfoKHR(vkReadStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportFenceFdKHR\n");;
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = m_vk->vkImportFenceFdKHR(device, pImportFenceFdInfo);
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                VkDevice device;
                const VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                uint64_t cgen_var_600;
                vkReadStream->read((uint64_t*)&cgen_var_600, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_600, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                unmarshal_VkFenceGetFdInfoKHR(vkReadStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetFenceFdKHR\n");;
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = m_vk->vkGetFenceFdKHR(device, pGetFdInfo, pFd);
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                uint64_t cgen_var_601;
                vkReadStream->read((uint64_t*)&cgen_var_601, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_601, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                unmarshal_VkSurfaceCapabilities2KHR(vkReadStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilities2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                uint64_t cgen_var_602;
                vkReadStream->read((uint64_t*)&cgen_var_602, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_602, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormat2KHR(vkReadStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceFormats2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                // WARNING PTR CHECK
                uint64_t cgen_var_605 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_605);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_606 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_606);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                uint64_t cgen_var_607;
                vkReadStream->read((uint64_t*)&cgen_var_607, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_607, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayProperties2KHR(vkReadStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_610 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_610);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_611 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_611);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                uint64_t cgen_var_612;
                vkReadStream->read((uint64_t*)&cgen_var_612, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_612, (VkPhysicalDevice*)&physicalDevice, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceDisplayPlaneProperties2KHR\n");;
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = m_vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_615 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_615);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_616 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_616);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                uint64_t cgen_var_617;
                vkReadStream->read((uint64_t*)&cgen_var_617, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_617, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_618;
                vkReadStream->read((uint64_t*)&cgen_var_618, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_618, (VkDisplayKHR*)&display, 1);
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModeProperties2KHR(vkReadStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayModeProperties2KHR\n");;
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = m_vk->vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
                // WARNING PTR CHECK
                uint64_t cgen_var_621 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_621);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_622 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_622);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                uint64_t cgen_var_623;
                vkReadStream->read((uint64_t*)&cgen_var_623, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_623, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                unmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                unmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDisplayPlaneCapabilities2KHR\n");;
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = m_vk->vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                uint64_t cgen_var_624;
                vkReadStream->read((uint64_t*)&cgen_var_624, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_624, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                uint64_t cgen_var_625;
                vkReadStream->read((uint64_t*)&cgen_var_625, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_625, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetBufferMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                uint64_t cgen_var_626;
                vkReadStream->read((uint64_t*)&cgen_var_626, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_626, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageSparseMemoryRequirements2KHR\n");;
                }
                m_vk->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                // WARNING PTR CHECK
                uint64_t cgen_var_629 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_629);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_630 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_630);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                uint64_t cgen_var_631;
                vkReadStream->read((uint64_t*)&cgen_var_631, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_631, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_633;
                vkReadStream->read((uint64_t*)&cgen_var_633, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_633, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSamplerYcbcrConversionKHR\n");;
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = m_vk->vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
                uint64_t cgen_var_634;
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_634, 1);
                vkStream->write((uint64_t*)&cgen_var_634, 8);
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_635;
                vkReadStream->read((uint64_t*)&cgen_var_635, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_635, (VkDevice*)&device, 1);
                uint64_t cgen_var_636;
                vkReadStream->read((uint64_t*)&cgen_var_636, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_636, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySamplerYcbcrConversionKHR\n");;
                }
                m_vk->vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                uint64_t cgen_var_638;
                vkReadStream->read((uint64_t*)&cgen_var_638, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_638, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2KHR\n");;
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_vk->vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                uint64_t cgen_var_639;
                vkReadStream->read((uint64_t*)&cgen_var_639, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_639, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory2KHR\n");;
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = m_vk->vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                uint64_t cgen_var_640;
                vkReadStream->read((uint64_t*)&cgen_var_640, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_640, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDescriptorSetLayoutSupportKHR\n");;
                }
                m_vk->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_641;
                vkReadStream->read((uint64_t*)&cgen_var_641, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_641, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_642;
                vkReadStream->read((uint64_t*)&cgen_var_642, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_642, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_643;
                vkReadStream->read((uint64_t*)&cgen_var_643, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_643, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirectCountKHR\n");;
                }
                m_vk->vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_644;
                vkReadStream->read((uint64_t*)&cgen_var_644, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_644, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_645;
                vkReadStream->read((uint64_t*)&cgen_var_645, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_645, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_646;
                vkReadStream->read((uint64_t*)&cgen_var_646, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_646, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirectCountKHR\n");;
                }
                m_vk->vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_ANDROID_native_buffer
            case OP_vkGetSwapchainGrallocUsageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainGrallocUsageANDROID\n");;
                }
                VkDevice device;
                VkFormat format;
                VkImageUsageFlags imageUsage;
                int* grallocUsage;
                uint64_t cgen_var_647;
                vkReadStream->read((uint64_t*)&cgen_var_647, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_647, (VkDevice*)&device, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageUsageFlags*)&imageUsage, sizeof(VkImageUsageFlags));
                vkReadStream->alloc((void**)&grallocUsage, sizeof(int));
                vkReadStream->read((int*)grallocUsage, sizeof(int));
                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
                vkGetSwapchainGrallocUsageANDROID_VkResult_return = m_state->on_vkGetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage);
                vkStream->write((int*)grallocUsage, sizeof(int));
                vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkAcquireImageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireImageANDROID\n");;
                }
                VkDevice device;
                VkImage image;
                int nativeFenceFd;
                VkSemaphore semaphore;
                VkFence fence;
                uint64_t cgen_var_648;
                vkReadStream->read((uint64_t*)&cgen_var_648, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_648, (VkDevice*)&device, 1);
                uint64_t cgen_var_649;
                vkReadStream->read((uint64_t*)&cgen_var_649, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_649, (VkImage*)&image, 1);
                vkReadStream->read((int*)&nativeFenceFd, sizeof(int));
                uint64_t cgen_var_650;
                vkReadStream->read((uint64_t*)&cgen_var_650, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_650, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_651;
                vkReadStream->read((uint64_t*)&cgen_var_651, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_651, (VkFence*)&fence, 1);
                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence);
                vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueSignalReleaseImageANDROID\n");;
                }
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                int* pNativeFenceFd;
                uint64_t cgen_var_652;
                vkReadStream->read((uint64_t*)&cgen_var_652, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_652, (VkQueue*)&queue, 1);
                vkReadStream->read((uint32_t*)&waitSemaphoreCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pWaitSemaphores = (const VkSemaphore*)(uintptr_t)vkReadStream->getBe64();
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint64_t* cgen_var_654;
                        vkReadStream->alloc((void**)&cgen_var_654, ((waitSemaphoreCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_654, ((waitSemaphoreCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_654, (VkSemaphore*)pWaitSemaphores, ((waitSemaphoreCount)));
                    }
                }
                uint64_t cgen_var_655;
                vkReadStream->read((uint64_t*)&cgen_var_655, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_655, (VkImage*)&image, 1);
                vkReadStream->alloc((void**)&pNativeFenceFd, sizeof(int));
                vkReadStream->read((int*)pNativeFenceFd, sizeof(int));
                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
                vkQueueSignalReleaseImageANDROID_VkResult_return = m_state->on_vkQueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                vkStream->write((int*)pNativeFenceFd, sizeof(int));
                vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                VkInstance instance;
                const VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                uint64_t cgen_var_656;
                vkReadStream->read((uint64_t*)&cgen_var_656, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_656, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                unmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                uint64_t cgen_var_658;
                vkReadStream->read((uint64_t*)&cgen_var_658, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_658, (VkDebugReportCallbackEXT*)pCallback, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDebugReportCallbackEXT\n");;
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = m_vk->vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
                uint64_t cgen_var_659;
                vkStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_659, 1);
                vkStream->write((uint64_t*)&cgen_var_659, 8);
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_660;
                vkReadStream->read((uint64_t*)&cgen_var_660, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_660, (VkInstance*)&instance, 1);
                uint64_t cgen_var_661;
                vkReadStream->read((uint64_t*)&cgen_var_661, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_661, (VkDebugReportCallbackEXT*)&callback, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDebugReportCallbackEXT\n");;
                }
                m_vk->vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                const char* pLayerPrefix;
                const char* pMessage;
                uint64_t cgen_var_663;
                vkReadStream->read((uint64_t*)&cgen_var_663, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_663, (VkInstance*)&instance, 1);
                vkReadStream->read((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
                vkReadStream->read((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
                vkReadStream->read((uint64_t*)&object, sizeof(uint64_t));
                location = (size_t)vkReadStream->getBe64();
                vkReadStream->read((int32_t*)&messageCode, sizeof(int32_t));
                vkReadStream->loadStringInPlace((char**)&pLayerPrefix);
                vkReadStream->loadStringInPlace((char**)&pMessage);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugReportMessageEXT\n");;
                }
                m_vk->vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                uint64_t cgen_var_665;
                vkReadStream->read((uint64_t*)&cgen_var_665, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_665, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                unmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugMarkerSetObjectTagEXT\n");;
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = m_vk->vkDebugMarkerSetObjectTagEXT(device, pTagInfo);
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                uint64_t cgen_var_666;
                vkReadStream->read((uint64_t*)&cgen_var_666, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_666, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                unmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDebugMarkerSetObjectNameEXT\n");;
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = m_vk->vkDebugMarkerSetObjectNameEXT(device, pNameInfo);
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                uint64_t cgen_var_667;
                vkReadStream->read((uint64_t*)&cgen_var_667, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_667, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerBeginEXT\n");;
                }
                m_vk->vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                VkCommandBuffer commandBuffer;
                uint64_t cgen_var_668;
                vkReadStream->read((uint64_t*)&cgen_var_668, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_668, (VkCommandBuffer*)&commandBuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerEndEXT\n");;
                }
                m_vk->vkCmdDebugMarkerEndEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                uint64_t cgen_var_669;
                vkReadStream->read((uint64_t*)&cgen_var_669, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_669, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDebugMarkerInsertEXT\n");;
                }
                m_vk->vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_670;
                vkReadStream->read((uint64_t*)&cgen_var_670, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_670, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_671;
                vkReadStream->read((uint64_t*)&cgen_var_671, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_671, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_672;
                vkReadStream->read((uint64_t*)&cgen_var_672, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_672, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndirectCountAMD\n");;
                }
                m_vk->vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_673;
                vkReadStream->read((uint64_t*)&cgen_var_673, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_673, (VkCommandBuffer*)&commandBuffer, 1);
                uint64_t cgen_var_674;
                vkReadStream->read((uint64_t*)&cgen_var_674, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_674, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_675;
                vkReadStream->read((uint64_t*)&cgen_var_675, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_675, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdDrawIndexedIndirectCountAMD\n");;
                }
                m_vk->vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                uint64_t cgen_var_676;
                vkReadStream->read((uint64_t*)&cgen_var_676, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_676, (VkDevice*)&device, 1);
                uint64_t cgen_var_677;
                vkReadStream->read((uint64_t*)&cgen_var_677, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_677, (VkPipeline*)&pipeline, 1);
                vkReadStream->read((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
                vkReadStream->read((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
                // WARNING PTR CHECK
                pInfoSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    (*pInfoSize) = (size_t)vkReadStream->getBe64();
                }
                // WARNING PTR CHECK
                pInfo = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetShaderInfoAMD\n");;
                }
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = m_vk->vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                // WARNING PTR CHECK
                uint64_t cgen_var_681 = (uint64_t)(uintptr_t)pInfoSize;
                vkStream->putBe64(cgen_var_681);
                if (pInfoSize)
                {
                    uint64_t cgen_var_682 = (uint64_t)(*pInfoSize);
                    vkStream->putBe64(cgen_var_682);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_683 = (uint64_t)(uintptr_t)pInfo;
                vkStream->putBe64(cgen_var_683);
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                uint64_t cgen_var_684;
                vkReadStream->read((uint64_t*)&cgen_var_684, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_684, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                unmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalImageFormatPropertiesNV\n");;
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = m_vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                uint64_t cgen_var_685;
                vkReadStream->read((uint64_t*)&cgen_var_685, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_685, (VkDevice*)&device, 1);
                uint64_t cgen_var_686;
                vkReadStream->read((uint64_t*)&cgen_var_686, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_686, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryWin32HandleNV\n");;
                }
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = m_vk->vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle);
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                VkInstance instance;
                const VkViSurfaceCreateInfoNN* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_687;
                vkReadStream->read((uint64_t*)&cgen_var_687, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_687, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                unmarshal_VkViSurfaceCreateInfoNN(vkReadStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_689;
                vkReadStream->read((uint64_t*)&cgen_var_689, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_689, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateViSurfaceNN\n");;
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = m_vk->vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_690;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_690, 1);
                vkStream->write((uint64_t*)&cgen_var_690, 8);
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                uint64_t cgen_var_691;
                vkReadStream->read((uint64_t*)&cgen_var_691, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_691, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                unmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginConditionalRenderingEXT\n");;
                }
                m_vk->vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                uint64_t cgen_var_692;
                vkReadStream->read((uint64_t*)&cgen_var_692, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_692, (VkCommandBuffer*)&commandBuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndConditionalRenderingEXT\n");;
                }
                m_vk->vkCmdEndConditionalRenderingEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NVX_device_generated_commands
            case OP_vkCmdProcessCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo;
                uint64_t cgen_var_693;
                vkReadStream->read((uint64_t*)&cgen_var_693, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_693, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
                unmarshal_VkCmdProcessCommandsInfoNVX(vkReadStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdProcessCommandsNVX\n");;
                }
                m_vk->vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdReserveSpaceForCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo;
                uint64_t cgen_var_694;
                vkReadStream->read((uint64_t*)&cgen_var_694, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_694, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
                unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkReadStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdReserveSpaceForCommandsNVX\n");;
                }
                m_vk->vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout;
                uint64_t cgen_var_695;
                vkReadStream->read((uint64_t*)&cgen_var_695, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_695, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
                unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkReadStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                uint64_t cgen_var_697;
                vkReadStream->read((uint64_t*)&cgen_var_697, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_697, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateIndirectCommandsLayoutNVX\n");;
                }
                VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNVX_VkResult_return = m_vk->vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                uint64_t cgen_var_698;
                vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_698, 1);
                vkStream->write((uint64_t*)&cgen_var_698, 8);
                vkStream->write(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                VkIndirectCommandsLayoutNVX indirectCommandsLayout;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_699;
                vkReadStream->read((uint64_t*)&cgen_var_699, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_699, (VkDevice*)&device, 1);
                uint64_t cgen_var_700;
                vkReadStream->read((uint64_t*)&cgen_var_700, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_700, (VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyIndirectCommandsLayoutNVX\n");;
                }
                m_vk->vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateObjectTableNVX:
            {
                VkDevice device;
                const VkObjectTableCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkObjectTableNVX* pObjectTable;
                uint64_t cgen_var_702;
                vkReadStream->read((uint64_t*)&cgen_var_702, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_702, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
                unmarshal_VkObjectTableCreateInfoNVX(vkReadStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pObjectTable, sizeof(VkObjectTableNVX));
                uint64_t cgen_var_704;
                vkReadStream->read((uint64_t*)&cgen_var_704, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_704, (VkObjectTableNVX*)pObjectTable, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateObjectTableNVX\n");;
                }
                VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
                vkCreateObjectTableNVX_VkResult_return = m_vk->vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable);
                uint64_t cgen_var_705;
                vkStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_705, 1);
                vkStream->write((uint64_t*)&cgen_var_705, 8);
                vkStream->write(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyObjectTableNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_706;
                vkReadStream->read((uint64_t*)&cgen_var_706, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_706, (VkDevice*)&device, 1);
                uint64_t cgen_var_707;
                vkReadStream->read((uint64_t*)&cgen_var_707, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_707, (VkObjectTableNVX*)&objectTable, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyObjectTableNVX\n");;
                }
                m_vk->vkDestroyObjectTableNVX(device, objectTable, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectTableEntryNVX* const* ppObjectTableEntries;
                const uint32_t* pObjectIndices;
                uint64_t cgen_var_709;
                vkReadStream->read((uint64_t*)&cgen_var_709, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_709, (VkDevice*)&device, 1);
                uint64_t cgen_var_710;
                vkReadStream->read((uint64_t*)&cgen_var_710, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_710, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterObjectsNVX\n");;
                }
                VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
                vkRegisterObjectsNVX_VkResult_return = m_vk->vkRegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                vkStream->write(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkUnregisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectEntryTypeNVX* pObjectEntryTypes;
                const uint32_t* pObjectIndices;
                uint64_t cgen_var_711;
                vkReadStream->read((uint64_t*)&cgen_var_711, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_711, (VkDevice*)&device, 1);
                uint64_t cgen_var_712;
                vkReadStream->read((uint64_t*)&cgen_var_712, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_712, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->read((VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUnregisterObjectsNVX\n");;
                }
                VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
                vkUnregisterObjectsNVX_VkResult_return = m_vk->vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                vkStream->write(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX:
            {
                VkPhysicalDevice physicalDevice;
                VkDeviceGeneratedCommandsFeaturesNVX* pFeatures;
                VkDeviceGeneratedCommandsLimitsNVX* pLimits;
                uint64_t cgen_var_713;
                vkReadStream->read((uint64_t*)&cgen_var_713, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_713, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
                unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkReadStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                vkReadStream->alloc((void**)&pLimits, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
                unmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkReadStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX\n");;
                }
                m_vk->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits);
                marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewportWScalingNV* pViewportWScalings;
                uint64_t cgen_var_714;
                vkReadStream->read((uint64_t*)&cgen_var_714, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_714, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewportWScalingNV(vkReadStream, (VkViewportWScalingNV*)(pViewportWScalings + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetViewportWScalingNV\n");;
                }
                m_vk->vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint64_t cgen_var_715;
                vkReadStream->read((uint64_t*)&cgen_var_715, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_715, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_716;
                vkReadStream->read((uint64_t*)&cgen_var_716, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_716, (VkDisplayKHR*)&display, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkReleaseDisplayEXT\n");;
                }
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = m_vk->vkReleaseDisplayEXT(physicalDevice, display);
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                uint64_t cgen_var_717;
                vkReadStream->read((uint64_t*)&cgen_var_717, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_717, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_718;
                vkReadStream->read((uint64_t*)&cgen_var_718, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_718, (VkDisplayKHR*)&display, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireXlibDisplayEXT\n");;
                }
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = m_vk->vkAcquireXlibDisplayEXT(physicalDevice, dpy, display);
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                uint64_t cgen_var_719;
                vkReadStream->read((uint64_t*)&cgen_var_719, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_719, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->read((RROutput*)&rrOutput, sizeof(RROutput));
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                uint64_t cgen_var_720;
                vkReadStream->read((uint64_t*)&cgen_var_720, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_720, (VkDisplayKHR*)pDisplay, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRandROutputDisplayEXT\n");;
                }
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = m_vk->vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->write((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_721;
                vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_721, 1);
                vkStream->write((uint64_t*)&cgen_var_721, 8);
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                uint64_t cgen_var_722;
                vkReadStream->read((uint64_t*)&cgen_var_722, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_722, (VkPhysicalDevice*)&physicalDevice, 1);
                uint64_t cgen_var_723;
                vkReadStream->read((uint64_t*)&cgen_var_723, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_723, (VkSurfaceKHR*)&surface, 1);
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                unmarshal_VkSurfaceCapabilities2EXT(vkReadStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceSurfaceCapabilities2EXT\n");;
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = m_vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
                marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                uint64_t cgen_var_724;
                vkReadStream->read((uint64_t*)&cgen_var_724, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_724, (VkDevice*)&device, 1);
                uint64_t cgen_var_725;
                vkReadStream->read((uint64_t*)&cgen_var_725, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_725, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                unmarshal_VkDisplayPowerInfoEXT(vkReadStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDisplayPowerControlEXT\n");;
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = m_vk->vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                VkDevice device;
                const VkDeviceEventInfoEXT* pDeviceEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                uint64_t cgen_var_726;
                vkReadStream->read((uint64_t*)&cgen_var_726, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_726, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                unmarshal_VkDeviceEventInfoEXT(vkReadStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_728;
                vkReadStream->read((uint64_t*)&cgen_var_728, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_728, (VkFence*)pFence, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterDeviceEventEXT\n");;
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = m_vk->vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
                uint64_t cgen_var_729;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_729, 1);
                vkStream->write((uint64_t*)&cgen_var_729, 8);
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayEventInfoEXT* pDisplayEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                uint64_t cgen_var_730;
                vkReadStream->read((uint64_t*)&cgen_var_730, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_730, (VkDevice*)&device, 1);
                uint64_t cgen_var_731;
                vkReadStream->read((uint64_t*)&cgen_var_731, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_731, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                unmarshal_VkDisplayEventInfoEXT(vkReadStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_733;
                vkReadStream->read((uint64_t*)&cgen_var_733, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_733, (VkFence*)pFence, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterDisplayEventEXT\n");;
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = m_vk->vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
                uint64_t cgen_var_734;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_734, 1);
                vkStream->write((uint64_t*)&cgen_var_734, 8);
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                uint64_t cgen_var_735;
                vkReadStream->read((uint64_t*)&cgen_var_735, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_735, (VkDevice*)&device, 1);
                uint64_t cgen_var_736;
                vkReadStream->read((uint64_t*)&cgen_var_736, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_736, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                vkReadStream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainCounterEXT\n");;
                }
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = m_vk->vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                uint64_t cgen_var_737;
                vkReadStream->read((uint64_t*)&cgen_var_737, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_737, (VkDevice*)&device, 1);
                uint64_t cgen_var_738;
                vkReadStream->read((uint64_t*)&cgen_var_738, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_738, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                unmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetRefreshCycleDurationGOOGLE\n");;
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = m_vk->vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                uint64_t cgen_var_739;
                vkReadStream->read((uint64_t*)&cgen_var_739, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_739, (VkDevice*)&device, 1);
                uint64_t cgen_var_740;
                vkReadStream->read((uint64_t*)&cgen_var_740, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_740, (VkSwapchainKHR*)&swapchain, 1);
                // WARNING PTR CHECK
                pPresentationTimingCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        unmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPastPresentationTimingGOOGLE\n");;
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = m_vk->vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
                // WARNING PTR CHECK
                uint64_t cgen_var_743 = (uint64_t)(uintptr_t)pPresentationTimingCount;
                vkStream->putBe64(cgen_var_743);
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_744 = (uint64_t)(uintptr_t)pPresentationTimings;
                vkStream->putBe64(cgen_var_744);
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                const VkRect2D* pDiscardRectangles;
                uint64_t cgen_var_745;
                vkReadStream->read((uint64_t*)&cgen_var_745, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_745, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pDiscardRectangles + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetDiscardRectangleEXT\n");;
                }
                m_vk->vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainKHR* pSwapchains;
                const VkHdrMetadataEXT* pMetadata;
                uint64_t cgen_var_746;
                vkReadStream->read((uint64_t*)&cgen_var_746, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_746, (VkDevice*)&device, 1);
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_747;
                    vkReadStream->alloc((void**)&cgen_var_747, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_747, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_747, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkHdrMetadataEXT(vkReadStream, (VkHdrMetadataEXT*)(pMetadata + i));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetHdrMetadataEXT\n");;
                }
                m_vk->vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                VkInstance instance;
                const VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_748;
                vkReadStream->read((uint64_t*)&cgen_var_748, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_748, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                unmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_750;
                vkReadStream->read((uint64_t*)&cgen_var_750, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_750, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateIOSSurfaceMVK\n");;
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = m_vk->vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_751;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_751, 1);
                vkStream->write((uint64_t*)&cgen_var_751, 8);
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                VkInstance instance;
                const VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                uint64_t cgen_var_752;
                vkReadStream->read((uint64_t*)&cgen_var_752, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_752, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                unmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_754;
                vkReadStream->read((uint64_t*)&cgen_var_754, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_754, (VkSurfaceKHR*)pSurface, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateMacOSSurfaceMVK\n");;
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = m_vk->vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
                uint64_t cgen_var_755;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_755, 1);
                vkStream->write((uint64_t*)&cgen_var_755, 8);
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                uint64_t cgen_var_756;
                vkReadStream->read((uint64_t*)&cgen_var_756, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_756, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                unmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetDebugUtilsObjectNameEXT\n");;
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = m_vk->vkSetDebugUtilsObjectNameEXT(device, pNameInfo);
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                uint64_t cgen_var_757;
                vkReadStream->read((uint64_t*)&cgen_var_757, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_757, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                unmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSetDebugUtilsObjectTagEXT\n");;
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = m_vk->vkSetDebugUtilsObjectTagEXT(device, pTagInfo);
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                uint64_t cgen_var_758;
                vkReadStream->read((uint64_t*)&cgen_var_758, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_758, (VkQueue*)&queue, 1);
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueBeginDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                VkQueue queue;
                uint64_t cgen_var_759;
                vkReadStream->read((uint64_t*)&cgen_var_759, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_759, (VkQueue*)&queue, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueEndDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueEndDebugUtilsLabelEXT(queue);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                uint64_t cgen_var_760;
                vkReadStream->read((uint64_t*)&cgen_var_760, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_760, (VkQueue*)&queue, 1);
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueInsertDebugUtilsLabelEXT\n");;
                }
                m_vk->vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                uint64_t cgen_var_761;
                vkReadStream->read((uint64_t*)&cgen_var_761, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_761, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBeginDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                uint64_t cgen_var_762;
                vkReadStream->read((uint64_t*)&cgen_var_762, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_762, (VkCommandBuffer*)&commandBuffer, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdEndDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdEndDebugUtilsLabelEXT(commandBuffer);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                uint64_t cgen_var_763;
                vkReadStream->read((uint64_t*)&cgen_var_763, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_763, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdInsertDebugUtilsLabelEXT\n");;
                }
                m_vk->vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                uint64_t cgen_var_764;
                vkReadStream->read((uint64_t*)&cgen_var_764, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_764, (VkInstance*)&instance, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                uint64_t cgen_var_766;
                vkReadStream->read((uint64_t*)&cgen_var_766, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_766, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDebugUtilsMessengerEXT\n");;
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = m_vk->vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
                uint64_t cgen_var_767;
                vkStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_767, 1);
                vkStream->write((uint64_t*)&cgen_var_767, 8);
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_768;
                vkReadStream->read((uint64_t*)&cgen_var_768, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_768, (VkInstance*)&instance, 1);
                uint64_t cgen_var_769;
                vkReadStream->read((uint64_t*)&cgen_var_769, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_769, (VkDebugUtilsMessengerEXT*)&messenger, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDebugUtilsMessengerEXT\n");;
                }
                m_vk->vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                uint64_t cgen_var_771;
                vkReadStream->read((uint64_t*)&cgen_var_771, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_771, (VkInstance*)&instance, 1);
                vkReadStream->read((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                vkReadStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                unmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkSubmitDebugUtilsMessageEXT\n");;
                }
                m_vk->vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                VkDevice device;
                const AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                uint64_t cgen_var_772;
                vkReadStream->read((uint64_t*)&cgen_var_772, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_772, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                vkReadStream->read((AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                unmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetAndroidHardwareBufferPropertiesANDROID\n");;
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = m_vk->vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                VkDevice device;
                const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                uint64_t cgen_var_773;
                vkReadStream->read((uint64_t*)&cgen_var_773, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_773, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryAndroidHardwareBufferANDROID\n");;
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = m_vk->vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                uint64_t cgen_var_774;
                vkReadStream->read((uint64_t*)&cgen_var_774, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_774, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                unmarshal_VkSampleLocationsInfoEXT(vkReadStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetSampleLocationsEXT\n");;
                }
                m_vk->vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                uint64_t cgen_var_775;
                vkReadStream->read((uint64_t*)&cgen_var_775, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_775, (VkPhysicalDevice*)&physicalDevice, 1);
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                unmarshal_VkMultisamplePropertiesEXT(vkReadStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMultisamplePropertiesEXT\n");;
                }
                m_vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
                marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                VkDevice device;
                const VkValidationCacheCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                uint64_t cgen_var_776;
                vkReadStream->read((uint64_t*)&cgen_var_776, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_776, (VkDevice*)&device, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                unmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                uint64_t cgen_var_778;
                vkReadStream->read((uint64_t*)&cgen_var_778, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_778, (VkValidationCacheEXT*)pValidationCache, 1);
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateValidationCacheEXT\n");;
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = m_vk->vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
                uint64_t cgen_var_779;
                vkStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_779, 1);
                vkStream->write((uint64_t*)&cgen_var_779, 8);
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                const VkAllocationCallbacks* pAllocator;
                uint64_t cgen_var_780;
                vkReadStream->read((uint64_t*)&cgen_var_780, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_780, (VkDevice*)&device, 1);
                uint64_t cgen_var_781;
                vkReadStream->read((uint64_t*)&cgen_var_781, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_781, (VkValidationCacheEXT*)&validationCache, 1);
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyValidationCacheEXT\n");;
                }
                m_vk->vkDestroyValidationCacheEXT(device, validationCache, pAllocator);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                const VkValidationCacheEXT* pSrcCaches;
                uint64_t cgen_var_783;
                vkReadStream->read((uint64_t*)&cgen_var_783, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_783, (VkDevice*)&device, 1);
                uint64_t cgen_var_784;
                vkReadStream->read((uint64_t*)&cgen_var_784, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_784, (VkValidationCacheEXT*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_785;
                    vkReadStream->alloc((void**)&cgen_var_785, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_785, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(cgen_var_785, (VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMergeValidationCachesEXT\n");;
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = m_vk->vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                uint64_t cgen_var_786;
                vkReadStream->read((uint64_t*)&cgen_var_786, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_786, (VkDevice*)&device, 1);
                uint64_t cgen_var_787;
                vkReadStream->read((uint64_t*)&cgen_var_787, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_787, (VkValidationCacheEXT*)&validationCache, 1);
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetValidationCacheDataEXT\n");;
                }
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = m_vk->vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
                // WARNING PTR CHECK
                uint64_t cgen_var_791 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_791);
                if (pDataSize)
                {
                    uint64_t cgen_var_792 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_792);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_793 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_793);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                const void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                uint64_t cgen_var_794;
                vkReadStream->read((uint64_t*)&cgen_var_794, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_794, (VkDevice*)&device, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                // WARNING PTR CHECK
                pHostPointer = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    vkReadStream->read((void*)pHostPointer, sizeof(const uint8_t));
                }
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                unmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetMemoryHostPointerPropertiesEXT\n");;
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = m_vk->vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                uint64_t cgen_var_796;
                vkReadStream->read((uint64_t*)&cgen_var_796, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_796, (VkCommandBuffer*)&commandBuffer, 1);
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_797;
                vkReadStream->read((uint64_t*)&cgen_var_797, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_797, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&marker, sizeof(uint32_t));
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdWriteBufferMarkerAMD\n");;
                }
                m_vk->vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                VkCommandBuffer commandBuffer;
                const void* pCheckpointMarker;
                uint64_t cgen_var_798;
                vkReadStream->read((uint64_t*)&cgen_var_798, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_798, (VkCommandBuffer*)&commandBuffer, 1);
                // WARNING PTR CHECK
                pCheckpointMarker = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    vkReadStream->read((void*)pCheckpointMarker, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdSetCheckpointNV\n");;
                }
                m_vk->vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                uint64_t cgen_var_800;
                vkReadStream->read((uint64_t*)&cgen_var_800, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_800, (VkQueue*)&queue, 1);
                // WARNING PTR CHECK
                pCheckpointDataCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        unmarshal_VkCheckpointDataNV(vkReadStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetQueueCheckpointDataNV\n");;
                }
                m_vk->vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
                // WARNING PTR CHECK
                uint64_t cgen_var_803 = (uint64_t)(uintptr_t)pCheckpointDataCount;
                vkStream->putBe64(cgen_var_803);
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_804 = (uint64_t)(uintptr_t)pCheckpointData;
                vkStream->putBe64(cgen_var_804);
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space
            case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMapMemoryIntoAddressSpaceGOOGLE\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                uint64_t cgen_var_805;
                vkReadStream->read((uint64_t*)&cgen_var_805, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_805, (VkDevice*)&device, 1);
                uint64_t cgen_var_806;
                vkReadStream->read((uint64_t*)&cgen_var_806, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_806, (VkDeviceMemory*)&memory, 1);
                // WARNING PTR CHECK
                pAddress = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pAddress, sizeof(uint64_t));
                }
                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(device, memory, pAddress);
                // WARNING PTR CHECK
                uint64_t cgen_var_808 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_808);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                vkStream->commitWrite();
                break;
            }
#endif
            default:
            {
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    return ptr - (unsigned char*)buf;;
}


