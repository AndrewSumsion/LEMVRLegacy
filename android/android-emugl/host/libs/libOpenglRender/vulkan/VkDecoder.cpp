// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"
#include "common/goldfish_vk_private_defs.h"
#include "common/goldfish_vk_transform.h"

#include "android/base/Pool.h"
#include "android/base/system/System.h"

#include "IOStream.h"
#include "emugl/common/logging.h"

#include "VkDecoderGlobalState.h"
#include "VkDecoderSnapshot.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>





using emugl::vkDispatch;

using namespace goldfish_vk;

using android::base::System;

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(System::get()->envGet("ANDROID_EMU_VK_LOG_CALLS") == "1"), m_vk(vkDispatch()), m_state(VkDecoderGlobalState::get()) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    size_t decode(void* buf, size_t bufsize, IOStream* stream);

private:
    bool m_logCalls;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
    BoxedHandleCreateMapping m_boxedHandleCreateMapping;
    BoxedHandleDestroyMapping m_boxedHandleDestroyMapping;
    BoxedHandleUnwrapAndDeleteMapping m_boxedHandleUnwrapAndDeleteMapping;
    android::base::Pool m_pool { 8, 4096, 64 };
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()) { }

VkDecoder::~VkDecoder() = default;

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* stream) {
    return mImpl->decode(buf, bufsize, stream);
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream)
{
    if (len < 8) return 0;;
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
        auto vk = m_vk;
        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateInstance\n");;
                }
                const VkInstanceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                unmarshal_VkInstanceCreateInfo(vkReadStream, (VkInstanceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pInstance;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                uint64_t cgen_var_1;
                vkReadStream->read((uint64_t*)&cgen_var_1, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_1, (VkInstance*)pInstance, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInstance;
                if (pCreateInfo)
                {
                    transform_tohost_VkInstanceCreateInfo(m_state, (VkInstanceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(&m_pool, pCreateInfo, pAllocator, pInstance);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                vkStream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_2, 1);
                vkStream->write((uint64_t*)&cgen_var_2, 8);
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateInstance(&m_pool, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
                break;
            }
            case OP_vkDestroyInstance:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyInstance\n");;
                }
                VkInstance instance;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkReadStream->read((uint64_t*)&cgen_var_3, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_3, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyInstance(&m_pool, instance, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyInstance(&m_pool, instance, pAllocator);
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumeratePhysicalDevices\n");;
                }
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_5;
                vkReadStream->read((uint64_t*)&cgen_var_5, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_5, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDevices;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_8;
                        vkReadStream->alloc((void**)&cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_8, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDevices;
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_state->on_vkEnumeratePhysicalDevices(&m_pool, instance, pPhysicalDeviceCount, pPhysicalDevices);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_9 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
                vkStream->putBe64(cgen_var_9);
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDevices;
                vkStream->putBe64(cgen_var_10);
                if (pPhysicalDevices)
                {
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_11;
                        vkStream->alloc((void**)&cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_11, (*(pPhysicalDeviceCount)));
                        vkStream->write((uint64_t*)cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumeratePhysicalDevices(&m_pool, vkEnumeratePhysicalDevices_VkResult_return, instance, pPhysicalDeviceCount, pPhysicalDevices);
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_12;
                vkReadStream->read((uint64_t*)&cgen_var_12, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_12, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                unmarshal_VkPhysicalDeviceFeatures(vkReadStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_13;
                vkReadStream->read((uint64_t*)&cgen_var_13, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_13, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                unmarshal_VkFormatProperties(vkReadStream, (VkFormatProperties*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format, pFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_14;
                vkReadStream->read((uint64_t*)&cgen_var_14, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_14, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                unmarshal_VkImageFormatProperties(vkReadStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties(&m_pool, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties(&m_pool, vkGetPhysicalDeviceImageFormatProperties_VkResult_return, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_15;
                vkReadStream->read((uint64_t*)&cgen_var_15, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_15, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                unmarshal_VkPhysicalDeviceProperties(vkReadStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                m_state->on_vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_16;
                vkReadStream->read((uint64_t*)&cgen_var_16, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_16, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties(vkReadStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_19 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_19);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_20 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_20);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties(&m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_21;
                vkReadStream->read((uint64_t*)&cgen_var_21, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_21, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                unmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice, pMemoryProperties);
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                VkInstance instance;
                const char* pName;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_22;
                vkReadStream->read((uint64_t*)&cgen_var_22, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_22, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->loadStringInPlace((char**)&pName);
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = vk->vkGetInstanceProcAddr(unboxed_instance, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetInstanceProcAddr(&m_pool, vkGetInstanceProcAddr_PFN_vkVoidFunction_return, instance, pName);
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                VkDevice device;
                const char* pName;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_23;
                vkReadStream->read((uint64_t*)&cgen_var_23, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_23, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->loadStringInPlace((char**)&pName);
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = vk->vkGetDeviceProcAddr(unboxed_device, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceProcAddr(&m_pool, vkGetDeviceProcAddr_PFN_vkVoidFunction_return, device, pName);
                break;
            }
            case OP_vkCreateDevice:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDevice\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkDeviceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_24;
                vkReadStream->read((uint64_t*)&cgen_var_24, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_24, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                unmarshal_VkDeviceCreateInfo(vkReadStream, (VkDeviceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                uint64_t cgen_var_26;
                vkReadStream->read((uint64_t*)&cgen_var_26, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_26, (VkDevice*)pDevice, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDevice;
                if (pCreateInfo)
                {
                    transform_tohost_VkDeviceCreateInfo(m_state, (VkDeviceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(&m_pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_27;
                vkStream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_27, 1);
                vkStream->write((uint64_t*)&cgen_var_27, 8);
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDevice(&m_pool, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
                break;
            }
            case OP_vkDestroyDevice:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDevice\n");;
                }
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_28;
                vkReadStream->read((uint64_t*)&cgen_var_28, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_28, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyDevice(&m_pool, device, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDevice(&m_pool, device, pAllocator);
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_32 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_32);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_33);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumerateInstanceExtensionProperties(&m_pool, vkEnumerateInstanceExtensionProperties_VkResult_return, pLayerName, pPropertyCount, pProperties);
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                VkPhysicalDevice physicalDevice;
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_34;
                vkReadStream->read((uint64_t*)&cgen_var_34, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_34, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->loadStringInPlace((char**)&pLayerName);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = vk->vkEnumerateDeviceExtensionProperties(unboxed_physicalDevice, pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_37 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_37);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_38 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_38);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumerateDeviceExtensionProperties(&m_pool, vkEnumerateDeviceExtensionProperties_VkResult_return, physicalDevice, pLayerName, pPropertyCount, pProperties);
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_41 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_41);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_42 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_42);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumerateInstanceLayerProperties(&m_pool, vkEnumerateInstanceLayerProperties_VkResult_return, pPropertyCount, pProperties);
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_43;
                vkReadStream->read((uint64_t*)&cgen_var_43, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_43, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_46 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_46);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_47 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_47);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumerateDeviceLayerProperties(&m_pool, vkEnumerateDeviceLayerProperties_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetDeviceQueue\n");;
                }
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_48;
                vkReadStream->read((uint64_t*)&cgen_var_48, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_48, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queueIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_49;
                vkReadStream->read((uint64_t*)&cgen_var_49, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_49, (VkQueue*)pQueue, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueue;
                m_state->on_vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_50;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_50, 1);
                vkStream->write((uint64_t*)&cgen_var_50, 8);
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                break;
            }
            case OP_vkQueueSubmit:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueSubmit\n");;
                }
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_51;
                vkReadStream->read((uint64_t*)&cgen_var_51, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_51, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&submitCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    unmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i));
                }
                uint64_t cgen_var_52;
                vkReadStream->read((uint64_t*)&cgen_var_52, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_52, (VkFence*)&fence, 1);
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueSubmit(&m_pool, vkQueueSubmit_VkResult_return, queue, submitCount, pSubmits, fence);
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                VkQueue queue;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_53;
                vkReadStream->read((uint64_t*)&cgen_var_53, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_53, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = vk->vkQueueWaitIdle(unboxed_queue);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueWaitIdle(&m_pool, vkQueueWaitIdle_VkResult_return, queue);
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                VkDevice device;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_54;
                vkReadStream->read((uint64_t*)&cgen_var_54, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_54, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDeviceWaitIdle(&m_pool, vkDeviceWaitIdle_VkResult_return, device);
                break;
            }
            case OP_vkAllocateMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateMemory\n");;
                }
                VkDevice device;
                const VkMemoryAllocateInfo* pAllocateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_55;
                vkReadStream->read((uint64_t*)&cgen_var_55, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_55, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                unmarshal_VkMemoryAllocateInfo(vkReadStream, (VkMemoryAllocateInfo*)(pAllocateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMemory;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                uint64_t cgen_var_57;
                vkReadStream->read((uint64_t*)&cgen_var_57, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_57, (VkDeviceMemory*)pMemory, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemory;
                if (pAllocateInfo)
                {
                    transform_tohost_VkMemoryAllocateInfo(m_state, (VkMemoryAllocateInfo*)(pAllocateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(&m_pool, device, pAllocateInfo, pAllocator, pMemory);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_58;
                vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_58, 1);
                vkStream->write((uint64_t*)&cgen_var_58, 8);
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAllocateMemory(&m_pool, vkAllocateMemory_VkResult_return, device, pAllocateInfo, pAllocator, pMemory);
                break;
            }
            case OP_vkFreeMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_59;
                vkReadStream->read((uint64_t*)&cgen_var_59, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_59, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for memory;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_60;
                vkReadStream->read((uint64_t*)&cgen_var_60, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_60, (VkDeviceMemory*)&memory, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for memory;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkFreeMemory(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkFreeMemory(&m_pool, device, memory, pAllocator);
                break;
            }
            case OP_vkMapMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMapMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_62;
                vkReadStream->read((uint64_t*)&cgen_var_62, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_62, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_63;
                vkReadStream->read((uint64_t*)&cgen_var_63, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_63, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
                // Begin manual dispatchable handle unboxing for ppData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                ppData = (void**)(uintptr_t)vkReadStream->getBe64();
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    vkReadStream->read((void**)ppData, sizeof(void*));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for ppData;
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(&m_pool, device, memory, offset, size, flags, ppData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_65 = (uint64_t)(uintptr_t)ppData;
                vkStream->putBe64(cgen_var_65);
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkMapMemory(&m_pool, vkMapMemory_VkResult_return, device, memory, offset, size, flags, ppData);
                break;
            }
            case OP_vkUnmapMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUnmapMemory\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_66;
                vkReadStream->read((uint64_t*)&cgen_var_66, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_66, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_67;
                vkReadStream->read((uint64_t*)&cgen_var_67, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_67, (VkDeviceMemory*)&memory, 1);
                m_state->on_vkUnmapMemory(&m_pool, device, memory);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUnmapMemory(&m_pool, device, memory);
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFlushMappedMemoryRanges\n");;
                }
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_68;
                vkReadStream->read((uint64_t*)&cgen_var_68, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_68, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = pMemoryRanges[i].memory;
                        auto size = pMemoryRanges[i].size;
                        auto offset = pMemoryRanges[i].offset;
                        uint64_t readStream = 0;
                        vkReadStream->read(&readStream, sizeof(uint64_t));
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        if (!hostPtr && readStream > 0) abort();
                        if (!hostPtr) continue;
                        uint8_t* targetRange = hostPtr + offset;
                        vkReadStream->read(targetRange, readStream);
                    }
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = vk->vkFlushMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkFlushMappedMemoryRanges(&m_pool, vkFlushMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkInvalidateMappedMemoryRanges\n");;
                }
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_69;
                vkReadStream->read((uint64_t*)&cgen_var_69, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_69, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = vk->vkInvalidateMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = range.memory;
                        auto size = range.size;
                        auto offset = range.offset;
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                        uint64_t writeStream = 0;
                        if (!hostPtr) { vkStream->write(&writeStream, sizeof(uint64_t)); continue; };
                        uint8_t* targetRange = hostPtr + offset;
                        writeStream = actualSize;
                        vkStream->write(&writeStream, sizeof(uint64_t));
                        vkStream->write(targetRange, actualSize);
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkInvalidateMappedMemoryRanges(&m_pool, vkInvalidateMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_70;
                vkReadStream->read((uint64_t*)&cgen_var_70, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_70, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_71;
                vkReadStream->read((uint64_t*)&cgen_var_71, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_71, (VkDeviceMemory*)&memory, 1);
                // Begin manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                vk->vkGetDeviceMemoryCommitment(unboxed_device, memory, pCommittedMemoryInBytes);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceMemoryCommitment(&m_pool, device, memory, pCommittedMemoryInBytes);
                break;
            }
            case OP_vkBindBufferMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory\n");;
                }
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_72;
                vkReadStream->read((uint64_t*)&cgen_var_72, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_72, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_73;
                vkReadStream->read((uint64_t*)&cgen_var_73, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_73, (VkBuffer*)&buffer, 1);
                uint64_t cgen_var_74;
                vkReadStream->read((uint64_t*)&cgen_var_74, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_74, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(&m_pool, device, buffer, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindBufferMemory(&m_pool, vkBindBufferMemory_VkResult_return, device, buffer, memory, memoryOffset);
                break;
            }
            case OP_vkBindImageMemory:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindImageMemory\n");;
                }
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_75;
                vkReadStream->read((uint64_t*)&cgen_var_75, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_75, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_76;
                vkReadStream->read((uint64_t*)&cgen_var_76, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_76, (VkImage*)&image, 1);
                uint64_t cgen_var_77;
                vkReadStream->read((uint64_t*)&cgen_var_77, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_77, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_state->on_vkBindImageMemory(&m_pool, device, image, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindImageMemory(&m_pool, vkBindImageMemory_VkResult_return, device, image, memory, memoryOffset);
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_78;
                vkReadStream->read((uint64_t*)&cgen_var_78, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_78, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_79;
                vkReadStream->read((uint64_t*)&cgen_var_79, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_79, (VkBuffer*)&buffer, 1);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                vk->vkGetBufferMemoryRequirements(unboxed_device, buffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetBufferMemoryRequirements(&m_pool, device, buffer, pMemoryRequirements);
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements\n");;
                }
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_80;
                vkReadStream->read((uint64_t*)&cgen_var_80, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_80, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_81;
                vkReadStream->read((uint64_t*)&cgen_var_81, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_81, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                m_state->on_vkGetImageMemoryRequirements(&m_pool, device, image, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageMemoryRequirements(&m_pool, device, image, pMemoryRequirements);
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_82;
                vkReadStream->read((uint64_t*)&cgen_var_82, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_82, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_83;
                vkReadStream->read((uint64_t*)&cgen_var_83, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_83, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements(vkReadStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vk->vkGetImageSparseMemoryRequirements(unboxed_device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_86 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_86);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_87 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_87);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageSparseMemoryRequirements(&m_pool, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_88;
                vkReadStream->read((uint64_t*)&cgen_var_88, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_88, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties(vkReadStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties(unboxed_physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_91 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_91);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_92 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_92);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties(&m_pool, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                break;
            }
            case OP_vkQueueBindSparse:
            {
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_93;
                vkReadStream->read((uint64_t*)&cgen_var_93, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_93, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i));
                }
                uint64_t cgen_var_94;
                vkReadStream->read((uint64_t*)&cgen_var_94, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_94, (VkFence*)&fence, 1);
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = vk->vkQueueBindSparse(unboxed_queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueBindSparse(&m_pool, vkQueueBindSparse_VkResult_return, queue, bindInfoCount, pBindInfo, fence);
                break;
            }
            case OP_vkCreateFence:
            {
                VkDevice device;
                const VkFenceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_95;
                vkReadStream->read((uint64_t*)&cgen_var_95, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_95, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                unmarshal_VkFenceCreateInfo(vkReadStream, (VkFenceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_97;
                vkReadStream->read((uint64_t*)&cgen_var_97, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_97, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pCreateInfo)
                {
                    transform_tohost_VkFenceCreateInfo(m_state, (VkFenceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = vk->vkCreateFence(unboxed_device, pCreateInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFence;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_98;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_98, 1);
                vkStream->write((uint64_t*)&cgen_var_98, 8);
                // Begin auto non dispatchable handle create for pFence;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateFence(&m_pool, vkCreateFence_VkResult_return, device, pCreateInfo, pAllocator, pFence);
                break;
            }
            case OP_vkDestroyFence:
            {
                VkDevice device;
                VkFence fence;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_99;
                vkReadStream->read((uint64_t*)&cgen_var_99, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_99, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for fence;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_100;
                vkReadStream->read((uint64_t*)&cgen_var_100, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_100, (VkFence*)&fence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for fence;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyFence(unboxed_device, fence, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyFence(&m_pool, device, fence, pAllocator);
                break;
            }
            case OP_vkResetFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_102;
                vkReadStream->read((uint64_t*)&cgen_var_102, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_102, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_103;
                    vkReadStream->alloc((void**)&cgen_var_103, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_103, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_103, (VkFence*)pFences, ((fenceCount)));
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = vk->vkResetFences(unboxed_device, fenceCount, pFences);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetFences(&m_pool, vkResetFences_VkResult_return, device, fenceCount, pFences);
                break;
            }
            case OP_vkGetFenceStatus:
            {
                VkDevice device;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_104;
                vkReadStream->read((uint64_t*)&cgen_var_104, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_104, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_105;
                vkReadStream->read((uint64_t*)&cgen_var_105, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_105, (VkFence*)&fence, 1);
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = vk->vkGetFenceStatus(unboxed_device, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetFenceStatus(&m_pool, vkGetFenceStatus_VkResult_return, device, fence);
                break;
            }
            case OP_vkWaitForFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_106;
                vkReadStream->read((uint64_t*)&cgen_var_106, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_106, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_107;
                    vkReadStream->alloc((void**)&cgen_var_107, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_107, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_107, (VkFence*)pFences, ((fenceCount)));
                }
                vkReadStream->read((VkBool32*)&waitAll, sizeof(VkBool32));
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkWaitForFences(&m_pool, vkWaitForFences_VkResult_return, device, fenceCount, pFences, waitAll, timeout);
                break;
            }
            case OP_vkCreateSemaphore:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSemaphore\n");;
                }
                VkDevice device;
                const VkSemaphoreCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_108;
                vkReadStream->read((uint64_t*)&cgen_var_108, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_108, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                unmarshal_VkSemaphoreCreateInfo(vkReadStream, (VkSemaphoreCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSemaphore;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                uint64_t cgen_var_110;
                vkReadStream->read((uint64_t*)&cgen_var_110, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_110, (VkSemaphore*)pSemaphore, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSemaphore;
                if (pCreateInfo)
                {
                    transform_tohost_VkSemaphoreCreateInfo(m_state, (VkSemaphoreCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(&m_pool, device, pCreateInfo, pAllocator, pSemaphore);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_111;
                vkStream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_111, 1);
                vkStream->write((uint64_t*)&cgen_var_111, 8);
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSemaphore(&m_pool, vkCreateSemaphore_VkResult_return, device, pCreateInfo, pAllocator, pSemaphore);
                break;
            }
            case OP_vkDestroySemaphore:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySemaphore\n");;
                }
                VkDevice device;
                VkSemaphore semaphore;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_112;
                vkReadStream->read((uint64_t*)&cgen_var_112, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_112, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for semaphore;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_113;
                vkReadStream->read((uint64_t*)&cgen_var_113, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_113, (VkSemaphore*)&semaphore, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for semaphore;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
                break;
            }
            case OP_vkCreateEvent:
            {
                VkDevice device;
                const VkEventCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_115;
                vkReadStream->read((uint64_t*)&cgen_var_115, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_115, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                unmarshal_VkEventCreateInfo(vkReadStream, (VkEventCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pEvent;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                uint64_t cgen_var_117;
                vkReadStream->read((uint64_t*)&cgen_var_117, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_117, (VkEvent*)pEvent, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pEvent;
                if (pCreateInfo)
                {
                    transform_tohost_VkEventCreateInfo(m_state, (VkEventCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pEvent;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_118;
                vkStream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_118, 1);
                vkStream->write((uint64_t*)&cgen_var_118, 8);
                // Begin auto non dispatchable handle create for pEvent;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateEvent(&m_pool, vkCreateEvent_VkResult_return, device, pCreateInfo, pAllocator, pEvent);
                break;
            }
            case OP_vkDestroyEvent:
            {
                VkDevice device;
                VkEvent event;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_119;
                vkReadStream->read((uint64_t*)&cgen_var_119, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_119, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for event;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_120;
                vkReadStream->read((uint64_t*)&cgen_var_120, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_120, (VkEvent*)&event, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for event;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyEvent(unboxed_device, event, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyEvent(&m_pool, device, event, pAllocator);
                break;
            }
            case OP_vkGetEventStatus:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_122;
                vkReadStream->read((uint64_t*)&cgen_var_122, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_122, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_123;
                vkReadStream->read((uint64_t*)&cgen_var_123, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_123, (VkEvent*)&event, 1);
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetEventStatus(&m_pool, vkGetEventStatus_VkResult_return, device, event);
                break;
            }
            case OP_vkSetEvent:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_124;
                vkReadStream->read((uint64_t*)&cgen_var_124, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_124, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_125;
                vkReadStream->read((uint64_t*)&cgen_var_125, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_125, (VkEvent*)&event, 1);
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkSetEvent(&m_pool, vkSetEvent_VkResult_return, device, event);
                break;
            }
            case OP_vkResetEvent:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_126;
                vkReadStream->read((uint64_t*)&cgen_var_126, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_126, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_127;
                vkReadStream->read((uint64_t*)&cgen_var_127, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_127, (VkEvent*)&event, 1);
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetEvent(&m_pool, vkResetEvent_VkResult_return, device, event);
                break;
            }
            case OP_vkCreateQueryPool:
            {
                VkDevice device;
                const VkQueryPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_128;
                vkReadStream->read((uint64_t*)&cgen_var_128, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_128, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                unmarshal_VkQueryPoolCreateInfo(vkReadStream, (VkQueryPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pQueryPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                uint64_t cgen_var_130;
                vkReadStream->read((uint64_t*)&cgen_var_130, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_130, (VkQueryPool*)pQueryPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueryPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkQueryPoolCreateInfo(m_state, (VkQueryPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pQueryPool;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_131;
                vkStream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_131, 1);
                vkStream->write((uint64_t*)&cgen_var_131, 8);
                // Begin auto non dispatchable handle create for pQueryPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateQueryPool(&m_pool, vkCreateQueryPool_VkResult_return, device, pCreateInfo, pAllocator, pQueryPool);
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                VkDevice device;
                VkQueryPool queryPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_132;
                vkReadStream->read((uint64_t*)&cgen_var_132, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_132, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for queryPool;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_133;
                vkReadStream->read((uint64_t*)&cgen_var_133, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_133, (VkQueryPool*)&queryPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for queryPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyQueryPool(&m_pool, device, queryPool, pAllocator);
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_135;
                vkReadStream->read((uint64_t*)&cgen_var_135, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_135, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_136;
                vkReadStream->read((uint64_t*)&cgen_var_136, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_136, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                dataSize = (size_t)vkReadStream->getBe64();
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetQueryPoolResults(&m_pool, vkGetQueryPoolResults_VkResult_return, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                break;
            }
            case OP_vkCreateBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateBuffer\n");;
                }
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_138;
                vkReadStream->read((uint64_t*)&cgen_var_138, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_138, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                unmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_140;
                vkReadStream->read((uint64_t*)&cgen_var_140, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_140, (VkBuffer*)pBuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pBuffer;
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(&m_pool, device, pCreateInfo, pAllocator, pBuffer);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_141;
                vkStream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_141, 1);
                vkStream->write((uint64_t*)&cgen_var_141, 8);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateBuffer(&m_pool, vkCreateBuffer_VkResult_return, device, pCreateInfo, pAllocator, pBuffer);
                break;
            }
            case OP_vkDestroyBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyBuffer\n");;
                }
                VkDevice device;
                VkBuffer buffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_142;
                vkReadStream->read((uint64_t*)&cgen_var_142, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_142, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for buffer;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_143;
                vkReadStream->read((uint64_t*)&cgen_var_143, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_143, (VkBuffer*)&buffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for buffer;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
                break;
            }
            case OP_vkCreateBufferView:
            {
                VkDevice device;
                const VkBufferViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_145;
                vkReadStream->read((uint64_t*)&cgen_var_145, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_145, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                unmarshal_VkBufferViewCreateInfo(vkReadStream, (VkBufferViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                uint64_t cgen_var_147;
                vkReadStream->read((uint64_t*)&cgen_var_147, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_147, (VkBufferView*)pView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pView;
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferViewCreateInfo(m_state, (VkBufferViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_148;
                vkStream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_148, 1);
                vkStream->write((uint64_t*)&cgen_var_148, 8);
                // Begin auto non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateBufferView(&m_pool, vkCreateBufferView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                break;
            }
            case OP_vkDestroyBufferView:
            {
                VkDevice device;
                VkBufferView bufferView;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_149;
                vkReadStream->read((uint64_t*)&cgen_var_149, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_149, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for bufferView;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_150;
                vkReadStream->read((uint64_t*)&cgen_var_150, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_150, (VkBufferView*)&bufferView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for bufferView;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyBufferView(&m_pool, device, bufferView, pAllocator);
                break;
            }
            case OP_vkCreateImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImage\n");;
                }
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_152;
                vkReadStream->read((uint64_t*)&cgen_var_152, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_152, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                unmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_154;
                vkReadStream->read((uint64_t*)&cgen_var_154, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_154, (VkImage*)pImage, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImage;
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_state->on_vkCreateImage(&m_pool, device, pCreateInfo, pAllocator, pImage);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_155;
                vkStream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_155, 1);
                vkStream->write((uint64_t*)&cgen_var_155, 8);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateImage(&m_pool, vkCreateImage_VkResult_return, device, pCreateInfo, pAllocator, pImage);
                break;
            }
            case OP_vkDestroyImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImage\n");;
                }
                VkDevice device;
                VkImage image;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_156;
                vkReadStream->read((uint64_t*)&cgen_var_156, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_156, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for image;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_157;
                vkReadStream->read((uint64_t*)&cgen_var_157, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_157, (VkImage*)&image, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for image;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyImage(&m_pool, device, image, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyImage(&m_pool, device, image, pAllocator);
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                VkDevice device;
                VkImage image;
                const VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_159;
                vkReadStream->read((uint64_t*)&cgen_var_159, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_159, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_160;
                vkReadStream->read((uint64_t*)&cgen_var_160, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_160, (VkImage*)&image, 1);
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                unmarshal_VkImageSubresource(vkReadStream, (VkImageSubresource*)(pSubresource));
                // Begin manual dispatchable handle unboxing for pLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                unmarshal_VkSubresourceLayout(vkReadStream, (VkSubresourceLayout*)(pLayout));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pLayout;
                if (pSubresource)
                {
                    transform_tohost_VkImageSubresource(m_state, (VkImageSubresource*)(pSubresource));
                }
                if (pLayout)
                {
                    transform_tohost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
                vkStream->unsetHandleMapping();
                if (pLayout)
                {
                    transform_fromhost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageSubresourceLayout(&m_pool, device, image, pSubresource, pLayout);
                break;
            }
            case OP_vkCreateImageView:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateImageView\n");;
                }
                VkDevice device;
                const VkImageViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_161;
                vkReadStream->read((uint64_t*)&cgen_var_161, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_161, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                unmarshal_VkImageViewCreateInfo(vkReadStream, (VkImageViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                uint64_t cgen_var_163;
                vkReadStream->read((uint64_t*)&cgen_var_163, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_163, (VkImageView*)pView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pView;
                if (pCreateInfo)
                {
                    transform_tohost_VkImageViewCreateInfo(m_state, (VkImageViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(&m_pool, device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pView;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_164;
                vkStream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_164, 1);
                vkStream->write((uint64_t*)&cgen_var_164, 8);
                // Begin manual non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateImageView(&m_pool, vkCreateImageView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                break;
            }
            case OP_vkDestroyImageView:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyImageView\n");;
                }
                VkDevice device;
                VkImageView imageView;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_165;
                vkReadStream->read((uint64_t*)&cgen_var_165, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_165, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for imageView;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_166;
                vkReadStream->read((uint64_t*)&cgen_var_166, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_166, (VkImageView*)&imageView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for imageView;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyImageView(&m_pool, device, imageView, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyImageView(&m_pool, device, imageView, pAllocator);
                break;
            }
            case OP_vkCreateShaderModule:
            {
                VkDevice device;
                const VkShaderModuleCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_168;
                vkReadStream->read((uint64_t*)&cgen_var_168, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_168, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                unmarshal_VkShaderModuleCreateInfo(vkReadStream, (VkShaderModuleCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pShaderModule;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                uint64_t cgen_var_170;
                vkReadStream->read((uint64_t*)&cgen_var_170, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_170, (VkShaderModule*)pShaderModule, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pShaderModule;
                if (pCreateInfo)
                {
                    transform_tohost_VkShaderModuleCreateInfo(m_state, (VkShaderModuleCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = vk->vkCreateShaderModule(unboxed_device, pCreateInfo, pAllocator, pShaderModule);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pShaderModule;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_171;
                vkStream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_171, 1);
                vkStream->write((uint64_t*)&cgen_var_171, 8);
                // Begin auto non dispatchable handle create for pShaderModule;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateShaderModule(&m_pool, vkCreateShaderModule_VkResult_return, device, pCreateInfo, pAllocator, pShaderModule);
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                VkDevice device;
                VkShaderModule shaderModule;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_172;
                vkReadStream->read((uint64_t*)&cgen_var_172, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_172, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for shaderModule;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_173;
                vkReadStream->read((uint64_t*)&cgen_var_173, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_173, (VkShaderModule*)&shaderModule, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for shaderModule;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyShaderModule(unboxed_device, shaderModule, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyShaderModule(&m_pool, device, shaderModule, pAllocator);
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                VkDevice device;
                const VkPipelineCacheCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_175;
                vkReadStream->read((uint64_t*)&cgen_var_175, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_175, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                unmarshal_VkPipelineCacheCreateInfo(vkReadStream, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelineCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                uint64_t cgen_var_177;
                vkReadStream->read((uint64_t*)&cgen_var_177, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_177, (VkPipelineCache*)pPipelineCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelineCache;
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineCacheCreateInfo(m_state, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = vk->vkCreatePipelineCache(unboxed_device, pCreateInfo, pAllocator, pPipelineCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineCache;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_178;
                vkStream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_178, 1);
                vkStream->write((uint64_t*)&cgen_var_178, 8);
                // Begin auto non dispatchable handle create for pPipelineCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreatePipelineCache(&m_pool, vkCreatePipelineCache_VkResult_return, device, pCreateInfo, pAllocator, pPipelineCache);
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_179;
                vkReadStream->read((uint64_t*)&cgen_var_179, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_179, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineCache;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_180;
                vkReadStream->read((uint64_t*)&cgen_var_180, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_180, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipelineCache;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyPipelineCache(unboxed_device, pipelineCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyPipelineCache(&m_pool, device, pipelineCache, pAllocator);
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_182;
                vkReadStream->read((uint64_t*)&cgen_var_182, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_182, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_183;
                vkReadStream->read((uint64_t*)&cgen_var_183, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_183, (VkPipelineCache*)&pipelineCache, 1);
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDataSize;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_187 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_187);
                if (pDataSize)
                {
                    uint64_t cgen_var_188 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_188);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_189 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_189);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPipelineCacheData(&m_pool, vkGetPipelineCacheData_VkResult_return, device, pipelineCache, pDataSize, pData);
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                const VkPipelineCache* pSrcCaches;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_190;
                vkReadStream->read((uint64_t*)&cgen_var_190, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_190, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_191;
                vkReadStream->read((uint64_t*)&cgen_var_191, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_191, (VkPipelineCache*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_192;
                    vkReadStream->alloc((void**)&cgen_var_192, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_192, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(cgen_var_192, (VkPipelineCache*)pSrcCaches, ((srcCacheCount)));
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = vk->vkMergePipelineCaches(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkMergePipelineCaches(&m_pool, vkMergePipelineCaches_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkGraphicsPipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_193;
                vkReadStream->read((uint64_t*)&cgen_var_193, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_193, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_194;
                vkReadStream->read((uint64_t*)&cgen_var_194, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_194, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_196;
                    vkReadStream->alloc((void**)&cgen_var_196, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_196, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_196, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelines;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkGraphicsPipelineCreateInfo(m_state, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = vk->vkCreateGraphicsPipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_197;
                    vkStream->alloc((void**)&cgen_var_197, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_197, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_197, ((createInfoCount)) * 8);
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateGraphicsPipelines(&m_pool, vkCreateGraphicsPipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkComputePipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_198;
                vkReadStream->read((uint64_t*)&cgen_var_198, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_198, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_199;
                vkReadStream->read((uint64_t*)&cgen_var_199, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_199, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkComputePipelineCreateInfo(vkReadStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_201;
                    vkReadStream->alloc((void**)&cgen_var_201, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_201, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_201, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelines;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkComputePipelineCreateInfo(m_state, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = vk->vkCreateComputePipelines(unboxed_device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_202;
                    vkStream->alloc((void**)&cgen_var_202, ((createInfoCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_202, ((createInfoCount)));
                    vkStream->write((uint64_t*)cgen_var_202, ((createInfoCount)) * 8);
                }
                // Begin auto non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateComputePipelines(&m_pool, vkCreateComputePipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                break;
            }
            case OP_vkDestroyPipeline:
            {
                VkDevice device;
                VkPipeline pipeline;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_203;
                vkReadStream->read((uint64_t*)&cgen_var_203, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_203, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipeline;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_204;
                vkReadStream->read((uint64_t*)&cgen_var_204, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_204, (VkPipeline*)&pipeline, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipeline;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyPipeline(unboxed_device, pipeline, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyPipeline(&m_pool, device, pipeline, pAllocator);
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                VkDevice device;
                const VkPipelineLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_206;
                vkReadStream->read((uint64_t*)&cgen_var_206, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_206, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                unmarshal_VkPipelineLayoutCreateInfo(vkReadStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelineLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                uint64_t cgen_var_208;
                vkReadStream->read((uint64_t*)&cgen_var_208, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_208, (VkPipelineLayout*)pPipelineLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelineLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineLayoutCreateInfo(m_state, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = vk->vkCreatePipelineLayout(unboxed_device, pCreateInfo, pAllocator, pPipelineLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineLayout;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_209;
                vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_209, 1);
                vkStream->write((uint64_t*)&cgen_var_209, 8);
                // Begin auto non dispatchable handle create for pPipelineLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreatePipelineLayout(&m_pool, vkCreatePipelineLayout_VkResult_return, device, pCreateInfo, pAllocator, pPipelineLayout);
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_210;
                vkReadStream->read((uint64_t*)&cgen_var_210, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_210, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineLayout;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_211;
                vkReadStream->read((uint64_t*)&cgen_var_211, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_211, (VkPipelineLayout*)&pipelineLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipelineLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyPipelineLayout(unboxed_device, pipelineLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyPipelineLayout(&m_pool, device, pipelineLayout, pAllocator);
                break;
            }
            case OP_vkCreateSampler:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateSampler\n");;
                }
                VkDevice device;
                const VkSamplerCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_213;
                vkReadStream->read((uint64_t*)&cgen_var_213, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_213, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                unmarshal_VkSamplerCreateInfo(vkReadStream, (VkSamplerCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSampler;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                uint64_t cgen_var_215;
                vkReadStream->read((uint64_t*)&cgen_var_215, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_215, (VkSampler*)pSampler, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSampler;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerCreateInfo(m_state, (VkSamplerCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_state->on_vkCreateSampler(&m_pool, device, pCreateInfo, pAllocator, pSampler);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_216;
                vkStream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_216, 1);
                vkStream->write((uint64_t*)&cgen_var_216, 8);
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSampler(&m_pool, vkCreateSampler_VkResult_return, device, pCreateInfo, pAllocator, pSampler);
                break;
            }
            case OP_vkDestroySampler:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroySampler\n");;
                }
                VkDevice device;
                VkSampler sampler;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_217;
                vkReadStream->read((uint64_t*)&cgen_var_217, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_217, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for sampler;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_218;
                vkReadStream->read((uint64_t*)&cgen_var_218, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_218, (VkSampler*)&sampler, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for sampler;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroySampler(&m_pool, device, sampler, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySampler(&m_pool, device, sampler, pAllocator);
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_220;
                vkReadStream->read((uint64_t*)&cgen_var_220, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_220, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSetLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                uint64_t cgen_var_222;
                vkReadStream->read((uint64_t*)&cgen_var_222, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_222, (VkDescriptorSetLayout*)pSetLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSetLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = vk->vkCreateDescriptorSetLayout(unboxed_device, pCreateInfo, pAllocator, pSetLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pSetLayout;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_223;
                vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_223, 1);
                vkStream->write((uint64_t*)&cgen_var_223, 8);
                // Begin auto non dispatchable handle create for pSetLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDescriptorSetLayout(&m_pool, vkCreateDescriptorSetLayout_VkResult_return, device, pCreateInfo, pAllocator, pSetLayout);
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_224;
                vkReadStream->read((uint64_t*)&cgen_var_224, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_224, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_225;
                vkReadStream->read((uint64_t*)&cgen_var_225, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_225, (VkDescriptorSetLayout*)&descriptorSetLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyDescriptorSetLayout(unboxed_device, descriptorSetLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDescriptorSetLayout(&m_pool, device, descriptorSetLayout, pAllocator);
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                VkDevice device;
                const VkDescriptorPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_227;
                vkReadStream->read((uint64_t*)&cgen_var_227, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_227, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                unmarshal_VkDescriptorPoolCreateInfo(vkReadStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                uint64_t cgen_var_229;
                vkReadStream->read((uint64_t*)&cgen_var_229, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_229, (VkDescriptorPool*)pDescriptorPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorPoolCreateInfo(m_state, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = vk->vkCreateDescriptorPool(unboxed_device, pCreateInfo, pAllocator, pDescriptorPool);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pDescriptorPool;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_230;
                vkStream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_230, 1);
                vkStream->write((uint64_t*)&cgen_var_230, 8);
                // Begin auto non dispatchable handle create for pDescriptorPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDescriptorPool(&m_pool, vkCreateDescriptorPool_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorPool);
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_231;
                vkReadStream->read((uint64_t*)&cgen_var_231, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_231, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorPool;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_232;
                vkReadStream->read((uint64_t*)&cgen_var_232, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_232, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyDescriptorPool(unboxed_device, descriptorPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDescriptorPool(&m_pool, device, descriptorPool, pAllocator);
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_234;
                vkReadStream->read((uint64_t*)&cgen_var_234, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_234, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_235;
                vkReadStream->read((uint64_t*)&cgen_var_235, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_235, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = vk->vkResetDescriptorPool(unboxed_device, descriptorPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetDescriptorPool(&m_pool, vkResetDescriptorPool_VkResult_return, device, descriptorPool, flags);
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                VkDevice device;
                const VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_236;
                vkReadStream->read((uint64_t*)&cgen_var_236, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_236, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                unmarshal_VkDescriptorSetAllocateInfo(vkReadStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                // Begin manual dispatchable handle unboxing for pDescriptorSets;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_237;
                    vkReadStream->alloc((void**)&cgen_var_237, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_237, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_237, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorSets;
                if (pAllocateInfo)
                {
                    transform_tohost_VkDescriptorSetAllocateInfo(m_state, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = vk->vkAllocateDescriptorSets(unboxed_device, pAllocateInfo, pDescriptorSets);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pDescriptorSets;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_238;
                    vkStream->alloc((void**)&cgen_var_238, pAllocateInfo->descriptorSetCount * 8);
                    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_238, pAllocateInfo->descriptorSetCount);
                    vkStream->write((uint64_t*)cgen_var_238, pAllocateInfo->descriptorSetCount * 8);
                }
                // Begin auto non dispatchable handle create for pDescriptorSets;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAllocateDescriptorSets(&m_pool, vkAllocateDescriptorSets_VkResult_return, device, pAllocateInfo, pDescriptorSets);
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_239;
                vkReadStream->read((uint64_t*)&cgen_var_239, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_239, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_240;
                vkReadStream->read((uint64_t*)&cgen_var_240, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_240, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                // Begin manual non dispatchable handle destroy unboxing for pDescriptorSets;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                // WARNING PTR CHECK
                pDescriptorSets = (const VkDescriptorSet*)(uintptr_t)vkReadStream->getBe64();
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    if (((descriptorSetCount)))
                    {
                        uint64_t* cgen_var_242;
                        vkReadStream->alloc((void**)&cgen_var_242, ((descriptorSetCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_242, ((descriptorSetCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_242, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pDescriptorSets;
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = vk->vkFreeDescriptorSets(unboxed_device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkFreeDescriptorSets(&m_pool, vkFreeDescriptorSets_VkResult_return, device, descriptorPool, descriptorSetCount, pDescriptorSets);
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSets\n");;
                }
                VkDevice device;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                const VkCopyDescriptorSet* pDescriptorCopies;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_243;
                vkReadStream->read((uint64_t*)&cgen_var_243, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_243, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                vkReadStream->read((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    unmarshal_VkCopyDescriptorSet(vkReadStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (pDescriptorCopies)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                    {
                        transform_tohost_VkCopyDescriptorSet(m_state, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                    }
                }
                m_state->on_vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                VkDevice device;
                const VkFramebufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_244;
                vkReadStream->read((uint64_t*)&cgen_var_244, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_244, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                unmarshal_VkFramebufferCreateInfo(vkReadStream, (VkFramebufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFramebuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                uint64_t cgen_var_246;
                vkReadStream->read((uint64_t*)&cgen_var_246, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_246, (VkFramebuffer*)pFramebuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFramebuffer;
                if (pCreateInfo)
                {
                    transform_tohost_VkFramebufferCreateInfo(m_state, (VkFramebufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = vk->vkCreateFramebuffer(unboxed_device, pCreateInfo, pAllocator, pFramebuffer);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFramebuffer;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_247;
                vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_247, 1);
                vkStream->write((uint64_t*)&cgen_var_247, 8);
                // Begin auto non dispatchable handle create for pFramebuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateFramebuffer(&m_pool, vkCreateFramebuffer_VkResult_return, device, pCreateInfo, pAllocator, pFramebuffer);
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                VkDevice device;
                VkFramebuffer framebuffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_248;
                vkReadStream->read((uint64_t*)&cgen_var_248, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_248, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for framebuffer;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_249;
                vkReadStream->read((uint64_t*)&cgen_var_249, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_249, (VkFramebuffer*)&framebuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for framebuffer;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyFramebuffer(unboxed_device, framebuffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyFramebuffer(&m_pool, device, framebuffer, pAllocator);
                break;
            }
            case OP_vkCreateRenderPass:
            {
                VkDevice device;
                const VkRenderPassCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_251;
                vkReadStream->read((uint64_t*)&cgen_var_251, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_251, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                unmarshal_VkRenderPassCreateInfo(vkReadStream, (VkRenderPassCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_253;
                vkReadStream->read((uint64_t*)&cgen_var_253, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_253, (VkRenderPass*)pRenderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRenderPass;
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo(m_state, (VkRenderPassCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = vk->vkCreateRenderPass(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pRenderPass;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_254;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_254, 1);
                vkStream->write((uint64_t*)&cgen_var_254, 8);
                // Begin auto non dispatchable handle create for pRenderPass;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateRenderPass(&m_pool, vkCreateRenderPass_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                VkDevice device;
                VkRenderPass renderPass;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_255;
                vkReadStream->read((uint64_t*)&cgen_var_255, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_255, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for renderPass;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_256;
                vkReadStream->read((uint64_t*)&cgen_var_256, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_256, (VkRenderPass*)&renderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for renderPass;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyRenderPass(unboxed_device, renderPass, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyRenderPass(&m_pool, device, renderPass, pAllocator);
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_258;
                vkReadStream->read((uint64_t*)&cgen_var_258, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_258, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_259;
                vkReadStream->read((uint64_t*)&cgen_var_259, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_259, (VkRenderPass*)&renderPass, 1);
                // Begin manual dispatchable handle unboxing for pGranularity;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                unmarshal_VkExtent2D(vkReadStream, (VkExtent2D*)(pGranularity));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pGranularity;
                if (pGranularity)
                {
                    transform_tohost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
                vkStream->unsetHandleMapping();
                if (pGranularity)
                {
                    transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetRenderAreaGranularity(&m_pool, device, renderPass, pGranularity);
                break;
            }
            case OP_vkCreateCommandPool:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateCommandPool\n");;
                }
                VkDevice device;
                const VkCommandPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_260;
                vkReadStream->read((uint64_t*)&cgen_var_260, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_260, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                unmarshal_VkCommandPoolCreateInfo(vkReadStream, (VkCommandPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pCommandPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                uint64_t cgen_var_262;
                vkReadStream->read((uint64_t*)&cgen_var_262, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_262, (VkCommandPool*)pCommandPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommandPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkCommandPoolCreateInfo(m_state, (VkCommandPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_state->on_vkCreateCommandPool(&m_pool, device, pCreateInfo, pAllocator, pCommandPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_263;
                vkStream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_263, 1);
                vkStream->write((uint64_t*)&cgen_var_263, 8);
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateCommandPool(&m_pool, vkCreateCommandPool_VkResult_return, device, pCreateInfo, pAllocator, pCommandPool);
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyCommandPool\n");;
                }
                VkDevice device;
                VkCommandPool commandPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_264;
                vkReadStream->read((uint64_t*)&cgen_var_264, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_264, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for commandPool;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_265;
                vkReadStream->read((uint64_t*)&cgen_var_265, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_265, (VkCommandPool*)&commandPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for commandPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
                break;
            }
            case OP_vkResetCommandPool:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandPool\n");;
                }
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_267;
                vkReadStream->read((uint64_t*)&cgen_var_267, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_267, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_268;
                vkReadStream->read((uint64_t*)&cgen_var_268, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_268, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_state->on_vkResetCommandPool(&m_pool, device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetCommandPool(&m_pool, vkResetCommandPool_VkResult_return, device, commandPool, flags);
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAllocateCommandBuffers\n");;
                }
                VkDevice device;
                const VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_269;
                vkReadStream->read((uint64_t*)&cgen_var_269, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_269, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                unmarshal_VkCommandBufferAllocateInfo(vkReadStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                // Begin manual dispatchable handle unboxing for pCommandBuffers;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_270;
                    vkReadStream->alloc((void**)&cgen_var_270, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_270, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_270, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommandBuffers;
                if (pAllocateInfo)
                {
                    transform_tohost_VkCommandBufferAllocateInfo(m_state, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(&m_pool, device, pAllocateInfo, pCommandBuffers);
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_271;
                    vkStream->alloc((void**)&cgen_var_271, pAllocateInfo->commandBufferCount * 8);
                    vkStream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_271, pAllocateInfo->commandBufferCount);
                    vkStream->write((uint64_t*)cgen_var_271, pAllocateInfo->commandBufferCount * 8);
                }
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAllocateCommandBuffers(&m_pool, vkAllocateCommandBuffers_VkResult_return, device, pAllocateInfo, pCommandBuffers);
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkFreeCommandBuffers\n");;
                }
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_272;
                vkReadStream->read((uint64_t*)&cgen_var_272, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_272, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_273;
                vkReadStream->read((uint64_t*)&cgen_var_273, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_273, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pCommandBuffers = (const VkCommandBuffer*)(uintptr_t)vkReadStream->getBe64();
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    if (((commandBufferCount)))
                    {
                        uint64_t* cgen_var_275;
                        vkReadStream->alloc((void**)&cgen_var_275, ((commandBufferCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_275, ((commandBufferCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_275, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                    }
                }
                m_state->on_vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount, pCommandBuffers);
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBeginCommandBuffer\n");;
                }
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_276;
                vkReadStream->read((uint64_t*)&cgen_var_276, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_276, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_state->on_vkBeginCommandBuffer(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBeginCommandBuffer(&m_pool, vkBeginCommandBuffer_VkResult_return, commandBuffer, pBeginInfo);
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_277;
                vkReadStream->read((uint64_t*)&cgen_var_277, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_277, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = vk->vkEndCommandBuffer(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEndCommandBuffer(&m_pool, vkEndCommandBuffer_VkResult_return, commandBuffer);
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandBuffer\n");;
                }
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_278;
                vkReadStream->read((uint64_t*)&cgen_var_278, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_278, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = m_state->on_vkResetCommandBuffer(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetCommandBuffer(&m_pool, vkResetCommandBuffer_VkResult_return, commandBuffer, flags);
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindPipeline\n");;
                }
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_279;
                vkReadStream->read((uint64_t*)&cgen_var_279, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_279, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_280;
                vkReadStream->read((uint64_t*)&cgen_var_280, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_280, (VkPipeline*)&pipeline, 1);
                m_state->on_vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
                break;
            }
            case OP_vkCmdSetViewport:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_281;
                vkReadStream->read((uint64_t*)&cgen_var_281, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_281, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewport(vkReadStream, (VkViewport*)(pViewports + i));
                }
                if (pViewports)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewport(m_state, (VkViewport*)(pViewports + i));
                    }
                }
                vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount, pViewports);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetViewport(&m_pool, commandBuffer, firstViewport, viewportCount, pViewports);
                break;
            }
            case OP_vkCmdSetScissor:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_282;
                vkReadStream->read((uint64_t*)&cgen_var_282, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_282, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstScissor, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&scissorCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pScissors + i));
                }
                if (pScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pScissors + i));
                    }
                }
                vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount, pScissors);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetScissor(&m_pool, commandBuffer, firstScissor, scissorCount, pScissors);
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                VkCommandBuffer commandBuffer;
                float lineWidth;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_283;
                vkReadStream->read((uint64_t*)&cgen_var_283, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_283, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&lineWidth, sizeof(float));
                vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetLineWidth(&m_pool, commandBuffer, lineWidth);
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_284;
                vkReadStream->read((uint64_t*)&cgen_var_284, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_284, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&depthBiasConstantFactor, sizeof(float));
                vkReadStream->read((float*)&depthBiasClamp, sizeof(float));
                vkReadStream->read((float*)&depthBiasSlopeFactor, sizeof(float));
                vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetDepthBias(&m_pool, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_285;
                vkReadStream->read((uint64_t*)&cgen_var_285, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_285, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&blendConstants, 4 * sizeof(const float));
                vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetBlendConstants(&m_pool, commandBuffer, blendConstants);
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_286;
                vkReadStream->read((uint64_t*)&cgen_var_286, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_286, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&minDepthBounds, sizeof(float));
                vkReadStream->read((float*)&maxDepthBounds, sizeof(float));
                vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetDepthBounds(&m_pool, commandBuffer, minDepthBounds, maxDepthBounds);
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_287;
                vkReadStream->read((uint64_t*)&cgen_var_287, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_287, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&compareMask, sizeof(uint32_t));
                vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetStencilCompareMask(&m_pool, commandBuffer, faceMask, compareMask);
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_288;
                vkReadStream->read((uint64_t*)&cgen_var_288, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_288, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&writeMask, sizeof(uint32_t));
                vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetStencilWriteMask(&m_pool, commandBuffer, faceMask, writeMask);
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_289;
                vkReadStream->read((uint64_t*)&cgen_var_289, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_289, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&reference, sizeof(uint32_t));
                vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetStencilReference(&m_pool, commandBuffer, faceMask, reference);
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdBindDescriptorSets\n");;
                }
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_290;
                vkReadStream->read((uint64_t*)&cgen_var_290, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_290, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_291;
                vkReadStream->read((uint64_t*)&cgen_var_291, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_291, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&firstSet, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                if (((descriptorSetCount)))
                {
                    uint64_t* cgen_var_292;
                    vkReadStream->alloc((void**)&cgen_var_292, ((descriptorSetCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_292, ((descriptorSetCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_292, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                }
                vkReadStream->read((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                m_state->on_vkCmdBindDescriptorSets(&m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBindDescriptorSets(&m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_293;
                vkReadStream->read((uint64_t*)&cgen_var_293, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_293, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_294;
                vkReadStream->read((uint64_t*)&cgen_var_294, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_294, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkIndexType*)&indexType, sizeof(VkIndexType));
                vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBindIndexBuffer(&m_pool, commandBuffer, buffer, offset, indexType);
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_295;
                vkReadStream->read((uint64_t*)&cgen_var_295, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_295, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstBinding, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bindingCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint64_t* cgen_var_296;
                    vkReadStream->alloc((void**)&cgen_var_296, ((bindingCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_296, ((bindingCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(cgen_var_296, (VkBuffer*)pBuffers, ((bindingCount)));
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBindVertexBuffers(&m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                break;
            }
            case OP_vkCmdDraw:
            {
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_297;
                vkReadStream->read((uint64_t*)&cgen_var_297, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_297, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&vertexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstVertex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDraw(&m_pool, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_298;
                vkReadStream->read((uint64_t*)&cgen_var_298, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_298, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&indexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstIndex, sizeof(uint32_t));
                vkReadStream->read((int32_t*)&vertexOffset, sizeof(int32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndexed(&m_pool, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_299;
                vkReadStream->read((uint64_t*)&cgen_var_299, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_299, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_300;
                vkReadStream->read((uint64_t*)&cgen_var_300, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_300, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndirect(&m_pool, commandBuffer, buffer, offset, drawCount, stride);
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_301;
                vkReadStream->read((uint64_t*)&cgen_var_301, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_301, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_302;
                vkReadStream->read((uint64_t*)&cgen_var_302, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_302, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndexedIndirect(&m_pool, commandBuffer, buffer, offset, drawCount, stride);
                break;
            }
            case OP_vkCmdDispatch:
            {
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_303;
                vkReadStream->read((uint64_t*)&cgen_var_303, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_303, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDispatch(&m_pool, commandBuffer, groupCountX, groupCountY, groupCountZ);
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_304;
                vkReadStream->read((uint64_t*)&cgen_var_304, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_304, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_305;
                vkReadStream->read((uint64_t*)&cgen_var_305, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_305, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDispatchIndirect(&m_pool, commandBuffer, buffer, offset);
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_306;
                vkReadStream->read((uint64_t*)&cgen_var_306, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_306, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_307;
                vkReadStream->read((uint64_t*)&cgen_var_307, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_307, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_308;
                vkReadStream->read((uint64_t*)&cgen_var_308, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_308, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferCopy(vkReadStream, (VkBufferCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferCopy(m_state, (VkBufferCopy*)(pRegions + i));
                    }
                }
                vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdCopyBuffer(&m_pool, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                break;
            }
            case OP_vkCmdCopyImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_309;
                vkReadStream->read((uint64_t*)&cgen_var_309, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_309, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_310;
                vkReadStream->read((uint64_t*)&cgen_var_310, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_310, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_311;
                vkReadStream->read((uint64_t*)&cgen_var_311, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_311, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageCopy(vkReadStream, (VkImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageCopy(m_state, (VkImageCopy*)(pRegions + i));
                    }
                }
                vk->vkCmdCopyImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdCopyImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                break;
            }
            case OP_vkCmdBlitImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkFilter filter;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_312;
                vkReadStream->read((uint64_t*)&cgen_var_312, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_312, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_313;
                vkReadStream->read((uint64_t*)&cgen_var_313, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_313, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_314;
                vkReadStream->read((uint64_t*)&cgen_var_314, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_314, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageBlit(vkReadStream, (VkImageBlit*)(pRegions + i));
                }
                vkReadStream->read((VkFilter*)&filter, sizeof(VkFilter));
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageBlit(m_state, (VkImageBlit*)(pRegions + i));
                    }
                }
                vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBlitImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyBufferToImage\n");;
                }
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_315;
                vkReadStream->read((uint64_t*)&cgen_var_315, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_315, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_316;
                vkReadStream->read((uint64_t*)&cgen_var_316, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_316, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_317;
                vkReadStream->read((uint64_t*)&cgen_var_317, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_317, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                m_state->on_vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdCopyImageToBuffer\n");;
                }
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_318;
                vkReadStream->read((uint64_t*)&cgen_var_318, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_318, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_319;
                vkReadStream->read((uint64_t*)&cgen_var_319, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_319, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_320;
                vkReadStream->read((uint64_t*)&cgen_var_320, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_320, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                m_state->on_vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_321;
                vkReadStream->read((uint64_t*)&cgen_var_321, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_321, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_322;
                vkReadStream->read((uint64_t*)&cgen_var_322, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_322, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(const uint8_t));
                vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdUpdateBuffer(&m_pool, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_323;
                vkReadStream->read((uint64_t*)&cgen_var_323, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_323, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_324;
                vkReadStream->read((uint64_t*)&cgen_var_324, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_324, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&data, sizeof(uint32_t));
                vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdFillBuffer(&m_pool, commandBuffer, dstBuffer, dstOffset, size, data);
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_325;
                vkReadStream->read((uint64_t*)&cgen_var_325, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_325, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_326;
                vkReadStream->read((uint64_t*)&cgen_var_326, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_326, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                unmarshal_VkClearColorValue(vkReadStream, (VkClearColorValue*)(pColor));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (pColor)
                {
                    transform_tohost_VkClearColorValue(m_state, (VkClearColorValue*)(pColor));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdClearColorImage(&m_pool, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_327;
                vkReadStream->read((uint64_t*)&cgen_var_327, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_327, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_328;
                vkReadStream->read((uint64_t*)&cgen_var_328, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_328, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                unmarshal_VkClearDepthStencilValue(vkReadStream, (VkClearDepthStencilValue*)(pDepthStencil));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (pDepthStencil)
                {
                    transform_tohost_VkClearDepthStencilValue(m_state, (VkClearDepthStencilValue*)(pDepthStencil));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdClearDepthStencilImage(&m_pool, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                uint32_t rectCount;
                const VkClearRect* pRects;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_329;
                vkReadStream->read((uint64_t*)&cgen_var_329, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_329, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&attachmentCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    unmarshal_VkClearAttachment(vkReadStream, (VkClearAttachment*)(pAttachments + i));
                }
                vkReadStream->read((uint32_t*)&rectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    unmarshal_VkClearRect(vkReadStream, (VkClearRect*)(pRects + i));
                }
                if (pAttachments)
                {
                    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                    {
                        transform_tohost_VkClearAttachment(m_state, (VkClearAttachment*)(pAttachments + i));
                    }
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                    {
                        transform_tohost_VkClearRect(m_state, (VkClearRect*)(pRects + i));
                    }
                }
                vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdClearAttachments(&m_pool, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                break;
            }
            case OP_vkCmdResolveImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_330;
                vkReadStream->read((uint64_t*)&cgen_var_330, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_330, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_331;
                vkReadStream->read((uint64_t*)&cgen_var_331, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_331, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_332;
                vkReadStream->read((uint64_t*)&cgen_var_332, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_332, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageResolve(vkReadStream, (VkImageResolve*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageResolve(m_state, (VkImageResolve*)(pRegions + i));
                    }
                }
                vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdResolveImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                break;
            }
            case OP_vkCmdSetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_333;
                vkReadStream->read((uint64_t*)&cgen_var_333, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_333, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_334;
                vkReadStream->read((uint64_t*)&cgen_var_334, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_334, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetEvent(&m_pool, commandBuffer, event, stageMask);
                break;
            }
            case OP_vkCmdResetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_335;
                vkReadStream->read((uint64_t*)&cgen_var_335, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_335, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_336;
                vkReadStream->read((uint64_t*)&cgen_var_336, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_336, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdResetEvent(&m_pool, commandBuffer, event, stageMask);
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_337;
                vkReadStream->read((uint64_t*)&cgen_var_337, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_337, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&eventCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                if (((eventCount)))
                {
                    uint64_t* cgen_var_338;
                    vkReadStream->alloc((void**)&cgen_var_338, ((eventCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_338, ((eventCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkEvent(cgen_var_338, (VkEvent*)pEvents, ((eventCount)));
                }
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdWaitEvents(&m_pool, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdPipelineBarrier\n");;
                }
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_339;
                vkReadStream->read((uint64_t*)&cgen_var_339, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_339, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                m_state->on_vkCmdPipelineBarrier(&m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdPipelineBarrier(&m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_340;
                vkReadStream->read((uint64_t*)&cgen_var_340, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_340, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_341;
                vkReadStream->read((uint64_t*)&cgen_var_341, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_341, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vkReadStream->read((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
                vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBeginQuery(&m_pool, commandBuffer, queryPool, query, flags);
                break;
            }
            case OP_vkCmdEndQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_342;
                vkReadStream->read((uint64_t*)&cgen_var_342, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_342, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_343;
                vkReadStream->read((uint64_t*)&cgen_var_343, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_343, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdEndQuery(&m_pool, commandBuffer, queryPool, query);
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_344;
                vkReadStream->read((uint64_t*)&cgen_var_344, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_344, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_345;
                vkReadStream->read((uint64_t*)&cgen_var_345, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_345, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdResetQueryPool(&m_pool, commandBuffer, queryPool, firstQuery, queryCount);
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_346;
                vkReadStream->read((uint64_t*)&cgen_var_346, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_346, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_347;
                vkReadStream->read((uint64_t*)&cgen_var_347, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_347, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdWriteTimestamp(&m_pool, commandBuffer, pipelineStage, queryPool, query);
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_348;
                vkReadStream->read((uint64_t*)&cgen_var_348, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_348, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_349;
                vkReadStream->read((uint64_t*)&cgen_var_349, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_349, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                uint64_t cgen_var_350;
                vkReadStream->read((uint64_t*)&cgen_var_350, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_350, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdCopyQueryPoolResults(&m_pool, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                break;
            }
            case OP_vkCmdPushConstants:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_351;
                vkReadStream->read((uint64_t*)&cgen_var_351, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_351, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_352;
                vkReadStream->read((uint64_t*)&cgen_var_352, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_352, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
                vkReadStream->read((uint32_t*)&offset, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&size, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pValues, ((size)) * sizeof(const uint8_t));
                vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size, pValues);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdPushConstants(&m_pool, commandBuffer, layout, stageFlags, offset, size, pValues);
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_353;
                vkReadStream->read((uint64_t*)&cgen_var_353, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_353, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                vk->vkCmdBeginRenderPass(unboxed_commandBuffer, pRenderPassBegin, contents);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBeginRenderPass(&m_pool, commandBuffer, pRenderPassBegin, contents);
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_354;
                vkReadStream->read((uint64_t*)&cgen_var_354, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_354, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdNextSubpass(&m_pool, commandBuffer, contents);
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_355;
                vkReadStream->read((uint64_t*)&cgen_var_355, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_355, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vk->vkCmdEndRenderPass(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdEndRenderPass(&m_pool, commandBuffer);
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCmdExecuteCommands\n");;
                }
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_356;
                vkReadStream->read((uint64_t*)&cgen_var_356, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_356, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (((commandBufferCount)))
                {
                    uint64_t* cgen_var_357;
                    vkReadStream->alloc((void**)&cgen_var_357, ((commandBufferCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_357, ((commandBufferCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_357, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                }
                m_state->on_vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEnumerateInstanceVersion\n");;
                }
                uint32_t* pApiVersion;
                // Begin manual dispatchable handle unboxing for pApiVersion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pApiVersion;
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_state->on_vkEnumerateInstanceVersion(&m_pool, pApiVersion);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumerateInstanceVersion(&m_pool, vkEnumerateInstanceVersion_VkResult_return, pApiVersion);
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2\n");;
                }
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_358;
                vkReadStream->read((uint64_t*)&cgen_var_358, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_358, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_state->on_vkBindBufferMemory2(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindBufferMemory2(&m_pool, vkBindBufferMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                break;
            }
            case OP_vkBindImageMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_359;
                vkReadStream->read((uint64_t*)&cgen_var_359, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_359, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = vk->vkBindImageMemory2(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindImageMemory2(&m_pool, vkBindImageMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_360;
                vkReadStream->read((uint64_t*)&cgen_var_360, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_360, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeatures(&m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_361;
                vkReadStream->read((uint64_t*)&cgen_var_361, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_361, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetDeviceMask(&m_pool, commandBuffer, deviceMask);
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_362;
                vkReadStream->read((uint64_t*)&cgen_var_362, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_362, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDispatchBase(&m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_363;
                vkReadStream->read((uint64_t*)&cgen_var_363, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_363, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = vk->vkEnumeratePhysicalDeviceGroups(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_366 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_366);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_367 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_367);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumeratePhysicalDeviceGroups(&m_pool, vkEnumeratePhysicalDeviceGroups_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2\n");;
                }
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_368;
                vkReadStream->read((uint64_t*)&cgen_var_368, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_368, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                m_state->on_vkGetImageMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_369;
                vkReadStream->read((uint64_t*)&cgen_var_369, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_369, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                vk->vkGetBufferMemoryRequirements2(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetBufferMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_370;
                vkReadStream->read((uint64_t*)&cgen_var_370, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_370, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_373 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_373);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_374 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_374);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageSparseMemoryRequirements2(&m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_375;
                vkReadStream->read((uint64_t*)&cgen_var_375, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_375, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_376;
                vkReadStream->read((uint64_t*)&cgen_var_376, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_376, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_377;
                vkReadStream->read((uint64_t*)&cgen_var_377, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_377, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format, pFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_378;
                vkReadStream->read((uint64_t*)&cgen_var_378, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_378, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2(&m_pool, vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_379;
                vkReadStream->read((uint64_t*)&cgen_var_379, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_379, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_382 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_382);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_383 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_383);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2(&m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_384;
                vkReadStream->read((uint64_t*)&cgen_var_384, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_384, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice, pMemoryProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_385;
                vkReadStream->read((uint64_t*)&cgen_var_385, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_385, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_388 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_388);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_389 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_389);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2(&m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                break;
            }
            case OP_vkTrimCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_390;
                vkReadStream->read((uint64_t*)&cgen_var_390, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_390, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_391;
                vkReadStream->read((uint64_t*)&cgen_var_391, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_391, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkTrimCommandPool(&m_pool, device, commandPool, flags);
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                VkDevice device;
                const VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_392;
                vkReadStream->read((uint64_t*)&cgen_var_392, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_392, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                unmarshal_VkDeviceQueueInfo2(vkReadStream, (VkDeviceQueueInfo2*)(pQueueInfo));
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_393;
                vkReadStream->read((uint64_t*)&cgen_var_393, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_393, (VkQueue*)pQueue, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueue;
                if (pQueueInfo)
                {
                    transform_tohost_VkDeviceQueueInfo2(m_state, (VkDeviceQueueInfo2*)(pQueueInfo));
                }
                vk->vkGetDeviceQueue2(unboxed_device, pQueueInfo, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_394;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_394, 1);
                vkStream->write((uint64_t*)&cgen_var_394, 8);
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceQueue2(&m_pool, device, pQueueInfo, pQueue);
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_395;
                vkReadStream->read((uint64_t*)&cgen_var_395, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_395, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_397;
                vkReadStream->read((uint64_t*)&cgen_var_397, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_397, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pYcbcrConversion;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = vk->vkCreateSamplerYcbcrConversion(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_398;
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_398, 1);
                vkStream->write((uint64_t*)&cgen_var_398, 8);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSamplerYcbcrConversion(&m_pool, vkCreateSamplerYcbcrConversion_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_399;
                vkReadStream->read((uint64_t*)&cgen_var_399, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_399, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_400;
                vkReadStream->read((uint64_t*)&cgen_var_400, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_400, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for ycbcrConversion;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroySamplerYcbcrConversion(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySamplerYcbcrConversion(&m_pool, device, ycbcrConversion, pAllocator);
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplate\n");;
                }
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_402;
                vkReadStream->read((uint64_t*)&cgen_var_402, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_402, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_404;
                vkReadStream->read((uint64_t*)&cgen_var_404, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_404, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplate(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_405;
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_405, 1);
                vkStream->write((uint64_t*)&cgen_var_405, 8);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDescriptorUpdateTemplate(&m_pool, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplate\n");;
                }
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_406;
                vkReadStream->read((uint64_t*)&cgen_var_406, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_406, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_407;
                vkReadStream->read((uint64_t*)&cgen_var_407, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_407, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyDescriptorUpdateTemplate(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDescriptorUpdateTemplate(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_409;
                vkReadStream->read((uint64_t*)&cgen_var_409, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_409, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_410;
                vkReadStream->read((uint64_t*)&cgen_var_410, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_410, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_411;
                vkReadStream->read((uint64_t*)&cgen_var_411, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_411, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUpdateDescriptorSetWithTemplate(&m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_413;
                vkReadStream->read((uint64_t*)&cgen_var_413, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_413, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalBufferProperties;
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                vk->vkGetPhysicalDeviceExternalBufferProperties(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalBufferProperties(&m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_414;
                vkReadStream->read((uint64_t*)&cgen_var_414, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_414, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalFenceProperties;
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                vk->vkGetPhysicalDeviceExternalFenceProperties(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalFenceProperties(&m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphoreProperties\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_415;
                vkReadStream->read((uint64_t*)&cgen_var_415, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_415, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphoreProperties(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_416;
                vkReadStream->read((uint64_t*)&cgen_var_416, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_416, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupport;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDescriptorSetLayoutSupport(&m_pool, device, pCreateInfo, pSupport);
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                VkInstance instance;
                VkSurfaceKHR surface;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_417;
                vkReadStream->read((uint64_t*)&cgen_var_417, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_417, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for surface;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_418;
                vkReadStream->read((uint64_t*)&cgen_var_418, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_418, (VkSurfaceKHR*)&surface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for surface;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroySurfaceKHR(unboxed_instance, surface, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySurfaceKHR(&m_pool, instance, surface, pAllocator);
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_420;
                vkReadStream->read((uint64_t*)&cgen_var_420, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_420, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                uint64_t cgen_var_421;
                vkReadStream->read((uint64_t*)&cgen_var_421, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_421, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSupported;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                vkReadStream->read((VkBool32*)pSupported, sizeof(VkBool32));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupported;
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceSupportKHR(unboxed_physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->unsetHandleMapping();
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceSupportKHR(&m_pool, vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, physicalDevice, queueFamilyIndex, surface, pSupported);
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_422;
                vkReadStream->read((uint64_t*)&cgen_var_422, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_422, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_423;
                vkReadStream->read((uint64_t*)&cgen_var_423, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_423, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                unmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(&m_pool, vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_424;
                vkReadStream->read((uint64_t*)&cgen_var_424, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_424, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_425;
                vkReadStream->read((uint64_t*)&cgen_var_425, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_425, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormatCount;
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormatKHR(vkReadStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormats;
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormatsKHR(unboxed_physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_428 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_428);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_429 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_429);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormatsKHR(&m_pool, vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_430;
                vkReadStream->read((uint64_t*)&cgen_var_430, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_430, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_431;
                vkReadStream->read((uint64_t*)&cgen_var_431, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_431, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pPresentModeCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentModeCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentModeCount;
                // Begin manual dispatchable handle unboxing for pPresentModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentModes = (VkPresentModeKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    vkReadStream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentModes;
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfacePresentModesKHR(unboxed_physicalDevice, surface, pPresentModeCount, pPresentModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_434 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_434);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_435 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_435);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfacePresentModesKHR(&m_pool, vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, physicalDevice, surface, pPresentModeCount, pPresentModes);
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                VkDevice device;
                const VkSwapchainCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_436;
                vkReadStream->read((uint64_t*)&cgen_var_436, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_436, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSwapchain;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                uint64_t cgen_var_438;
                vkReadStream->read((uint64_t*)&cgen_var_438, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_438, (VkSwapchainKHR*)pSwapchain, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchain;
                if (pCreateInfo)
                {
                    transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = vk->vkCreateSwapchainKHR(unboxed_device, pCreateInfo, pAllocator, pSwapchain);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pSwapchain;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_439;
                vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_439, 1);
                vkStream->write((uint64_t*)&cgen_var_439, 8);
                // Begin auto non dispatchable handle create for pSwapchain;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSwapchainKHR(&m_pool, vkCreateSwapchainKHR_VkResult_return, device, pCreateInfo, pAllocator, pSwapchain);
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_440;
                vkReadStream->read((uint64_t*)&cgen_var_440, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_440, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for swapchain;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_441;
                vkReadStream->read((uint64_t*)&cgen_var_441, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_441, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for swapchain;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySwapchainKHR(&m_pool, device, swapchain, pAllocator);
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_443;
                vkReadStream->read((uint64_t*)&cgen_var_443, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_443, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_444;
                vkReadStream->read((uint64_t*)&cgen_var_444, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_444, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pSwapchainImageCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSwapchainImageCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchainImageCount;
                // Begin manual dispatchable handle unboxing for pSwapchainImages;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSwapchainImages = (VkImage*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_447;
                        vkReadStream->alloc((void**)&cgen_var_447, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_447, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkImage(cgen_var_447, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchainImages;
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_448 = (uint64_t)(uintptr_t)pSwapchainImageCount;
                vkStream->putBe64(cgen_var_448);
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_449 = (uint64_t)(uintptr_t)pSwapchainImages;
                vkStream->putBe64(cgen_var_449);
                if (pSwapchainImages)
                {
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_450;
                        vkStream->alloc((void**)&cgen_var_450, (*(pSwapchainImageCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_450, (*(pSwapchainImageCount)));
                        vkStream->write((uint64_t*)cgen_var_450, (*(pSwapchainImageCount)) * 8);
                    }
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSwapchainImagesKHR(&m_pool, vkGetSwapchainImagesKHR_VkResult_return, device, swapchain, pSwapchainImageCount, pSwapchainImages);
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_451;
                vkReadStream->read((uint64_t*)&cgen_var_451, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_451, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_452;
                vkReadStream->read((uint64_t*)&cgen_var_452, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_452, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                uint64_t cgen_var_453;
                vkReadStream->read((uint64_t*)&cgen_var_453, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_453, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_454;
                vkReadStream->read((uint64_t*)&cgen_var_454, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_454, (VkFence*)&fence, 1);
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageIndex;
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAcquireNextImageKHR(&m_pool, vkAcquireNextImageKHR_VkResult_return, device, swapchain, timeout, semaphore, fence, pImageIndex);
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                VkQueue queue;
                const VkPresentInfoKHR* pPresentInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_455;
                vkReadStream->read((uint64_t*)&cgen_var_455, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_455, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                unmarshal_VkPresentInfoKHR(vkReadStream, (VkPresentInfoKHR*)(pPresentInfo));
                if (pPresentInfo)
                {
                    transform_tohost_VkPresentInfoKHR(m_state, (VkPresentInfoKHR*)(pPresentInfo));
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = vk->vkQueuePresentKHR(unboxed_queue, pPresentInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueuePresentKHR(&m_pool, vkQueuePresentKHR_VkResult_return, queue, pPresentInfo);
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_456;
                vkReadStream->read((uint64_t*)&cgen_var_456, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_456, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                unmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_tohost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device, pDeviceGroupPresentCapabilities);
                vkStream->unsetHandleMapping();
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceGroupPresentCapabilitiesKHR(&m_pool, vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, device, pDeviceGroupPresentCapabilities);
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_457;
                vkReadStream->read((uint64_t*)&cgen_var_457, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_457, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_458;
                vkReadStream->read((uint64_t*)&cgen_var_458, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_458, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    vkReadStream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pModes;
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_460 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_460);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceGroupSurfacePresentModesKHR(&m_pool, vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, device, surface, pModes);
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_461;
                vkReadStream->read((uint64_t*)&cgen_var_461, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_461, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_462;
                vkReadStream->read((uint64_t*)&cgen_var_462, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_462, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pRectCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pRectCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRectCount;
                // Begin manual dispatchable handle unboxing for pRects;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pRects = (VkRect2D*)(uintptr_t)vkReadStream->getBe64();
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRects;
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface, pRectCount, pRects);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_465 = (uint64_t)(uintptr_t)pRectCount;
                vkStream->putBe64(cgen_var_465);
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_fromhost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_466 = (uint64_t)(uintptr_t)pRects;
                vkStream->putBe64(cgen_var_466);
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDevicePresentRectanglesKHR(&m_pool, vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, physicalDevice, surface, pRectCount, pRects);
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                VkDevice device;
                const VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_467;
                vkReadStream->read((uint64_t*)&cgen_var_467, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_467, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                unmarshal_VkAcquireNextImageInfoKHR(vkReadStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageIndex;
                if (pAcquireInfo)
                {
                    transform_tohost_VkAcquireNextImageInfoKHR(m_state, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAcquireNextImage2KHR(&m_pool, vkAcquireNextImage2KHR_VkResult_return, device, pAcquireInfo, pImageIndex);
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_468;
                vkReadStream->read((uint64_t*)&cgen_var_468, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_468, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPropertiesKHR(vkReadStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_471 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_471);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_472 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_472);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceDisplayPropertiesKHR(&m_pool, vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_473;
                vkReadStream->read((uint64_t*)&cgen_var_473, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_473, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_476 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_476);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_477 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_477);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(&m_pool, vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_478;
                vkReadStream->read((uint64_t*)&cgen_var_478, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_478, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pDisplayCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDisplayCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplayCount;
                // Begin manual dispatchable handle unboxing for pDisplays;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDisplays = (VkDisplayKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_481;
                        vkReadStream->alloc((void**)&cgen_var_481, (*(pDisplayCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_481, (*(pDisplayCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_481, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplays;
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = vk->vkGetDisplayPlaneSupportedDisplaysKHR(unboxed_physicalDevice, planeIndex, pDisplayCount, pDisplays);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_482 = (uint64_t)(uintptr_t)pDisplayCount;
                vkStream->putBe64(cgen_var_482);
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_483 = (uint64_t)(uintptr_t)pDisplays;
                vkStream->putBe64(cgen_var_483);
                if (pDisplays)
                {
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_484;
                        vkStream->alloc((void**)&cgen_var_484, (*(pDisplayCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_484, (*(pDisplayCount)));
                        vkStream->write((uint64_t*)cgen_var_484, (*(pDisplayCount)) * 8);
                    }
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDisplayPlaneSupportedDisplaysKHR(&m_pool, vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, physicalDevice, planeIndex, pDisplayCount, pDisplays);
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_485;
                vkReadStream->read((uint64_t*)&cgen_var_485, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_485, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_486;
                vkReadStream->read((uint64_t*)&cgen_var_486, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_486, (VkDisplayKHR*)&display, 1);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModePropertiesKHR(vkReadStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = vk->vkGetDisplayModePropertiesKHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_489 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_489);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_490 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_490);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDisplayModePropertiesKHR(&m_pool, vkGetDisplayModePropertiesKHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                const VkDisplayModeCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_491;
                vkReadStream->read((uint64_t*)&cgen_var_491, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_491, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_492;
                vkReadStream->read((uint64_t*)&cgen_var_492, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_492, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                unmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMode;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                uint64_t cgen_var_494;
                vkReadStream->read((uint64_t*)&cgen_var_494, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_494, (VkDisplayModeKHR*)pMode, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMode;
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplayModeCreateInfoKHR(m_state, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = vk->vkCreateDisplayModeKHR(unboxed_physicalDevice, display, pCreateInfo, pAllocator, pMode);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMode;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_495;
                vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_495, 1);
                vkStream->write((uint64_t*)&cgen_var_495, 8);
                // Begin auto non dispatchable handle create for pMode;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDisplayModeKHR(&m_pool, vkCreateDisplayModeKHR_VkResult_return, physicalDevice, display, pCreateInfo, pAllocator, pMode);
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_496;
                vkReadStream->read((uint64_t*)&cgen_var_496, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_496, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_497;
                vkReadStream->read((uint64_t*)&cgen_var_497, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_497, (VkDisplayModeKHR*)&mode, 1);
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                unmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCapabilities;
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = vk->vkGetDisplayPlaneCapabilitiesKHR(unboxed_physicalDevice, mode, planeIndex, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDisplayPlaneCapabilitiesKHR(&m_pool, vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, physicalDevice, mode, planeIndex, pCapabilities);
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                VkInstance instance;
                const VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_498;
                vkReadStream->read((uint64_t*)&cgen_var_498, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_498, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                unmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_500;
                vkReadStream->read((uint64_t*)&cgen_var_500, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_500, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplaySurfaceCreateInfoKHR(m_state, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = vk->vkCreateDisplayPlaneSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_501;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_501, 1);
                vkStream->write((uint64_t*)&cgen_var_501, 8);
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDisplayPlaneSurfaceKHR(&m_pool, vkCreateDisplayPlaneSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_502;
                vkReadStream->read((uint64_t*)&cgen_var_502, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_502, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSwapchains;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_504;
                    vkReadStream->alloc((void**)&cgen_var_504, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_504, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_504, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchains;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = vk->vkCreateSharedSwapchainsKHR(unboxed_device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                vkStream->unsetHandleMapping();
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_505;
                    vkStream->alloc((void**)&cgen_var_505, ((swapchainCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_505, ((swapchainCount)));
                    vkStream->write((uint64_t*)cgen_var_505, ((swapchainCount)) * 8);
                }
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSharedSwapchainsKHR(&m_pool, vkCreateSharedSwapchainsKHR_VkResult_return, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                VkInstance instance;
                const VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_506;
                vkReadStream->read((uint64_t*)&cgen_var_506, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_506, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                unmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_508;
                vkReadStream->read((uint64_t*)&cgen_var_508, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_508, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkXlibSurfaceCreateInfoKHR(m_state, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = vk->vkCreateXlibSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_509;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_509, 1);
                vkStream->write((uint64_t*)&cgen_var_509, 8);
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateXlibSurfaceKHR(&m_pool, vkCreateXlibSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_510;
                vkReadStream->read((uint64_t*)&cgen_var_510, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_510, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                vkReadStream->read((VisualID*)&visualID, sizeof(VisualID));
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceXlibPresentationSupportKHR(&m_pool, vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, dpy, visualID);
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                VkInstance instance;
                const VkXcbSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_511;
                vkReadStream->read((uint64_t*)&cgen_var_511, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_511, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
                unmarshal_VkXcbSurfaceCreateInfoKHR(vkReadStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_513;
                vkReadStream->read((uint64_t*)&cgen_var_513, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_513, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkXcbSurfaceCreateInfoKHR(m_state, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXcbSurfaceKHR_VkResult_return = vk->vkCreateXcbSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_514;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_514, 1);
                vkStream->write((uint64_t*)&cgen_var_514, 8);
                vkStream->write(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateXcbSurfaceKHR(&m_pool, vkCreateXcbSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                xcb_connection_t* connection;
                xcb_visualid_t visual_id;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_515;
                vkReadStream->read((uint64_t*)&cgen_var_515, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_515, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for connection;
                vkReadStream->read((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
                VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXcbPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection, visual_id);
                vkStream->unsetHandleMapping();
                vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkStream->write(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceXcbPresentationSupportKHR(&m_pool, vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection, visual_id);
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                VkInstance instance;
                const VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_516;
                vkReadStream->read((uint64_t*)&cgen_var_516, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_516, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                unmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_518;
                vkReadStream->read((uint64_t*)&cgen_var_518, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_518, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkWaylandSurfaceCreateInfoKHR(m_state, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = vk->vkCreateWaylandSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_519;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_519, 1);
                vkStream->write((uint64_t*)&cgen_var_519, 8);
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateWaylandSurfaceKHR(&m_pool, vkCreateWaylandSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_520;
                vkReadStream->read((uint64_t*)&cgen_var_520, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_520, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for display;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                vkReadStream->read((wl_display*)display, sizeof(wl_display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for display;
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, display);
                vkStream->unsetHandleMapping();
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceWaylandPresentationSupportKHR(&m_pool, vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, display);
                break;
            }
#endif
#ifdef VK_KHR_mir_surface
            case OP_vkCreateMirSurfaceKHR:
            {
                VkInstance instance;
                const VkMirSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_521;
                vkReadStream->read((uint64_t*)&cgen_var_521, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_521, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
                unmarshal_VkMirSurfaceCreateInfoKHR(vkReadStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_523;
                vkReadStream->read((uint64_t*)&cgen_var_523, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_523, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkMirSurfaceCreateInfoKHR(m_state, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateMirSurfaceKHR_VkResult_return = vk->vkCreateMirSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_524;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_524, 1);
                vkStream->write((uint64_t*)&cgen_var_524, 8);
                vkStream->write(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateMirSurfaceKHR(&m_pool, vkCreateMirSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
            case OP_vkGetPhysicalDeviceMirPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                MirConnection* connection;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_525;
                vkReadStream->read((uint64_t*)&cgen_var_525, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_525, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(MirConnection));
                vkReadStream->read((MirConnection*)connection, sizeof(MirConnection));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for connection;
                VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceMirPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection);
                vkStream->unsetHandleMapping();
                vkStream->write((MirConnection*)connection, sizeof(MirConnection));
                vkStream->write(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceMirPresentationSupportKHR(&m_pool, vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection);
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                VkInstance instance;
                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_526;
                vkReadStream->read((uint64_t*)&cgen_var_526, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_526, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                unmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_528;
                vkReadStream->read((uint64_t*)&cgen_var_528, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_528, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkAndroidSurfaceCreateInfoKHR(m_state, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = vk->vkCreateAndroidSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_529;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_529, 1);
                vkStream->write((uint64_t*)&cgen_var_529, 8);
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateAndroidSurfaceKHR(&m_pool, vkCreateAndroidSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                VkInstance instance;
                const VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_530;
                vkReadStream->read((uint64_t*)&cgen_var_530, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_530, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                unmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_532;
                vkReadStream->read((uint64_t*)&cgen_var_532, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_532, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkWin32SurfaceCreateInfoKHR(m_state, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = vk->vkCreateWin32SurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_533;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_533, 1);
                vkStream->write((uint64_t*)&cgen_var_533, 8);
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateWin32SurfaceKHR(&m_pool, vkCreateWin32SurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_534;
                vkReadStream->read((uint64_t*)&cgen_var_534, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_534, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceWin32PresentationSupportKHR(&m_pool, vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex);
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFeatures2KHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_535;
                vkReadStream->read((uint64_t*)&cgen_var_535, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_535, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceProperties2KHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_536;
                vkReadStream->read((uint64_t*)&cgen_var_536, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_536, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceFormatProperties2KHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_537;
                vkReadStream->read((uint64_t*)&cgen_var_537, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_537, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format, pFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceImageFormatProperties2KHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_538;
                vkReadStream->read((uint64_t*)&cgen_var_538, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_538, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2KHR(&m_pool, vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_539;
                vkReadStream->read((uint64_t*)&cgen_var_539, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_539, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_542 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_542);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_543 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_543);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(&m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceMemoryProperties2KHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_544;
                vkReadStream->read((uint64_t*)&cgen_var_544, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_544, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice, pMemoryProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_545;
                vkReadStream->read((uint64_t*)&cgen_var_545, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_545, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_548 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_548);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_549 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_549);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(&m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_550;
                vkReadStream->read((uint64_t*)&cgen_var_550, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_550, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeaturesKHR(&m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_551;
                vkReadStream->read((uint64_t*)&cgen_var_551, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_551, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                vk->vkCmdSetDeviceMaskKHR(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetDeviceMaskKHR(&m_pool, commandBuffer, deviceMask);
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_552;
                vkReadStream->read((uint64_t*)&cgen_var_552, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_552, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                vk->vkCmdDispatchBaseKHR(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDispatchBaseKHR(&m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_553;
                vkReadStream->read((uint64_t*)&cgen_var_553, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_553, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_554;
                vkReadStream->read((uint64_t*)&cgen_var_554, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_554, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkTrimCommandPoolKHR(&m_pool, device, commandPool, flags);
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_555;
                vkReadStream->read((uint64_t*)&cgen_var_555, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_555, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = vk->vkEnumeratePhysicalDeviceGroupsKHR(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_558 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_558);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_559 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_559);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEnumeratePhysicalDeviceGroupsKHR(&m_pool, vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_560;
                vkReadStream->read((uint64_t*)&cgen_var_560, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_560, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalBufferProperties;
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(&m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                VkDevice device;
                const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_561;
                vkReadStream->read((uint64_t*)&cgen_var_561, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_561, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                unmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkMemoryGetWin32HandleInfoKHR(m_state, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = vk->vkGetMemoryWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryWin32HandleKHR(&m_pool, vkGetMemoryWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_562;
                vkReadStream->read((uint64_t*)&cgen_var_562, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_562, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((HANDLE*)&handle, sizeof(HANDLE));
                // Begin manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                unmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                if (pMemoryWin32HandleProperties)
                {
                    transform_tohost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vk->vkGetMemoryWin32HandlePropertiesKHR(unboxed_device, handleType, handle, pMemoryWin32HandleProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryWin32HandleProperties)
                {
                    transform_fromhost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryWin32HandlePropertiesKHR(&m_pool, vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, device, handleType, handle, pMemoryWin32HandleProperties);
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                VkDevice device;
                const VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_563;
                vkReadStream->read((uint64_t*)&cgen_var_563, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_563, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                unmarshal_VkMemoryGetFdInfoKHR(vkReadStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkMemoryGetFdInfoKHR(m_state, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = vk->vkGetMemoryFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryFdKHR(&m_pool, vkGetMemoryFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_564;
                vkReadStream->read((uint64_t*)&cgen_var_564, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_564, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((int*)&fd, sizeof(int));
                // Begin manual dispatchable handle unboxing for pMemoryFdProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                unmarshal_VkMemoryFdPropertiesKHR(vkReadStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryFdProperties;
                if (pMemoryFdProperties)
                {
                    transform_tohost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = vk->vkGetMemoryFdPropertiesKHR(unboxed_device, handleType, fd, pMemoryFdProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryFdProperties)
                {
                    transform_fromhost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryFdPropertiesKHR(&m_pool, vkGetMemoryFdPropertiesKHR_VkResult_return, device, handleType, fd, pMemoryFdProperties);
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR\n");;
                }
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_565;
                vkReadStream->read((uint64_t*)&cgen_var_565, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_565, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_566;
                vkReadStream->read((uint64_t*)&cgen_var_566, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_566, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                unmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                if (pImportSemaphoreWin32HandleInfo)
                {
                    transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(m_state, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = vk->vkImportSemaphoreWin32HandleKHR(unboxed_device, pImportSemaphoreWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkImportSemaphoreWin32HandleKHR(&m_pool, vkImportSemaphoreWin32HandleKHR_VkResult_return, device, pImportSemaphoreWin32HandleInfo);
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_567;
                vkReadStream->read((uint64_t*)&cgen_var_567, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_567, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                unmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(m_state, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = vk->vkGetSemaphoreWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSemaphoreWin32HandleKHR(&m_pool, vkGetSemaphoreWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkImportSemaphoreFdKHR\n");;
                }
                VkDevice device;
                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_568;
                vkReadStream->read((uint64_t*)&cgen_var_568, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_568, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                unmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                if (pImportSemaphoreFdInfo)
                {
                    transform_tohost_VkImportSemaphoreFdInfoKHR(m_state, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_state->on_vkImportSemaphoreFdKHR(&m_pool, device, pImportSemaphoreFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkImportSemaphoreFdKHR(&m_pool, vkImportSemaphoreFdKHR_VkResult_return, device, pImportSemaphoreFdInfo);
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSemaphoreFdKHR\n");;
                }
                VkDevice device;
                const VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_569;
                vkReadStream->read((uint64_t*)&cgen_var_569, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_569, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                unmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkSemaphoreGetFdInfoKHR(m_state, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_state->on_vkGetSemaphoreFdKHR(&m_pool, device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSemaphoreFdKHR(&m_pool, vkGetSemaphoreFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_570;
                vkReadStream->read((uint64_t*)&cgen_var_570, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_570, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_571;
                vkReadStream->read((uint64_t*)&cgen_var_571, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_571, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                vk->vkCmdPushDescriptorSetKHR(unboxed_commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdPushDescriptorSetKHR(&m_pool, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                const void* pData;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_572;
                vkReadStream->read((uint64_t*)&cgen_var_572, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_572, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_573;
                vkReadStream->read((uint64_t*)&cgen_var_573, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_573, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                uint64_t cgen_var_574;
                vkReadStream->read((uint64_t*)&cgen_var_574, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_574, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                vk->vkCmdPushDescriptorSetWithTemplateKHR(unboxed_commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdPushDescriptorSetWithTemplateKHR(&m_pool, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                break;
            }
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkCreateDescriptorUpdateTemplateKHR\n");;
                }
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_576;
                vkReadStream->read((uint64_t*)&cgen_var_576, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_576, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_578;
                vkReadStream->read((uint64_t*)&cgen_var_578, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_578, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplateKHR(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_579;
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_579, 1);
                vkStream->write((uint64_t*)&cgen_var_579, 8);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDescriptorUpdateTemplateKHR(&m_pool, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkDestroyDescriptorUpdateTemplateKHR\n");;
                }
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_580;
                vkReadStream->read((uint64_t*)&cgen_var_580, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_580, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_581;
                vkReadStream->read((uint64_t*)&cgen_var_581, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_581, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                m_state->on_vkDestroyDescriptorUpdateTemplateKHR(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDescriptorUpdateTemplateKHR(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_583;
                vkReadStream->read((uint64_t*)&cgen_var_583, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_583, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_584;
                vkReadStream->read((uint64_t*)&cgen_var_584, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_584, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_585;
                vkReadStream->read((uint64_t*)&cgen_var_585, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_585, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUpdateDescriptorSetWithTemplateKHR(&m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                VkDevice device;
                const VkRenderPassCreateInfo2KHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_587;
                vkReadStream->read((uint64_t*)&cgen_var_587, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_587, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
                unmarshal_VkRenderPassCreateInfo2KHR(vkReadStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_589;
                vkReadStream->read((uint64_t*)&cgen_var_589, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_589, (VkRenderPass*)pRenderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRenderPass;
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo2KHR(m_state, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = vk->vkCreateRenderPass2KHR(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_590;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_590, 1);
                vkStream->write((uint64_t*)&cgen_var_590, 8);
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateRenderPass2KHR(&m_pool, vkCreateRenderPass2KHR_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_591;
                vkReadStream->read((uint64_t*)&cgen_var_591, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_591, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                vk->vkCmdBeginRenderPass2KHR(unboxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBeginRenderPass2KHR(&m_pool, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_592;
                vkReadStream->read((uint64_t*)&cgen_var_592, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_592, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdNextSubpass2KHR(&m_pool, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_593;
                vkReadStream->read((uint64_t*)&cgen_var_593, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_593, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdEndRenderPass2KHR(&m_pool, commandBuffer, pSubpassEndInfo);
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_594;
                vkReadStream->read((uint64_t*)&cgen_var_594, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_594, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_595;
                vkReadStream->read((uint64_t*)&cgen_var_595, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_595, (VkSwapchainKHR*)&swapchain, 1);
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = vk->vkGetSwapchainStatusKHR(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSwapchainStatusKHR(&m_pool, vkGetSwapchainStatusKHR_VkResult_return, device, swapchain);
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_596;
                vkReadStream->read((uint64_t*)&cgen_var_596, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_596, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalFenceProperties;
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalFencePropertiesKHR(&m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_597;
                vkReadStream->read((uint64_t*)&cgen_var_597, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_597, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                unmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                if (pImportFenceWin32HandleInfo)
                {
                    transform_tohost_VkImportFenceWin32HandleInfoKHR(m_state, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = vk->vkImportFenceWin32HandleKHR(unboxed_device, pImportFenceWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkImportFenceWin32HandleKHR(&m_pool, vkImportFenceWin32HandleKHR_VkResult_return, device, pImportFenceWin32HandleInfo);
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_598;
                vkReadStream->read((uint64_t*)&cgen_var_598, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_598, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                unmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkFenceGetWin32HandleInfoKHR(m_state, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = vk->vkGetFenceWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetFenceWin32HandleKHR(&m_pool, vkGetFenceWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                VkDevice device;
                const VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_599;
                vkReadStream->read((uint64_t*)&cgen_var_599, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_599, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                unmarshal_VkImportFenceFdInfoKHR(vkReadStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                if (pImportFenceFdInfo)
                {
                    transform_tohost_VkImportFenceFdInfoKHR(m_state, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkImportFenceFdKHR(&m_pool, vkImportFenceFdKHR_VkResult_return, device, pImportFenceFdInfo);
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                VkDevice device;
                const VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_600;
                vkReadStream->read((uint64_t*)&cgen_var_600, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_600, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                unmarshal_VkFenceGetFdInfoKHR(vkReadStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkFenceGetFdInfoKHR(m_state, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetFenceFdKHR(&m_pool, vkGetFenceFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_601;
                vkReadStream->read((uint64_t*)&cgen_var_601, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_601, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                unmarshal_VkSurfaceCapabilities2KHR(vkReadStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2KHR(&m_pool, vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_602;
                vkReadStream->read((uint64_t*)&cgen_var_602, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_602, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormatCount;
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormat2KHR(vkReadStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormats;
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormats2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_605 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_605);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_606 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_606);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormats2KHR(&m_pool, vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_607;
                vkReadStream->read((uint64_t*)&cgen_var_607, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_607, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayProperties2KHR(vkReadStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_610 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_610);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_611 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_611);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceDisplayProperties2KHR(&m_pool, vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_612;
                vkReadStream->read((uint64_t*)&cgen_var_612, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_612, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_615 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_615);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_616 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_616);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(&m_pool, vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_617;
                vkReadStream->read((uint64_t*)&cgen_var_617, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_617, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_618;
                vkReadStream->read((uint64_t*)&cgen_var_618, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_618, (VkDisplayKHR*)&display, 1);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModeProperties2KHR(vkReadStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = vk->vkGetDisplayModeProperties2KHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_621 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_621);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_622 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_622);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDisplayModeProperties2KHR(&m_pool, vkGetDisplayModeProperties2KHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_623;
                vkReadStream->read((uint64_t*)&cgen_var_623, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_623, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                unmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                unmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCapabilities;
                if (pDisplayPlaneInfo)
                {
                    transform_tohost_VkDisplayPlaneInfo2KHR(m_state, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                }
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = vk->vkGetDisplayPlaneCapabilities2KHR(unboxed_physicalDevice, pDisplayPlaneInfo, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDisplayPlaneCapabilities2KHR(&m_pool, vkGetDisplayPlaneCapabilities2KHR_VkResult_return, physicalDevice, pDisplayPlaneInfo, pCapabilities);
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetImageMemoryRequirements2KHR\n");;
                }
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_624;
                vkReadStream->read((uint64_t*)&cgen_var_624, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_624, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                m_state->on_vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_625;
                vkReadStream->read((uint64_t*)&cgen_var_625, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_625, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                vk->vkGetBufferMemoryRequirements2KHR(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetBufferMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_626;
                vkReadStream->read((uint64_t*)&cgen_var_626, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_626, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_629 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_629);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_630 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_630);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetImageSparseMemoryRequirements2KHR(&m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_631;
                vkReadStream->read((uint64_t*)&cgen_var_631, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_631, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_633;
                vkReadStream->read((uint64_t*)&cgen_var_633, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_633, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pYcbcrConversion;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = vk->vkCreateSamplerYcbcrConversionKHR(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_634;
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_634, 1);
                vkStream->write((uint64_t*)&cgen_var_634, 8);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateSamplerYcbcrConversionKHR(&m_pool, vkCreateSamplerYcbcrConversionKHR_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_635;
                vkReadStream->read((uint64_t*)&cgen_var_635, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_635, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_636;
                vkReadStream->read((uint64_t*)&cgen_var_636, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_636, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for ycbcrConversion;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroySamplerYcbcrConversionKHR(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroySamplerYcbcrConversionKHR(&m_pool, device, ycbcrConversion, pAllocator);
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBindBufferMemory2KHR\n");;
                }
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_638;
                vkReadStream->read((uint64_t*)&cgen_var_638, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_638, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_state->on_vkBindBufferMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindBufferMemory2KHR(&m_pool, vkBindBufferMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_639;
                vkReadStream->read((uint64_t*)&cgen_var_639, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_639, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = vk->vkBindImageMemory2KHR(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBindImageMemory2KHR(&m_pool, vkBindImageMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                break;
            }
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_640;
                vkReadStream->read((uint64_t*)&cgen_var_640, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_640, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupport;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetDescriptorSetLayoutSupportKHR(&m_pool, device, pCreateInfo, pSupport);
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_641;
                vkReadStream->read((uint64_t*)&cgen_var_641, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_641, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_642;
                vkReadStream->read((uint64_t*)&cgen_var_642, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_642, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_643;
                vkReadStream->read((uint64_t*)&cgen_var_643, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_643, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndirectCountKHR(&m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_644;
                vkReadStream->read((uint64_t*)&cgen_var_644, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_644, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_645;
                vkReadStream->read((uint64_t*)&cgen_var_645, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_645, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_646;
                vkReadStream->read((uint64_t*)&cgen_var_646, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_646, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndexedIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndexedIndirectCountKHR(&m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                break;
            }
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_ANDROID_native_buffer
            case OP_vkGetSwapchainGrallocUsageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkGetSwapchainGrallocUsageANDROID\n");;
                }
                VkDevice device;
                VkFormat format;
                VkImageUsageFlags imageUsage;
                int* grallocUsage;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_647;
                vkReadStream->read((uint64_t*)&cgen_var_647, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_647, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageUsageFlags*)&imageUsage, sizeof(VkImageUsageFlags));
                // Begin manual dispatchable handle unboxing for grallocUsage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&grallocUsage, sizeof(int));
                vkReadStream->read((int*)grallocUsage, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for grallocUsage;
                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
                vkGetSwapchainGrallocUsageANDROID_VkResult_return = m_state->on_vkGetSwapchainGrallocUsageANDROID(&m_pool, device, format, imageUsage, grallocUsage);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)grallocUsage, sizeof(int));
                vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSwapchainGrallocUsageANDROID(&m_pool, vkGetSwapchainGrallocUsageANDROID_VkResult_return, device, format, imageUsage, grallocUsage);
                break;
            }
            case OP_vkAcquireImageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkAcquireImageANDROID\n");;
                }
                VkDevice device;
                VkImage image;
                int nativeFenceFd;
                VkSemaphore semaphore;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_648;
                vkReadStream->read((uint64_t*)&cgen_var_648, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_648, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_649;
                vkReadStream->read((uint64_t*)&cgen_var_649, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_649, (VkImage*)&image, 1);
                vkReadStream->read((int*)&nativeFenceFd, sizeof(int));
                uint64_t cgen_var_650;
                vkReadStream->read((uint64_t*)&cgen_var_650, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_650, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_651;
                vkReadStream->read((uint64_t*)&cgen_var_651, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_651, (VkFence*)&fence, 1);
                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(&m_pool, device, image, nativeFenceFd, semaphore, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAcquireImageANDROID(&m_pool, vkAcquireImageANDROID_VkResult_return, device, image, nativeFenceFd, semaphore, fence);
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROID:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkQueueSignalReleaseImageANDROID\n");;
                }
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                int* pNativeFenceFd;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_652;
                vkReadStream->read((uint64_t*)&cgen_var_652, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_652, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&waitSemaphoreCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pWaitSemaphores = (const VkSemaphore*)(uintptr_t)vkReadStream->getBe64();
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint64_t* cgen_var_654;
                        vkReadStream->alloc((void**)&cgen_var_654, ((waitSemaphoreCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_654, ((waitSemaphoreCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_654, (VkSemaphore*)pWaitSemaphores, ((waitSemaphoreCount)));
                    }
                }
                uint64_t cgen_var_655;
                vkReadStream->read((uint64_t*)&cgen_var_655, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_655, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pNativeFenceFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pNativeFenceFd, sizeof(int));
                vkReadStream->read((int*)pNativeFenceFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pNativeFenceFd;
                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
                vkQueueSignalReleaseImageANDROID_VkResult_return = m_state->on_vkQueueSignalReleaseImageANDROID(&m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pNativeFenceFd, sizeof(int));
                vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueSignalReleaseImageANDROID(&m_pool, vkQueueSignalReleaseImageANDROID_VkResult_return, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                break;
            }
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                VkInstance instance;
                const VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_656;
                vkReadStream->read((uint64_t*)&cgen_var_656, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_656, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                unmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pCallback;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                uint64_t cgen_var_658;
                vkReadStream->read((uint64_t*)&cgen_var_658, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_658, (VkDebugReportCallbackEXT*)pCallback, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCallback;
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugReportCallbackCreateInfoEXT(m_state, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = vk->vkCreateDebugReportCallbackEXT(unboxed_instance, pCreateInfo, pAllocator, pCallback);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pCallback;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_659;
                vkStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_659, 1);
                vkStream->write((uint64_t*)&cgen_var_659, 8);
                // Begin auto non dispatchable handle create for pCallback;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDebugReportCallbackEXT(&m_pool, vkCreateDebugReportCallbackEXT_VkResult_return, instance, pCreateInfo, pAllocator, pCallback);
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_660;
                vkReadStream->read((uint64_t*)&cgen_var_660, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_660, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for callback;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_661;
                vkReadStream->read((uint64_t*)&cgen_var_661, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_661, (VkDebugReportCallbackEXT*)&callback, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for callback;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDebugReportCallbackEXT(&m_pool, instance, callback, pAllocator);
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                const char* pLayerPrefix;
                const char* pMessage;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_663;
                vkReadStream->read((uint64_t*)&cgen_var_663, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_663, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->read((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
                vkReadStream->read((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
                vkReadStream->read((uint64_t*)&object, sizeof(uint64_t));
                location = (size_t)vkReadStream->getBe64();
                vkReadStream->read((int32_t*)&messageCode, sizeof(int32_t));
                vkReadStream->loadStringInPlace((char**)&pLayerPrefix);
                vkReadStream->loadStringInPlace((char**)&pMessage);
                vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDebugReportMessageEXT(&m_pool, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_665;
                vkReadStream->read((uint64_t*)&cgen_var_665, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_665, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                unmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                if (pTagInfo)
                {
                    transform_tohost_VkDebugMarkerObjectTagInfoEXT(m_state, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = vk->vkDebugMarkerSetObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDebugMarkerSetObjectTagEXT(&m_pool, vkDebugMarkerSetObjectTagEXT_VkResult_return, device, pTagInfo);
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_666;
                vkReadStream->read((uint64_t*)&cgen_var_666, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_666, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                unmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                if (pNameInfo)
                {
                    transform_tohost_VkDebugMarkerObjectNameInfoEXT(m_state, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = vk->vkDebugMarkerSetObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDebugMarkerSetObjectNameEXT(&m_pool, vkDebugMarkerSetObjectNameEXT_VkResult_return, device, pNameInfo);
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_667;
                vkReadStream->read((uint64_t*)&cgen_var_667, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_667, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                vk->vkCmdDebugMarkerBeginEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDebugMarkerBeginEXT(&m_pool, commandBuffer, pMarkerInfo);
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_668;
                vkReadStream->read((uint64_t*)&cgen_var_668, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_668, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vk->vkCmdDebugMarkerEndEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDebugMarkerEndEXT(&m_pool, commandBuffer);
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_669;
                vkReadStream->read((uint64_t*)&cgen_var_669, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_669, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                vk->vkCmdDebugMarkerInsertEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDebugMarkerInsertEXT(&m_pool, commandBuffer, pMarkerInfo);
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_670;
                vkReadStream->read((uint64_t*)&cgen_var_670, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_670, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_671;
                vkReadStream->read((uint64_t*)&cgen_var_671, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_671, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_672;
                vkReadStream->read((uint64_t*)&cgen_var_672, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_672, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndirectCountAMD(&m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_673;
                vkReadStream->read((uint64_t*)&cgen_var_673, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_673, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_674;
                vkReadStream->read((uint64_t*)&cgen_var_674, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_674, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_675;
                vkReadStream->read((uint64_t*)&cgen_var_675, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_675, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                vk->vkCmdDrawIndexedIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdDrawIndexedIndirectCountAMD(&m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_676;
                vkReadStream->read((uint64_t*)&cgen_var_676, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_676, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_677;
                vkReadStream->read((uint64_t*)&cgen_var_677, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_677, (VkPipeline*)&pipeline, 1);
                vkReadStream->read((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
                vkReadStream->read((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
                // Begin manual dispatchable handle unboxing for pInfoSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pInfoSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    (*pInfoSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInfoSize;
                // Begin manual dispatchable handle unboxing for pInfo;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pInfo = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInfo;
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = vk->vkGetShaderInfoAMD(unboxed_device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_681 = (uint64_t)(uintptr_t)pInfoSize;
                vkStream->putBe64(cgen_var_681);
                if (pInfoSize)
                {
                    uint64_t cgen_var_682 = (uint64_t)(*pInfoSize);
                    vkStream->putBe64(cgen_var_682);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_683 = (uint64_t)(uintptr_t)pInfo;
                vkStream->putBe64(cgen_var_683);
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetShaderInfoAMD(&m_pool, vkGetShaderInfoAMD_VkResult_return, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_684;
                vkReadStream->read((uint64_t*)&cgen_var_684, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_684, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                // Begin manual dispatchable handle unboxing for pExternalImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                unmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalImageFormatProperties;
                if (pExternalImageFormatProperties)
                {
                    transform_tohost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(unboxed_physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pExternalImageFormatProperties)
                {
                    transform_fromhost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&m_pool, vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_685;
                vkReadStream->read((uint64_t*)&cgen_var_685, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_685, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_686;
                vkReadStream->read((uint64_t*)&cgen_var_686, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_686, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = vk->vkGetMemoryWin32HandleNV(unboxed_device, memory, handleType, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryWin32HandleNV(&m_pool, vkGetMemoryWin32HandleNV_VkResult_return, device, memory, handleType, pHandle);
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                VkInstance instance;
                const VkViSurfaceCreateInfoNN* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_687;
                vkReadStream->read((uint64_t*)&cgen_var_687, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_687, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                unmarshal_VkViSurfaceCreateInfoNN(vkReadStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_689;
                vkReadStream->read((uint64_t*)&cgen_var_689, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_689, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkViSurfaceCreateInfoNN(m_state, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = vk->vkCreateViSurfaceNN(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_690;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_690, 1);
                vkStream->write((uint64_t*)&cgen_var_690, 8);
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateViSurfaceNN(&m_pool, vkCreateViSurfaceNN_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_691;
                vkReadStream->read((uint64_t*)&cgen_var_691, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_691, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                unmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                if (pConditionalRenderingBegin)
                {
                    transform_tohost_VkConditionalRenderingBeginInfoEXT(m_state, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                }
                vk->vkCmdBeginConditionalRenderingEXT(unboxed_commandBuffer, pConditionalRenderingBegin);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBeginConditionalRenderingEXT(&m_pool, commandBuffer, pConditionalRenderingBegin);
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_692;
                vkReadStream->read((uint64_t*)&cgen_var_692, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_692, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vk->vkCmdEndConditionalRenderingEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdEndConditionalRenderingEXT(&m_pool, commandBuffer);
                break;
            }
#endif
#ifdef VK_NVX_device_generated_commands
            case OP_vkCmdProcessCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_693;
                vkReadStream->read((uint64_t*)&cgen_var_693, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_693, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
                unmarshal_VkCmdProcessCommandsInfoNVX(vkReadStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                if (pProcessCommandsInfo)
                {
                    transform_tohost_VkCmdProcessCommandsInfoNVX(m_state, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                }
                vk->vkCmdProcessCommandsNVX(unboxed_commandBuffer, pProcessCommandsInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdProcessCommandsNVX(&m_pool, commandBuffer, pProcessCommandsInfo);
                break;
            }
            case OP_vkCmdReserveSpaceForCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_694;
                vkReadStream->read((uint64_t*)&cgen_var_694, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_694, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
                unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkReadStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                if (pReserveSpaceInfo)
                {
                    transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(m_state, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                }
                vk->vkCmdReserveSpaceForCommandsNVX(unboxed_commandBuffer, pReserveSpaceInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdReserveSpaceForCommandsNVX(&m_pool, commandBuffer, pReserveSpaceInfo);
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_695;
                vkReadStream->read((uint64_t*)&cgen_var_695, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_695, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
                unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkReadStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pIndirectCommandsLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                uint64_t cgen_var_697;
                vkReadStream->read((uint64_t*)&cgen_var_697, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_697, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pIndirectCommandsLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(m_state, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNVX_VkResult_return = vk->vkCreateIndirectCommandsLayoutNVX(unboxed_device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_698;
                vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_698, 1);
                vkStream->write((uint64_t*)&cgen_var_698, 8);
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateIndirectCommandsLayoutNVX(&m_pool, vkCreateIndirectCommandsLayoutNVX_VkResult_return, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                VkIndirectCommandsLayoutNVX indirectCommandsLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_699;
                vkReadStream->read((uint64_t*)&cgen_var_699, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_699, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_700;
                vkReadStream->read((uint64_t*)&cgen_var_700, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_700, (VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyIndirectCommandsLayoutNVX(unboxed_device, indirectCommandsLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyIndirectCommandsLayoutNVX(&m_pool, device, indirectCommandsLayout, pAllocator);
                break;
            }
            case OP_vkCreateObjectTableNVX:
            {
                VkDevice device;
                const VkObjectTableCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkObjectTableNVX* pObjectTable;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_702;
                vkReadStream->read((uint64_t*)&cgen_var_702, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_702, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
                unmarshal_VkObjectTableCreateInfoNVX(vkReadStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pObjectTable;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pObjectTable, sizeof(VkObjectTableNVX));
                uint64_t cgen_var_704;
                vkReadStream->read((uint64_t*)&cgen_var_704, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_704, (VkObjectTableNVX*)pObjectTable, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pObjectTable;
                if (pCreateInfo)
                {
                    transform_tohost_VkObjectTableCreateInfoNVX(m_state, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
                vkCreateObjectTableNVX_VkResult_return = vk->vkCreateObjectTableNVX(unboxed_device, pCreateInfo, pAllocator, pObjectTable);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pObjectTable;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_705;
                vkStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_705, 1);
                vkStream->write((uint64_t*)&cgen_var_705, 8);
                // Begin auto non dispatchable handle create for pObjectTable;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateObjectTableNVX(&m_pool, vkCreateObjectTableNVX_VkResult_return, device, pCreateInfo, pAllocator, pObjectTable);
                break;
            }
            case OP_vkDestroyObjectTableNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_706;
                vkReadStream->read((uint64_t*)&cgen_var_706, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_706, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for objectTable;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_707;
                vkReadStream->read((uint64_t*)&cgen_var_707, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_707, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for objectTable;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyObjectTableNVX(unboxed_device, objectTable, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyObjectTableNVX(&m_pool, device, objectTable, pAllocator);
                break;
            }
            case OP_vkRegisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectTableEntryNVX* const* ppObjectTableEntries;
                const uint32_t* pObjectIndices;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_709;
                vkReadStream->read((uint64_t*)&cgen_var_709, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_709, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_710;
                vkReadStream->read((uint64_t*)&cgen_var_710, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_710, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                (void)ppObjectTableEntries;
                VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
                vkRegisterObjectsNVX_VkResult_return = vk->vkRegisterObjectsNVX(unboxed_device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkRegisterObjectsNVX(&m_pool, vkRegisterObjectsNVX_VkResult_return, device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                break;
            }
            case OP_vkUnregisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectEntryTypeNVX* pObjectEntryTypes;
                const uint32_t* pObjectIndices;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_711;
                vkReadStream->read((uint64_t*)&cgen_var_711, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_711, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_712;
                vkReadStream->read((uint64_t*)&cgen_var_712, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_712, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->read((VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
                vkUnregisterObjectsNVX_VkResult_return = vk->vkUnregisterObjectsNVX(unboxed_device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUnregisterObjectsNVX(&m_pool, vkUnregisterObjectsNVX_VkResult_return, device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                break;
            }
            case OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX:
            {
                VkPhysicalDevice physicalDevice;
                VkDeviceGeneratedCommandsFeaturesNVX* pFeatures;
                VkDeviceGeneratedCommandsLimitsNVX* pLimits;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_713;
                vkReadStream->read((uint64_t*)&cgen_var_713, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_713, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
                unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkReadStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                // Begin manual dispatchable handle unboxing for pLimits;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLimits, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
                unmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkReadStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pLimits;
                if (pFeatures)
                {
                    transform_tohost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                if (pLimits)
                {
                    transform_tohost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                vk->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(unboxed_physicalDevice, pFeatures, pLimits);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                if (pLimits)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(&m_pool, physicalDevice, pFeatures, pLimits);
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewportWScalingNV* pViewportWScalings;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_714;
                vkReadStream->read((uint64_t*)&cgen_var_714, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_714, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewportWScalingNV(vkReadStream, (VkViewportWScalingNV*)(pViewportWScalings + i));
                }
                if (pViewportWScalings)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewportWScalingNV(m_state, (VkViewportWScalingNV*)(pViewportWScalings + i));
                    }
                }
                vk->vkCmdSetViewportWScalingNV(unboxed_commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetViewportWScalingNV(&m_pool, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_715;
                vkReadStream->read((uint64_t*)&cgen_var_715, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_715, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_716;
                vkReadStream->read((uint64_t*)&cgen_var_716, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_716, (VkDisplayKHR*)&display, 1);
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = vk->vkReleaseDisplayEXT(unboxed_physicalDevice, display);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkReleaseDisplayEXT(&m_pool, vkReleaseDisplayEXT_VkResult_return, physicalDevice, display);
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_717;
                vkReadStream->read((uint64_t*)&cgen_var_717, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_717, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                uint64_t cgen_var_718;
                vkReadStream->read((uint64_t*)&cgen_var_718, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_718, (VkDisplayKHR*)&display, 1);
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = vk->vkAcquireXlibDisplayEXT(unboxed_physicalDevice, dpy, display);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkAcquireXlibDisplayEXT(&m_pool, vkAcquireXlibDisplayEXT_VkResult_return, physicalDevice, dpy, display);
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_719;
                vkReadStream->read((uint64_t*)&cgen_var_719, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_719, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                vkReadStream->read((RROutput*)&rrOutput, sizeof(RROutput));
                // Begin manual dispatchable handle unboxing for pDisplay;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                uint64_t cgen_var_720;
                vkReadStream->read((uint64_t*)&cgen_var_720, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_720, (VkDisplayKHR*)pDisplay, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplay;
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = vk->vkGetRandROutputDisplayEXT(unboxed_physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_721;
                vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_721, 1);
                vkStream->write((uint64_t*)&cgen_var_721, 8);
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetRandROutputDisplayEXT(&m_pool, vkGetRandROutputDisplayEXT_VkResult_return, physicalDevice, dpy, rrOutput, pDisplay);
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_722;
                vkReadStream->read((uint64_t*)&cgen_var_722, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_722, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_723;
                vkReadStream->read((uint64_t*)&cgen_var_723, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_723, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                unmarshal_VkSurfaceCapabilities2EXT(vkReadStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2EXT(&m_pool, vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_724;
                vkReadStream->read((uint64_t*)&cgen_var_724, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_724, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_725;
                vkReadStream->read((uint64_t*)&cgen_var_725, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_725, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                unmarshal_VkDisplayPowerInfoEXT(vkReadStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                if (pDisplayPowerInfo)
                {
                    transform_tohost_VkDisplayPowerInfoEXT(m_state, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = vk->vkDisplayPowerControlEXT(unboxed_device, display, pDisplayPowerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDisplayPowerControlEXT(&m_pool, vkDisplayPowerControlEXT_VkResult_return, device, display, pDisplayPowerInfo);
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                VkDevice device;
                const VkDeviceEventInfoEXT* pDeviceEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_726;
                vkReadStream->read((uint64_t*)&cgen_var_726, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_726, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                unmarshal_VkDeviceEventInfoEXT(vkReadStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_728;
                vkReadStream->read((uint64_t*)&cgen_var_728, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_728, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pDeviceEventInfo)
                {
                    transform_tohost_VkDeviceEventInfoEXT(m_state, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = vk->vkRegisterDeviceEventEXT(unboxed_device, pDeviceEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_729;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_729, 1);
                vkStream->write((uint64_t*)&cgen_var_729, 8);
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkRegisterDeviceEventEXT(&m_pool, vkRegisterDeviceEventEXT_VkResult_return, device, pDeviceEventInfo, pAllocator, pFence);
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayEventInfoEXT* pDisplayEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_730;
                vkReadStream->read((uint64_t*)&cgen_var_730, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_730, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_731;
                vkReadStream->read((uint64_t*)&cgen_var_731, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_731, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                unmarshal_VkDisplayEventInfoEXT(vkReadStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_733;
                vkReadStream->read((uint64_t*)&cgen_var_733, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_733, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pDisplayEventInfo)
                {
                    transform_tohost_VkDisplayEventInfoEXT(m_state, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = vk->vkRegisterDisplayEventEXT(unboxed_device, display, pDisplayEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_734;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_734, 1);
                vkStream->write((uint64_t*)&cgen_var_734, 8);
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkRegisterDisplayEventEXT(&m_pool, vkRegisterDisplayEventEXT_VkResult_return, device, display, pDisplayEventInfo, pAllocator, pFence);
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_735;
                vkReadStream->read((uint64_t*)&cgen_var_735, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_735, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_736;
                vkReadStream->read((uint64_t*)&cgen_var_736, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_736, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
                // Begin manual dispatchable handle unboxing for pCounterValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                vkReadStream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCounterValue;
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = vk->vkGetSwapchainCounterEXT(unboxed_device, swapchain, counter, pCounterValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetSwapchainCounterEXT(&m_pool, vkGetSwapchainCounterEXT_VkResult_return, device, swapchain, counter, pCounterValue);
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_737;
                vkReadStream->read((uint64_t*)&cgen_var_737, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_737, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_738;
                vkReadStream->read((uint64_t*)&cgen_var_738, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_738, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pDisplayTimingProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                unmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplayTimingProperties;
                if (pDisplayTimingProperties)
                {
                    transform_tohost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = vk->vkGetRefreshCycleDurationGOOGLE(unboxed_device, swapchain, pDisplayTimingProperties);
                vkStream->unsetHandleMapping();
                if (pDisplayTimingProperties)
                {
                    transform_fromhost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetRefreshCycleDurationGOOGLE(&m_pool, vkGetRefreshCycleDurationGOOGLE_VkResult_return, device, swapchain, pDisplayTimingProperties);
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_739;
                vkReadStream->read((uint64_t*)&cgen_var_739, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_739, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_740;
                vkReadStream->read((uint64_t*)&cgen_var_740, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_740, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pPresentationTimingCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentationTimingCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentationTimingCount;
                // Begin manual dispatchable handle unboxing for pPresentationTimings;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        unmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentationTimings;
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_tohost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = vk->vkGetPastPresentationTimingGOOGLE(unboxed_device, swapchain, pPresentationTimingCount, pPresentationTimings);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_743 = (uint64_t)(uintptr_t)pPresentationTimingCount;
                vkStream->putBe64(cgen_var_743);
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_fromhost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_744 = (uint64_t)(uintptr_t)pPresentationTimings;
                vkStream->putBe64(cgen_var_744);
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPastPresentationTimingGOOGLE(&m_pool, vkGetPastPresentationTimingGOOGLE_VkResult_return, device, swapchain, pPresentationTimingCount, pPresentationTimings);
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                const VkRect2D* pDiscardRectangles;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_745;
                vkReadStream->read((uint64_t*)&cgen_var_745, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_745, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pDiscardRectangles + i));
                }
                if (pDiscardRectangles)
                {
                    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pDiscardRectangles + i));
                    }
                }
                vk->vkCmdSetDiscardRectangleEXT(unboxed_commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetDiscardRectangleEXT(&m_pool, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainKHR* pSwapchains;
                const VkHdrMetadataEXT* pMetadata;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_746;
                vkReadStream->read((uint64_t*)&cgen_var_746, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_746, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_747;
                    vkReadStream->alloc((void**)&cgen_var_747, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_747, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_747, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkHdrMetadataEXT(vkReadStream, (VkHdrMetadataEXT*)(pMetadata + i));
                }
                if (pMetadata)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkHdrMetadataEXT(m_state, (VkHdrMetadataEXT*)(pMetadata + i));
                    }
                }
                vk->vkSetHdrMetadataEXT(unboxed_device, swapchainCount, pSwapchains, pMetadata);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkSetHdrMetadataEXT(&m_pool, device, swapchainCount, pSwapchains, pMetadata);
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                VkInstance instance;
                const VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_748;
                vkReadStream->read((uint64_t*)&cgen_var_748, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_748, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                unmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_750;
                vkReadStream->read((uint64_t*)&cgen_var_750, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_750, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkIOSSurfaceCreateInfoMVK(m_state, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = vk->vkCreateIOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_751;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_751, 1);
                vkStream->write((uint64_t*)&cgen_var_751, 8);
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateIOSSurfaceMVK(&m_pool, vkCreateIOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                VkInstance instance;
                const VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_752;
                vkReadStream->read((uint64_t*)&cgen_var_752, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_752, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                unmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_754;
                vkReadStream->read((uint64_t*)&cgen_var_754, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_754, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkMacOSSurfaceCreateInfoMVK(m_state, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = vk->vkCreateMacOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_755;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_755, 1);
                vkStream->write((uint64_t*)&cgen_var_755, 8);
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateMacOSSurfaceMVK(&m_pool, vkCreateMacOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_756;
                vkReadStream->read((uint64_t*)&cgen_var_756, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_756, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                unmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                if (pNameInfo)
                {
                    transform_tohost_VkDebugUtilsObjectNameInfoEXT(m_state, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkSetDebugUtilsObjectNameEXT(&m_pool, vkSetDebugUtilsObjectNameEXT_VkResult_return, device, pNameInfo);
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_757;
                vkReadStream->read((uint64_t*)&cgen_var_757, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_757, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                unmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                if (pTagInfo)
                {
                    transform_tohost_VkDebugUtilsObjectTagInfoEXT(m_state, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkSetDebugUtilsObjectTagEXT(&m_pool, vkSetDebugUtilsObjectTagEXT_VkResult_return, device, pTagInfo);
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_758;
                vkReadStream->read((uint64_t*)&cgen_var_758, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_758, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueBeginDebugUtilsLabelEXT(&m_pool, queue, pLabelInfo);
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                VkQueue queue;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_759;
                vkReadStream->read((uint64_t*)&cgen_var_759, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_759, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(&m_pool, queue);
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_760;
                vkReadStream->read((uint64_t*)&cgen_var_760, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_760, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkQueueInsertDebugUtilsLabelEXT(&m_pool, queue, pLabelInfo);
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_761;
                vkReadStream->read((uint64_t*)&cgen_var_761, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_761, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdBeginDebugUtilsLabelEXT(&m_pool, commandBuffer, pLabelInfo);
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_762;
                vkReadStream->read((uint64_t*)&cgen_var_762, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_762, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdEndDebugUtilsLabelEXT(&m_pool, commandBuffer);
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_763;
                vkReadStream->read((uint64_t*)&cgen_var_763, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_763, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdInsertDebugUtilsLabelEXT(&m_pool, commandBuffer, pLabelInfo);
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_764;
                vkReadStream->read((uint64_t*)&cgen_var_764, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_764, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMessenger;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                uint64_t cgen_var_766;
                vkReadStream->read((uint64_t*)&cgen_var_766, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_766, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMessenger;
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(m_state, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = vk->vkCreateDebugUtilsMessengerEXT(unboxed_instance, pCreateInfo, pAllocator, pMessenger);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMessenger;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_767;
                vkStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_767, 1);
                vkStream->write((uint64_t*)&cgen_var_767, 8);
                // Begin auto non dispatchable handle create for pMessenger;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateDebugUtilsMessengerEXT(&m_pool, vkCreateDebugUtilsMessengerEXT_VkResult_return, instance, pCreateInfo, pAllocator, pMessenger);
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_768;
                vkReadStream->read((uint64_t*)&cgen_var_768, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_768, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for messenger;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_769;
                vkReadStream->read((uint64_t*)&cgen_var_769, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_769, (VkDebugUtilsMessengerEXT*)&messenger, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for messenger;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyDebugUtilsMessengerEXT(&m_pool, instance, messenger, pAllocator);
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_771;
                vkReadStream->read((uint64_t*)&cgen_var_771, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_771, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->read((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                vkReadStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                unmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                if (pCallbackData)
                {
                    transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(m_state, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                }
                vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity, messageTypes, pCallbackData);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkSubmitDebugUtilsMessageEXT(&m_pool, instance, messageSeverity, messageTypes, pCallbackData);
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                VkDevice device;
                const AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_772;
                vkReadStream->read((uint64_t*)&cgen_var_772, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_772, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                vkReadStream->read((AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                unmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = vk->vkGetAndroidHardwareBufferPropertiesANDROID(unboxed_device, buffer, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetAndroidHardwareBufferPropertiesANDROID(&m_pool, vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, device, buffer, pProperties);
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                VkDevice device;
                const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_773;
                vkReadStream->read((uint64_t*)&cgen_var_773, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_773, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pBuffer;
                if (pInfo)
                {
                    transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(m_state, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = vk->vkGetMemoryAndroidHardwareBufferANDROID(unboxed_device, pInfo, pBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryAndroidHardwareBufferANDROID(&m_pool, vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, device, pInfo, pBuffer);
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_774;
                vkReadStream->read((uint64_t*)&cgen_var_774, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_774, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                unmarshal_VkSampleLocationsInfoEXT(vkReadStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                if (pSampleLocationsInfo)
                {
                    transform_tohost_VkSampleLocationsInfoEXT(m_state, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                }
                vk->vkCmdSetSampleLocationsEXT(unboxed_commandBuffer, pSampleLocationsInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetSampleLocationsEXT(&m_pool, commandBuffer, pSampleLocationsInfo);
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_775;
                vkReadStream->read((uint64_t*)&cgen_var_775, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_775, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                // Begin manual dispatchable handle unboxing for pMultisampleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                unmarshal_VkMultisamplePropertiesEXT(vkReadStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMultisampleProperties;
                if (pMultisampleProperties)
                {
                    transform_tohost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(unboxed_physicalDevice, samples, pMultisampleProperties);
                vkStream->unsetHandleMapping();
                if (pMultisampleProperties)
                {
                    transform_fromhost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetPhysicalDeviceMultisamplePropertiesEXT(&m_pool, physicalDevice, samples, pMultisampleProperties);
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                VkDevice device;
                const VkValidationCacheCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_776;
                vkReadStream->read((uint64_t*)&cgen_var_776, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_776, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                unmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pValidationCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                uint64_t cgen_var_778;
                vkReadStream->read((uint64_t*)&cgen_var_778, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_778, (VkValidationCacheEXT*)pValidationCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pValidationCache;
                if (pCreateInfo)
                {
                    transform_tohost_VkValidationCacheCreateInfoEXT(m_state, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = vk->vkCreateValidationCacheEXT(unboxed_device, pCreateInfo, pAllocator, pValidationCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pValidationCache;
                vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_779;
                vkStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_779, 1);
                vkStream->write((uint64_t*)&cgen_var_779, 8);
                // Begin auto non dispatchable handle create for pValidationCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCreateValidationCacheEXT(&m_pool, vkCreateValidationCacheEXT_VkResult_return, device, pCreateInfo, pAllocator, pValidationCache);
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_780;
                vkReadStream->read((uint64_t*)&cgen_var_780, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_780, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for validationCache;
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeleteMapping);
                uint64_t cgen_var_781;
                vkReadStream->read((uint64_t*)&cgen_var_781, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_781, (VkValidationCacheEXT*)&validationCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for validationCache;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                vk->vkDestroyValidationCacheEXT(unboxed_device, validationCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkDestroyValidationCacheEXT(&m_pool, device, validationCache, pAllocator);
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                const VkValidationCacheEXT* pSrcCaches;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_783;
                vkReadStream->read((uint64_t*)&cgen_var_783, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_783, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_784;
                vkReadStream->read((uint64_t*)&cgen_var_784, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_784, (VkValidationCacheEXT*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_785;
                    vkReadStream->alloc((void**)&cgen_var_785, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_785, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(cgen_var_785, (VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)));
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = vk->vkMergeValidationCachesEXT(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkMergeValidationCachesEXT(&m_pool, vkMergeValidationCachesEXT_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_786;
                vkReadStream->read((uint64_t*)&cgen_var_786, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_786, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_787;
                vkReadStream->read((uint64_t*)&cgen_var_787, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_787, (VkValidationCacheEXT*)&validationCache, 1);
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDataSize;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = vk->vkGetValidationCacheDataEXT(unboxed_device, validationCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_791 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_791);
                if (pDataSize)
                {
                    uint64_t cgen_var_792 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_792);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_793 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_793);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetValidationCacheDataEXT(&m_pool, vkGetValidationCacheDataEXT_VkResult_return, device, validationCache, pDataSize, pData);
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                const void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_794;
                vkReadStream->read((uint64_t*)&cgen_var_794, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_794, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                // WARNING PTR CHECK
                pHostPointer = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    vkReadStream->read((void*)pHostPointer, sizeof(const uint8_t));
                }
                // Begin manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                unmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                if (pMemoryHostPointerProperties)
                {
                    transform_tohost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vk->vkGetMemoryHostPointerPropertiesEXT(unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryHostPointerProperties)
                {
                    transform_fromhost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetMemoryHostPointerPropertiesEXT(&m_pool, vkGetMemoryHostPointerPropertiesEXT_VkResult_return, device, handleType, pHostPointer, pMemoryHostPointerProperties);
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_796;
                vkReadStream->read((uint64_t*)&cgen_var_796, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_796, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_797;
                vkReadStream->read((uint64_t*)&cgen_var_797, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_797, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&marker, sizeof(uint32_t));
                vk->vkCmdWriteBufferMarkerAMD(unboxed_commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdWriteBufferMarkerAMD(&m_pool, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                VkCommandBuffer commandBuffer;
                const void* pCheckpointMarker;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_798;
                vkReadStream->read((uint64_t*)&cgen_var_798, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_798, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                // WARNING PTR CHECK
                pCheckpointMarker = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    vkReadStream->read((void*)pCheckpointMarker, sizeof(const uint8_t));
                }
                vk->vkCmdSetCheckpointNV(unboxed_commandBuffer, pCheckpointMarker);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkCmdSetCheckpointNV(&m_pool, commandBuffer, pCheckpointMarker);
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_800;
                vkReadStream->read((uint64_t*)&cgen_var_800, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_800, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                // Begin manual dispatchable handle unboxing for pCheckpointDataCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pCheckpointDataCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCheckpointDataCount;
                // Begin manual dispatchable handle unboxing for pCheckpointData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        unmarshal_VkCheckpointDataNV(vkReadStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCheckpointData;
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_tohost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vk->vkGetQueueCheckpointDataNV(unboxed_queue, pCheckpointDataCount, pCheckpointData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_803 = (uint64_t)(uintptr_t)pCheckpointDataCount;
                vkStream->putBe64(cgen_var_803);
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_fromhost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_804 = (uint64_t)(uintptr_t)pCheckpointData;
                vkStream->putBe64(cgen_var_804);
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkGetQueueCheckpointDataNV(&m_pool, queue, pCheckpointDataCount, pCheckpointData);
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space
            case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkMapMemoryIntoAddressSpaceGOOGLE\n");;
                }
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_805;
                vkReadStream->read((uint64_t*)&cgen_var_805, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_805, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_806;
                vkReadStream->read((uint64_t*)&cgen_var_806, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_806, (VkDeviceMemory*)&memory, 1);
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pAddress = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pAddress;
                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, device, memory, pAddress);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_808 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_808);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
                break;
            }
#endif
#ifdef VK_GOOGLE_color_buffer
            case OP_vkRegisterImageColorBufferGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterImageColorBufferGOOGLE\n");;
                }
                VkDevice device;
                VkImage image;
                uint32_t colorBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_809;
                vkReadStream->read((uint64_t*)&cgen_var_809, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_809, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_810;
                vkReadStream->read((uint64_t*)&cgen_var_810, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_810, (VkImage*)&image, 1);
                vkReadStream->read((uint32_t*)&colorBuffer, sizeof(uint32_t));
                VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterImageColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterImageColorBufferGOOGLE(&m_pool, device, image, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkRegisterImageColorBufferGOOGLE(&m_pool, vkRegisterImageColorBufferGOOGLE_VkResult_return, device, image, colorBuffer);
                break;
            }
            case OP_vkRegisterBufferColorBufferGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkRegisterBufferColorBufferGOOGLE\n");;
                }
                VkDevice device;
                VkBuffer buffer;
                uint32_t colorBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_811;
                vkReadStream->read((uint64_t*)&cgen_var_811, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_811, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_812;
                vkReadStream->read((uint64_t*)&cgen_var_812, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_812, (VkBuffer*)&buffer, 1);
                vkReadStream->read((uint32_t*)&colorBuffer, sizeof(uint32_t));
                VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterBufferColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterBufferColorBufferGOOGLE(&m_pool, device, buffer, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkRegisterBufferColorBufferGOOGLE(&m_pool, vkRegisterBufferColorBufferGOOGLE_VkResult_return, device, buffer, colorBuffer);
                break;
            }
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
            case OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkUpdateDescriptorSetWithTemplateSizedGOOGLE\n");;
                }
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                uint32_t imageInfoCount;
                uint32_t bufferInfoCount;
                uint32_t bufferViewCount;
                const uint32_t* pImageInfoEntryIndices;
                const uint32_t* pBufferInfoEntryIndices;
                const uint32_t* pBufferViewEntryIndices;
                const VkDescriptorImageInfo* pImageInfos;
                const VkDescriptorBufferInfo* pBufferInfos;
                const VkBufferView* pBufferViews;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_813;
                vkReadStream->read((uint64_t*)&cgen_var_813, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_813, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_814;
                vkReadStream->read((uint64_t*)&cgen_var_814, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_814, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_815;
                vkReadStream->read((uint64_t*)&cgen_var_815, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_815, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->read((uint32_t*)&imageInfoCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bufferInfoCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bufferViewCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pImageInfoEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pImageInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pBufferInfoEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pBufferViewEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferViewEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pImageInfos = (const VkDescriptorImageInfo*)(uintptr_t)vkReadStream->getBe64();
                if (pImageInfos)
                {
                    vkReadStream->alloc((void**)&pImageInfos, ((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        unmarshal_VkDescriptorImageInfo(vkReadStream, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                // WARNING PTR CHECK
                pBufferInfos = (const VkDescriptorBufferInfo*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferInfos)
                {
                    vkReadStream->alloc((void**)&pBufferInfos, ((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        unmarshal_VkDescriptorBufferInfo(vkReadStream, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                // WARNING PTR CHECK
                pBufferViews = (const VkBufferView*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferViews)
                {
                    vkReadStream->alloc((void**)&pBufferViews, ((bufferViewCount)) * sizeof(const VkBufferView));
                    if (((bufferViewCount)))
                    {
                        uint64_t* cgen_var_822;
                        vkReadStream->alloc((void**)&cgen_var_822, ((bufferViewCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_822, ((bufferViewCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(cgen_var_822, (VkBufferView*)pBufferViews, ((bufferViewCount)));
                    }
                }
                if (pImageInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorImageInfo(m_state, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                if (pBufferInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorBufferInfo(m_state, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(&m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(&m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                break;
            }
#endif
#ifdef VK_GOOGLE_async_command_buffers
            case OP_vkBeginCommandBufferAsyncGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkBeginCommandBufferAsyncGOOGLE\n");;
                }
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_823;
                vkReadStream->read((uint64_t*)&cgen_var_823, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_823, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo);
                break;
            }
            case OP_vkEndCommandBufferAsyncGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkEndCommandBufferAsyncGOOGLE\n");;
                }
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_824;
                vkReadStream->read((uint64_t*)&cgen_var_824, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_824, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer);
                break;
            }
            case OP_vkResetCommandBufferAsyncGOOGLE:
            {
                if (m_logCalls)
                {
                    fprintf(stderr, "call vkResetCommandBufferAsyncGOOGLE\n");;
                }
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_825;
                vkReadStream->read((uint64_t*)&cgen_var_825, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_825, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkReadStream->clearPool();
                m_pool.freeAll();
                vkStream->commitWrite();
                m_state->snapshot()->vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
                break;
            }
#endif
            default:
            {
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    return ptr - (unsigned char*)buf;;
}


