/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_BLOCK_GENERATED_TRACERS_H
#define TRACE_BLOCK_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_BDRV_OPEN_COMMON_EVENT;
extern TraceEvent _TRACE_BDRV_LOCK_MEDIUM_EVENT;
extern TraceEvent _TRACE_BLOCK_JOB_COMPLETED_EVENT;
extern TraceEvent _TRACE_BLOCK_JOB_STATE_TRANSITION_EVENT;
extern TraceEvent _TRACE_BLOCK_JOB_APPLY_VERB_EVENT;
extern TraceEvent _TRACE_BLK_CO_PREADV_EVENT;
extern TraceEvent _TRACE_BLK_CO_PWRITEV_EVENT;
extern TraceEvent _TRACE_BLK_ROOT_ATTACH_EVENT;
extern TraceEvent _TRACE_BLK_ROOT_DETACH_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PREADV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITEV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_BDRV_CO_DO_COPY_ON_READV_EVENT;
extern TraceEvent _TRACE_STREAM_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_STREAM_START_EVENT;
extern TraceEvent _TRACE_COMMIT_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_COMMIT_START_EVENT;
extern TraceEvent _TRACE_MIRROR_START_EVENT;
extern TraceEvent _TRACE_MIRROR_RESTART_ITER_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_FLUSH_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_DRAIN_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_SLEEP_EVENT;
extern TraceEvent _TRACE_MIRROR_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_MIRROR_ITERATION_DONE_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_IN_FLIGHT_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_ENTER_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_RETURN_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_SKIP_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_PROCESS_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_READ_FAIL_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_CANCEL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_PAUSE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_RESUME_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_COMPLETE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_FINALIZE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_DISMISS_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_STREAM_EVENT;
extern TraceEvent _TRACE_PAIO_SUBMIT_CO_EVENT;
extern TraceEvent _TRACE_PAIO_SUBMIT_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DATA_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_COPIED_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_ALLOC_EVENT;
extern TraceEvent _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_LINK_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_READ_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_FLUSH_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_ENTRY_FLUSH_EVENT;
extern TraceEvent _TRACE_QED_ALLOC_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_UNREF_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_FIND_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_NEED_CHECK_TIMER_CB_EVENT;
extern TraceEvent _TRACE_QED_START_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_CANCEL_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_AIO_COMPLETE_EVENT;
extern TraceEvent _TRACE_QED_AIO_SETUP_EVENT;
extern TraceEvent _TRACE_QED_AIO_NEXT_IO_EVENT;
extern TraceEvent _TRACE_QED_AIO_READ_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_PREFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_POSTFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_MAIN_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_CHNFAIL_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_UNKNWN_EVENT;
extern TraceEvent _TRACE_VXHS_AIO_RW_INVALID_EVENT;
extern TraceEvent _TRACE_VXHS_AIO_RW_IOERR_EVENT;
extern TraceEvent _TRACE_VXHS_GET_VDISK_STAT_ERR_EVENT;
extern TraceEvent _TRACE_VXHS_GET_VDISK_STAT_EVENT;
extern TraceEvent _TRACE_VXHS_COMPLETE_AIO_EVENT;
extern TraceEvent _TRACE_VXHS_PARSE_URI_FILENAME_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_VDISKID_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_HOSTINFO_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_IIO_OPEN_EVENT;
extern TraceEvent _TRACE_VXHS_PARSE_URI_HOSTINFO_EVENT;
extern TraceEvent _TRACE_VXHS_CLOSE_EVENT;
extern TraceEvent _TRACE_VXHS_GET_CREDS_EVENT;
extern TraceEvent _TRACE_NVME_KICK_EVENT;
extern TraceEvent _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_ERROR_EVENT;
extern TraceEvent _TRACE_NVME_PROCESS_COMPLETION_EVENT;
extern TraceEvent _TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_EVENT;
extern TraceEvent _TRACE_NVME_COMPLETE_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_RAW_EVENT;
extern TraceEvent _TRACE_NVME_HANDLE_EVENT_EVENT;
extern TraceEvent _TRACE_NVME_POLL_CB_EVENT;
extern TraceEvent _TRACE_NVME_PRW_ALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_QIOV_UNALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_PRW_BUFFERED_EVENT;
extern TraceEvent _TRACE_NVME_RW_DONE_EVENT;
extern TraceEvent _TRACE_NVME_DMA_MAP_FLUSH_EVENT;
extern TraceEvent _TRACE_NVME_FREE_REQ_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_PAGES_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_IOV_EVENT;
extern uint16_t _TRACE_BDRV_OPEN_COMMON_DSTATE;
extern uint16_t _TRACE_BDRV_LOCK_MEDIUM_DSTATE;
extern uint16_t _TRACE_BLOCK_JOB_COMPLETED_DSTATE;
extern uint16_t _TRACE_BLOCK_JOB_STATE_TRANSITION_DSTATE;
extern uint16_t _TRACE_BLOCK_JOB_APPLY_VERB_DSTATE;
extern uint16_t _TRACE_BLK_CO_PREADV_DSTATE;
extern uint16_t _TRACE_BLK_CO_PWRITEV_DSTATE;
extern uint16_t _TRACE_BLK_ROOT_ATTACH_DSTATE;
extern uint16_t _TRACE_BLK_ROOT_DETACH_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PREADV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITEV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_BDRV_CO_DO_COPY_ON_READV_DSTATE;
extern uint16_t _TRACE_STREAM_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_STREAM_START_DSTATE;
extern uint16_t _TRACE_COMMIT_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_COMMIT_START_DSTATE;
extern uint16_t _TRACE_MIRROR_START_DSTATE;
extern uint16_t _TRACE_MIRROR_RESTART_ITER_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_FLUSH_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_DRAIN_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_SLEEP_DSTATE;
extern uint16_t _TRACE_MIRROR_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_MIRROR_ITERATION_DONE_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_IN_FLIGHT_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_ENTER_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_RETURN_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_SKIP_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_PROCESS_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_READ_FAIL_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_CANCEL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_PAUSE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_RESUME_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_COMPLETE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_FINALIZE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_DISMISS_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_STREAM_DSTATE;
extern uint16_t _TRACE_PAIO_SUBMIT_CO_DSTATE;
extern uint16_t _TRACE_PAIO_SUBMIT_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DATA_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_COPIED_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_ALLOC_DSTATE;
extern uint16_t _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_LINK_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_READ_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_FLUSH_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_ENTRY_FLUSH_DSTATE;
extern uint16_t _TRACE_QED_ALLOC_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_UNREF_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_FIND_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_NEED_CHECK_TIMER_CB_DSTATE;
extern uint16_t _TRACE_QED_START_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_CANCEL_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_AIO_COMPLETE_DSTATE;
extern uint16_t _TRACE_QED_AIO_SETUP_DSTATE;
extern uint16_t _TRACE_QED_AIO_NEXT_IO_DSTATE;
extern uint16_t _TRACE_QED_AIO_READ_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_PREFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_POSTFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_MAIN_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_CHNFAIL_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_UNKNWN_DSTATE;
extern uint16_t _TRACE_VXHS_AIO_RW_INVALID_DSTATE;
extern uint16_t _TRACE_VXHS_AIO_RW_IOERR_DSTATE;
extern uint16_t _TRACE_VXHS_GET_VDISK_STAT_ERR_DSTATE;
extern uint16_t _TRACE_VXHS_GET_VDISK_STAT_DSTATE;
extern uint16_t _TRACE_VXHS_COMPLETE_AIO_DSTATE;
extern uint16_t _TRACE_VXHS_PARSE_URI_FILENAME_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_VDISKID_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_HOSTINFO_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_IIO_OPEN_DSTATE;
extern uint16_t _TRACE_VXHS_PARSE_URI_HOSTINFO_DSTATE;
extern uint16_t _TRACE_VXHS_CLOSE_DSTATE;
extern uint16_t _TRACE_VXHS_GET_CREDS_DSTATE;
extern uint16_t _TRACE_NVME_KICK_DSTATE;
extern uint16_t _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_ERROR_DSTATE;
extern uint16_t _TRACE_NVME_PROCESS_COMPLETION_DSTATE;
extern uint16_t _TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_DSTATE;
extern uint16_t _TRACE_NVME_COMPLETE_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_RAW_DSTATE;
extern uint16_t _TRACE_NVME_HANDLE_EVENT_DSTATE;
extern uint16_t _TRACE_NVME_POLL_CB_DSTATE;
extern uint16_t _TRACE_NVME_PRW_ALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_QIOV_UNALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_PRW_BUFFERED_DSTATE;
extern uint16_t _TRACE_NVME_RW_DONE_DSTATE;
extern uint16_t _TRACE_NVME_DMA_MAP_FLUSH_DSTATE;
extern uint16_t _TRACE_NVME_FREE_REQ_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_PAGES_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_IOV_DSTATE;
#define TRACE_BDRV_OPEN_COMMON_ENABLED 1
#define TRACE_BDRV_LOCK_MEDIUM_ENABLED 1
#define TRACE_BLOCK_JOB_COMPLETED_ENABLED 1
#define TRACE_BLOCK_JOB_STATE_TRANSITION_ENABLED 1
#define TRACE_BLOCK_JOB_APPLY_VERB_ENABLED 1
#define TRACE_BLK_CO_PREADV_ENABLED 1
#define TRACE_BLK_CO_PWRITEV_ENABLED 1
#define TRACE_BLK_ROOT_ATTACH_ENABLED 1
#define TRACE_BLK_ROOT_DETACH_ENABLED 1
#define TRACE_BDRV_CO_PREADV_ENABLED 1
#define TRACE_BDRV_CO_PWRITEV_ENABLED 1
#define TRACE_BDRV_CO_PWRITE_ZEROES_ENABLED 1
#define TRACE_BDRV_CO_DO_COPY_ON_READV_ENABLED 1
#define TRACE_STREAM_ONE_ITERATION_ENABLED 1
#define TRACE_STREAM_START_ENABLED 1
#define TRACE_COMMIT_ONE_ITERATION_ENABLED 1
#define TRACE_COMMIT_START_ENABLED 1
#define TRACE_MIRROR_START_ENABLED 1
#define TRACE_MIRROR_RESTART_ITER_ENABLED 1
#define TRACE_MIRROR_BEFORE_FLUSH_ENABLED 1
#define TRACE_MIRROR_BEFORE_DRAIN_ENABLED 1
#define TRACE_MIRROR_BEFORE_SLEEP_ENABLED 1
#define TRACE_MIRROR_ONE_ITERATION_ENABLED 1
#define TRACE_MIRROR_ITERATION_DONE_ENABLED 1
#define TRACE_MIRROR_YIELD_ENABLED 1
#define TRACE_MIRROR_YIELD_IN_FLIGHT_ENABLED 1
#define TRACE_BACKUP_DO_COW_ENTER_ENABLED 1
#define TRACE_BACKUP_DO_COW_RETURN_ENABLED 1
#define TRACE_BACKUP_DO_COW_SKIP_ENABLED 1
#define TRACE_BACKUP_DO_COW_PROCESS_ENABLED 1
#define TRACE_BACKUP_DO_COW_READ_FAIL_ENABLED 1
#define TRACE_BACKUP_DO_COW_WRITE_FAIL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_CANCEL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_PAUSE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_RESUME_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_COMPLETE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_FINALIZE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_DISMISS_ENABLED 1
#define TRACE_QMP_BLOCK_STREAM_ENABLED 1
#define TRACE_PAIO_SUBMIT_CO_ENABLED 1
#define TRACE_PAIO_SUBMIT_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DATA_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_ENABLED 1
#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_HANDLE_COPIED_ENABLED 1
#define TRACE_QCOW2_HANDLE_ALLOC_ENABLED 1
#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_ENABLED 1
#define TRACE_QCOW2_CLUSTER_LINK_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_READ_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_FLUSH_ENABLED 1
#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_ENABLED 1
#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_UNREF_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_FIND_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_READ_TABLE_ENABLED 1
#define TRACE_QED_READ_TABLE_CB_ENABLED 1
#define TRACE_QED_WRITE_TABLE_ENABLED 1
#define TRACE_QED_WRITE_TABLE_CB_ENABLED 1
#define TRACE_QED_NEED_CHECK_TIMER_CB_ENABLED 1
#define TRACE_QED_START_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_AIO_COMPLETE_ENABLED 1
#define TRACE_QED_AIO_SETUP_ENABLED 1
#define TRACE_QED_AIO_NEXT_IO_ENABLED 1
#define TRACE_QED_AIO_READ_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_PREFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_POSTFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_MAIN_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_CHNFAIL_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_UNKNWN_ENABLED 1
#define TRACE_VXHS_AIO_RW_INVALID_ENABLED 1
#define TRACE_VXHS_AIO_RW_IOERR_ENABLED 1
#define TRACE_VXHS_GET_VDISK_STAT_ERR_ENABLED 1
#define TRACE_VXHS_GET_VDISK_STAT_ENABLED 1
#define TRACE_VXHS_COMPLETE_AIO_ENABLED 1
#define TRACE_VXHS_PARSE_URI_FILENAME_ENABLED 1
#define TRACE_VXHS_OPEN_VDISKID_ENABLED 1
#define TRACE_VXHS_OPEN_HOSTINFO_ENABLED 1
#define TRACE_VXHS_OPEN_IIO_OPEN_ENABLED 1
#define TRACE_VXHS_PARSE_URI_HOSTINFO_ENABLED 1
#define TRACE_VXHS_CLOSE_ENABLED 1
#define TRACE_VXHS_GET_CREDS_ENABLED 1
#define TRACE_NVME_KICK_ENABLED 1
#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_ERROR_ENABLED 1
#define TRACE_NVME_PROCESS_COMPLETION_ENABLED 1
#define TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_ENABLED 1
#define TRACE_NVME_COMPLETE_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_RAW_ENABLED 1
#define TRACE_NVME_HANDLE_EVENT_ENABLED 1
#define TRACE_NVME_POLL_CB_ENABLED 1
#define TRACE_NVME_PRW_ALIGNED_ENABLED 1
#define TRACE_NVME_QIOV_UNALIGNED_ENABLED 1
#define TRACE_NVME_PRW_BUFFERED_ENABLED 1
#define TRACE_NVME_RW_DONE_ENABLED 1
#define TRACE_NVME_DMA_MAP_FLUSH_ENABLED 1
#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_PAGES_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_IOV_ENABLED 1

#define TRACE_BDRV_OPEN_COMMON_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
}

static inline void trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    if (true) {
        _nocheck__trace_bdrv_open_common(bs, filename, flags, format_name);
    }
}

#define TRACE_BDRV_LOCK_MEDIUM_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_lock_medium(void * bs, bool locked)
{
}

static inline void trace_bdrv_lock_medium(void * bs, bool locked)
{
    if (true) {
        _nocheck__trace_bdrv_lock_medium(bs, locked);
    }
}

#define TRACE_BLOCK_JOB_COMPLETED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_block_job_completed(void * job, int ret, int jret)
{
}

static inline void trace_block_job_completed(void * job, int ret, int jret)
{
    if (true) {
        _nocheck__trace_block_job_completed(job, ret, jret);
    }
}

#define TRACE_BLOCK_JOB_STATE_TRANSITION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_block_job_state_transition(void * job, int ret, const char * legal, const char * s0, const char * s1)
{
}

static inline void trace_block_job_state_transition(void * job, int ret, const char * legal, const char * s0, const char * s1)
{
    if (true) {
        _nocheck__trace_block_job_state_transition(job, ret, legal, s0, s1);
    }
}

#define TRACE_BLOCK_JOB_APPLY_VERB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_block_job_apply_verb(void * job, const char * state, const char * verb, const char * legal)
{
}

static inline void trace_block_job_apply_verb(void * job, const char * state, const char * verb, const char * legal)
{
    if (true) {
        _nocheck__trace_block_job_apply_verb(job, state, verb, legal);
    }
}

#define TRACE_BLK_CO_PREADV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_blk_co_preadv(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
}

static inline void trace_blk_co_preadv(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_preadv(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BLK_CO_PWRITEV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
}

static inline void trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_pwritev(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BLK_ROOT_ATTACH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_blk_root_attach(void * child, void * blk, void * bs)
{
}

static inline void trace_blk_root_attach(void * child, void * blk, void * bs)
{
    if (true) {
        _nocheck__trace_blk_root_attach(child, blk, bs);
    }
}

#define TRACE_BLK_ROOT_DETACH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_blk_root_detach(void * child, void * blk, void * bs)
{
}

static inline void trace_blk_root_detach(void * child, void * blk, void * bs)
{
    if (true) {
        _nocheck__trace_blk_root_detach(child, blk, bs);
    }
}

#define TRACE_BDRV_CO_PREADV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_co_preadv(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
}

static inline void trace_bdrv_co_preadv(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_preadv(bs, offset, nbytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITEV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_co_pwritev(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
}

static inline void trace_bdrv_co_pwritev(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwritev(bs, offset, nbytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int count, int flags)
{
}

static inline void trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int count, int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwrite_zeroes(bs, offset, count, flags);
    }
}

#define TRACE_BDRV_CO_DO_COPY_ON_READV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, unsigned int bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
}

static inline void trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, unsigned int bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
    if (true) {
        _nocheck__trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes);
    }
}

#define TRACE_STREAM_ONE_ITERATION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
}

static inline void trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_stream_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_STREAM_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_stream_start(void * bs, void * base, void * s)
{
}

static inline void trace_stream_start(void * bs, void * base, void * s)
{
    if (true) {
        _nocheck__trace_stream_start(bs, base, s);
    }
}

#define TRACE_COMMIT_ONE_ITERATION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
}

static inline void trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_commit_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_COMMIT_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_commit_start(void * bs, void * base, void * top, void * s)
{
}

static inline void trace_commit_start(void * bs, void * base, void * top, void * s)
{
    if (true) {
        _nocheck__trace_commit_start(bs, base, top, s);
    }
}

#define TRACE_MIRROR_START_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_start(void * bs, void * s, void * opaque)
{
}

static inline void trace_mirror_start(void * bs, void * s, void * opaque)
{
    if (true) {
        _nocheck__trace_mirror_start(bs, s, opaque);
    }
}

#define TRACE_MIRROR_RESTART_ITER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_restart_iter(void * s, int64_t cnt)
{
}

static inline void trace_mirror_restart_iter(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_restart_iter(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_FLUSH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_before_flush(void * s)
{
}

static inline void trace_mirror_before_flush(void * s)
{
    if (true) {
        _nocheck__trace_mirror_before_flush(s);
    }
}

#define TRACE_MIRROR_BEFORE_DRAIN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_before_drain(void * s, int64_t cnt)
{
}

static inline void trace_mirror_before_drain(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_before_drain(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_SLEEP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
}

static inline void trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
    if (true) {
        _nocheck__trace_mirror_before_sleep(s, cnt, synced, delay_ns);
    }
}

#define TRACE_MIRROR_ONE_ITERATION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
}

static inline void trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_mirror_one_iteration(s, offset, bytes);
    }
}

#define TRACE_MIRROR_ITERATION_DONE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
}

static inline void trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_mirror_iteration_done(s, offset, bytes, ret);
    }
}

#define TRACE_MIRROR_YIELD_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
}

static inline void trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield(s, cnt, buf_free_count, in_flight);
    }
}

#define TRACE_MIRROR_YIELD_IN_FLIGHT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
}

static inline void trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield_in_flight(s, offset, in_flight);
    }
}

#define TRACE_BACKUP_DO_COW_ENTER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
}

static inline void trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_backup_do_cow_enter(job, start, offset, bytes);
    }
}

#define TRACE_BACKUP_DO_COW_RETURN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
}

static inline void trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_return(job, offset, bytes, ret);
    }
}

#define TRACE_BACKUP_DO_COW_SKIP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_skip(void * job, int64_t start)
{
}

static inline void trace_backup_do_cow_skip(void * job, int64_t start)
{
    if (true) {
        _nocheck__trace_backup_do_cow_skip(job, start);
    }
}

#define TRACE_BACKUP_DO_COW_PROCESS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_process(void * job, int64_t start)
{
}

static inline void trace_backup_do_cow_process(void * job, int64_t start)
{
    if (true) {
        _nocheck__trace_backup_do_cow_process(job, start);
    }
}

#define TRACE_BACKUP_DO_COW_READ_FAIL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_read_fail(void * job, int64_t start, int ret)
{
}

static inline void trace_backup_do_cow_read_fail(void * job, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_read_fail(job, start, ret);
    }
}

#define TRACE_BACKUP_DO_COW_WRITE_FAIL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_backup_do_cow_write_fail(void * job, int64_t start, int ret)
{
}

static inline void trace_backup_do_cow_write_fail(void * job, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_write_fail(job, start, ret);
    }
}

#define TRACE_QMP_BLOCK_JOB_CANCEL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_cancel(void * job)
{
}

static inline void trace_qmp_block_job_cancel(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_cancel(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_PAUSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_pause(void * job)
{
}

static inline void trace_qmp_block_job_pause(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_pause(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_RESUME_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_resume(void * job)
{
}

static inline void trace_qmp_block_job_resume(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_resume(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_COMPLETE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_complete(void * job)
{
}

static inline void trace_qmp_block_job_complete(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_complete(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_FINALIZE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_finalize(void * job)
{
}

static inline void trace_qmp_block_job_finalize(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_finalize(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_DISMISS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_job_dismiss(void * job)
{
}

static inline void trace_qmp_block_job_dismiss(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_dismiss(job);
    }
}

#define TRACE_QMP_BLOCK_STREAM_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qmp_block_stream(void * bs, void * job)
{
}

static inline void trace_qmp_block_stream(void * bs, void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_stream(bs, job);
    }
}

#define TRACE_PAIO_SUBMIT_CO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_paio_submit_co(int64_t offset, int count, int type)
{
}

static inline void trace_paio_submit_co(int64_t offset, int count, int type)
{
    if (true) {
        _nocheck__trace_paio_submit_co(offset, count, type);
    }
}

#define TRACE_PAIO_SUBMIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
}

static inline void trace_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
    if (true) {
        _nocheck__trace_paio_submit(acb, opaque, offset, count, type);
    }
}

#define TRACE_QCOW2_WRITEV_START_REQ_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_writev_start_req(void * co, int64_t offset, int bytes)
{
}

static inline void trace_qcow2_writev_start_req(void * co, int64_t offset, int bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_req(co, offset, bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_REQ_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_writev_done_req(void * co, int ret)
{
}

static inline void trace_qcow2_writev_done_req(void * co, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_req(co, ret);
    }
}

#define TRACE_QCOW2_WRITEV_START_PART_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_writev_start_part(void * co)
{
}

static inline void trace_qcow2_writev_start_part(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_part(co);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_PART_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
}

static inline void trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_part(co, cur_bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DATA_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_writev_data(void * co, uint64_t offset)
{
}

static inline void trace_qcow2_writev_data(void * co, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qcow2_writev_data(co, offset);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int count)
{
}

static inline void trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int count)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes_start_req(co, offset, count);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int count)
{
}

static inline void trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int count)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes(co, offset, count);
    }
}

#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
}

static inline void trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
    if (true) {
        _nocheck__trace_qcow2_alloc_clusters_offset(co, offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_COPIED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
}

static inline void trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_copied(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_ALLOC_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
}

static inline void trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_alloc(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
}

static inline void trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_do_alloc_clusters_offset(co, guest_offset, host_offset, nb_clusters);
    }
}

#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cluster_alloc_phys(void * co)
{
}

static inline void trace_qcow2_cluster_alloc_phys(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_alloc_phys(co);
    }
}

#define TRACE_QCOW2_CLUSTER_LINK_L2_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
}

static inline void trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_link_l2(co, nb_clusters);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate(void * bs, int l1_index)
{
}

static inline void trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
}

static inline void trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_get_empty(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
}

static inline void trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l2(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
}

static inline void trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l1(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_DONE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
}

static inline void trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_done(bs, l1_index, ret);
    }
}

#define TRACE_QCOW2_CACHE_GET_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
}

static inline void trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get(co, c, offset, read_from_disk);
    }
}

#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
}

static inline void trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_replace_entry(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_READ_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_get_read(void * co, int c, int i)
{
}

static inline void trace_qcow2_cache_get_read(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_read(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_DONE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_get_done(void * co, int c, int i)
{
}

static inline void trace_qcow2_cache_get_done(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_done(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_FLUSH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_flush(void * co, int c)
{
}

static inline void trace_qcow2_cache_flush(void * co, int c)
{
    if (true) {
        _nocheck__trace_qcow2_cache_flush(co, c);
    }
}

#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
}

static inline void trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_entry_flush(co, c, i);
    }
}

#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
}

static inline void trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    if (true) {
        _nocheck__trace_qed_alloc_l2_cache_entry(l2_cache, entry);
    }
}

#define TRACE_QED_UNREF_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
}

static inline void trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    if (true) {
        _nocheck__trace_qed_unref_l2_cache_entry(entry, ref);
    }
}

#define TRACE_QED_FIND_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
}

static inline void trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    if (true) {
        _nocheck__trace_qed_find_l2_cache_entry(l2_cache, entry, offset, ref);
    }
}

#define TRACE_QED_READ_TABLE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_read_table(void * s, uint64_t offset, void * table)
{
}

static inline void trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    if (true) {
        _nocheck__trace_qed_read_table(s, offset, table);
    }
}

#define TRACE_QED_READ_TABLE_CB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_read_table_cb(void * s, void * table, int ret)
{
}

static inline void trace_qed_read_table_cb(void * s, void * table, int ret)
{
    if (true) {
        _nocheck__trace_qed_read_table_cb(s, table, ret);
    }
}

#define TRACE_QED_WRITE_TABLE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
}

static inline void trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    if (true) {
        _nocheck__trace_qed_write_table(s, offset, table, index, n);
    }
}

#define TRACE_QED_WRITE_TABLE_CB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
}

static inline void trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    if (true) {
        _nocheck__trace_qed_write_table_cb(s, table, flush, ret);
    }
}

#define TRACE_QED_NEED_CHECK_TIMER_CB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_need_check_timer_cb(void * s)
{
}

static inline void trace_qed_need_check_timer_cb(void * s)
{
    if (true) {
        _nocheck__trace_qed_need_check_timer_cb(s);
    }
}

#define TRACE_QED_START_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_start_need_check_timer(void * s)
{
}

static inline void trace_qed_start_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_start_need_check_timer(s);
    }
}

#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_cancel_need_check_timer(void * s)
{
}

static inline void trace_qed_cancel_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_cancel_need_check_timer(s);
    }
}

#define TRACE_QED_AIO_COMPLETE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_complete(void * s, void * acb, int ret)
{
}

static inline void trace_qed_aio_complete(void * s, void * acb, int ret)
{
    if (true) {
        _nocheck__trace_qed_aio_complete(s, acb, ret);
    }
}

#define TRACE_QED_AIO_SETUP_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
}

static inline void trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    if (true) {
        _nocheck__trace_qed_aio_setup(s, acb, sector_num, nb_sectors, opaque, flags);
    }
}

#define TRACE_QED_AIO_NEXT_IO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
}

static inline void trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    if (true) {
        _nocheck__trace_qed_aio_next_io(s, acb, ret, cur_pos);
    }
}

#define TRACE_QED_AIO_READ_DATA_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
}

static inline void trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_read_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_DATA_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
}

static inline void trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_PREFILL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
}

static inline void trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_prefill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_POSTFILL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
}

static inline void trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_postfill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_MAIN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
}

static inline void trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_main(s, acb, ret, offset, len);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_iio_callback(int error)
{
}

static inline void trace_vxhs_iio_callback(int error)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback(error);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_CHNFAIL_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_iio_callback_chnfail(int err, int error)
{
}

static inline void trace_vxhs_iio_callback_chnfail(int err, int error)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback_chnfail(err, error);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_UNKNWN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_iio_callback_unknwn(int opcode, int err)
{
}

static inline void trace_vxhs_iio_callback_unknwn(int opcode, int err)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback_unknwn(opcode, err);
    }
}

#define TRACE_VXHS_AIO_RW_INVALID_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_aio_rw_invalid(int req)
{
}

static inline void trace_vxhs_aio_rw_invalid(int req)
{
    if (true) {
        _nocheck__trace_vxhs_aio_rw_invalid(req);
    }
}

#define TRACE_VXHS_AIO_RW_IOERR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_aio_rw_ioerr(char * guid, int iodir, uint64_t size, uint64_t off, void * acb, int ret, int err)
{
}

static inline void trace_vxhs_aio_rw_ioerr(char * guid, int iodir, uint64_t size, uint64_t off, void * acb, int ret, int err)
{
    if (true) {
        _nocheck__trace_vxhs_aio_rw_ioerr(guid, iodir, size, off, acb, ret, err);
    }
}

#define TRACE_VXHS_GET_VDISK_STAT_ERR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_get_vdisk_stat_err(char * guid, int ret, int err)
{
}

static inline void trace_vxhs_get_vdisk_stat_err(char * guid, int ret, int err)
{
    if (true) {
        _nocheck__trace_vxhs_get_vdisk_stat_err(guid, ret, err);
    }
}

#define TRACE_VXHS_GET_VDISK_STAT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_get_vdisk_stat(char * vdisk_guid, uint64_t vdisk_size)
{
}

static inline void trace_vxhs_get_vdisk_stat(char * vdisk_guid, uint64_t vdisk_size)
{
    if (true) {
        _nocheck__trace_vxhs_get_vdisk_stat(vdisk_guid, vdisk_size);
    }
}

#define TRACE_VXHS_COMPLETE_AIO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_complete_aio(void * acb, uint64_t ret)
{
}

static inline void trace_vxhs_complete_aio(void * acb, uint64_t ret)
{
    if (true) {
        _nocheck__trace_vxhs_complete_aio(acb, ret);
    }
}

#define TRACE_VXHS_PARSE_URI_FILENAME_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_parse_uri_filename(const char * filename)
{
}

static inline void trace_vxhs_parse_uri_filename(const char * filename)
{
    if (true) {
        _nocheck__trace_vxhs_parse_uri_filename(filename);
    }
}

#define TRACE_VXHS_OPEN_VDISKID_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_open_vdiskid(const char * vdisk_id)
{
}

static inline void trace_vxhs_open_vdiskid(const char * vdisk_id)
{
    if (true) {
        _nocheck__trace_vxhs_open_vdiskid(vdisk_id);
    }
}

#define TRACE_VXHS_OPEN_HOSTINFO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_open_hostinfo(char * of_vsa_addr, int port)
{
}

static inline void trace_vxhs_open_hostinfo(char * of_vsa_addr, int port)
{
    if (true) {
        _nocheck__trace_vxhs_open_hostinfo(of_vsa_addr, port);
    }
}

#define TRACE_VXHS_OPEN_IIO_OPEN_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_open_iio_open(const char * host)
{
}

static inline void trace_vxhs_open_iio_open(const char * host)
{
    if (true) {
        _nocheck__trace_vxhs_open_iio_open(host);
    }
}

#define TRACE_VXHS_PARSE_URI_HOSTINFO_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_parse_uri_hostinfo(char * host, int port)
{
}

static inline void trace_vxhs_parse_uri_hostinfo(char * host, int port)
{
    if (true) {
        _nocheck__trace_vxhs_parse_uri_hostinfo(host, port);
    }
}

#define TRACE_VXHS_CLOSE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_close(char * vdisk_guid)
{
}

static inline void trace_vxhs_close(char * vdisk_guid)
{
    if (true) {
        _nocheck__trace_vxhs_close(vdisk_guid);
    }
}

#define TRACE_VXHS_GET_CREDS_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_vxhs_get_creds(const char * cacert, const char * client_key, const char * client_cert)
{
}

static inline void trace_vxhs_get_creds(const char * cacert, const char * client_key, const char * client_cert)
{
    if (true) {
        _nocheck__trace_vxhs_get_creds(cacert, client_key, client_cert);
    }
}

#define TRACE_NVME_KICK_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_kick(void * s, int queue)
{
}

static inline void trace_nvme_kick(void * s, int queue)
{
    if (true) {
        _nocheck__trace_nvme_kick(s, queue);
    }
}

#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_dma_flush_queue_wait(void * s)
{
}

static inline void trace_nvme_dma_flush_queue_wait(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_flush_queue_wait(s);
    }
}

#define TRACE_NVME_ERROR_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
}

static inline void trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
    if (true) {
        _nocheck__trace_nvme_error(cmd_specific, sq_head, sqid, cid, status);
    }
}

#define TRACE_NVME_PROCESS_COMPLETION_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_process_completion(void * s, int index, int inflight)
{
}

static inline void trace_nvme_process_completion(void * s, int index, int inflight)
{
    if (true) {
        _nocheck__trace_nvme_process_completion(s, index, inflight);
    }
}

#define TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_process_completion_queue_busy(void * s, int index)
{
}

static inline void trace_nvme_process_completion_queue_busy(void * s, int index)
{
    if (true) {
        _nocheck__trace_nvme_process_completion_queue_busy(s, index);
    }
}

#define TRACE_NVME_COMPLETE_COMMAND_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_complete_command(void * s, int index, int cid)
{
}

static inline void trace_nvme_complete_command(void * s, int index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_complete_command(s, index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_submit_command(void * s, int index, int cid)
{
}

static inline void trace_nvme_submit_command(void * s, int index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_submit_command(s, index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_RAW_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
}

static inline void trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
    if (true) {
        _nocheck__trace_nvme_submit_command_raw(c0, c1, c2, c3, c4, c5, c6, c7);
    }
}

#define TRACE_NVME_HANDLE_EVENT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_handle_event(void * s)
{
}

static inline void trace_nvme_handle_event(void * s)
{
    if (true) {
        _nocheck__trace_nvme_handle_event(s);
    }
}

#define TRACE_NVME_POLL_CB_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_poll_cb(void * s)
{
}

static inline void trace_nvme_poll_cb(void * s)
{
    if (true) {
        _nocheck__trace_nvme_poll_cb(s);
    }
}

#define TRACE_NVME_PRW_ALIGNED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
}

static inline void trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
    if (true) {
        _nocheck__trace_nvme_prw_aligned(s, is_write, offset, bytes, flags, niov);
    }
}

#define TRACE_NVME_QIOV_UNALIGNED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
}

static inline void trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
    if (true) {
        _nocheck__trace_nvme_qiov_unaligned(qiov, n, base, size, align);
    }
}

#define TRACE_NVME_PRW_BUFFERED_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
}

static inline void trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
    if (true) {
        _nocheck__trace_nvme_prw_buffered(s, offset, bytes, niov, is_write);
    }
}

#define TRACE_NVME_RW_DONE_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
}

static inline void trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_nvme_rw_done(s, is_write, offset, bytes, ret);
    }
}

#define TRACE_NVME_DMA_MAP_FLUSH_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_dma_map_flush(void * s)
{
}

static inline void trace_nvme_dma_map_flush(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_map_flush(s);
    }
}

#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_free_req_queue_wait(void * q)
{
}

static inline void trace_nvme_free_req_queue_wait(void * q)
{
    if (true) {
        _nocheck__trace_nvme_free_req_queue_wait(q);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
}

static inline void trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov(s, cmd, req, qiov, entries);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_PAGES_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
}

static inline void trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_pages(s, i, page);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_IOV_BACKEND_DSTATE() ( \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
}

static inline void trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_iov(s, i, page, pages);
    }
}
#endif /* TRACE_BLOCK_GENERATED_TRACERS_H */
