// *********************************
// *********************************
// AUTOGENERATED CODE.  DO NOT EDIT.
// *********************************
// *********************************

#include "gles/pass_through.h"
#include "common/alog.h"
#include "common/dlog.h"
#include "common/rendering_interface.h"
#include "gles/debug.h"
#include "gles/gles_context.h"

#include "GLES12Translator/underlying_apis.h"
#include "GLES12Translator/angle_gles2.h"

#define DEBUG 0

#if DEBUG
#define DPRINT(fmt,...) do { \
    DLOG("gles12 underlying: " fmt, ##__VA_ARGS__); \
} while(0)
#else
#define DPRINT(...)
#endif


class ContextAutoLock {
 public:
  ContextAutoLock(emugl::ContextGPU* context) : context_(context) {
  }

  ~ContextAutoLock() {
  }

 private:
  emugl::ContextGPU* context_;
};


void ActiveTextureCall(const GlesContext* c, GLenum texture) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ActiveTextureCall(%p, %s (0x%x))", c, GetEnumString(texture), texture);
  return _api->glActiveTexture(texture);
}


void AttachShaderCall(const GlesContext* c, GLuint program, GLuint shader) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("AttachShaderCall(%p, %u, %u)", c, program, shader);
  return _api->glAttachShader(program, shader);
}


void BindAttribLocationCall(const GlesContext* c, GLuint program, GLuint index, const char* name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BindAttribLocationCall(%p, %u, %u, %p)", c, program, index, name);
  return _api->glBindAttribLocation(program, index, name);
}


void BindBufferCall(const GlesContext* c, GLenum target, GLuint buffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BindBufferCall(%p, %s (0x%x), %u)", c, GetEnumString(target), target, buffer);
  return _api->glBindBuffer(target, buffer);
}


void BindFramebufferCall(const GlesContext* c, GLenum target, GLuint framebuffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BindFramebufferCall(%p, %s (0x%x), %u)", c, GetEnumString(target), target, framebuffer);
  return _api->glBindFramebuffer(target, framebuffer);
}


void BindRenderbufferCall(const GlesContext* c, GLenum target, GLuint renderbuffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BindRenderbufferCall(%p, %s (0x%x), %u)", c, GetEnumString(target), target, renderbuffer);
  return _api->glBindRenderbuffer(target, renderbuffer);
}


void BindTextureCall(const GlesContext* c, GLenum target, GLuint texture) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BindTextureCall(%p, %s (0x%x), %u)", c, GetEnumString(target), target, texture);
  return _api->glBindTexture(target, texture);
}


void BlendColorCall(const GlesContext* c, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BlendColorCall(%p, %f, %f, %f, %f)", c, red, green, blue, alpha);
  return _api->glBlendColor(red, green, blue, alpha);
}


void BlendEquationCall(const GlesContext* c, GLenum mode) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BlendEquationCall(%p, %s (0x%x))", c, GetEnumString(mode), mode);
  return _api->glBlendEquation(mode);
}


void BlendEquationSeparateCall(const GlesContext* c, GLenum modeRGB, GLenum modeAlpha) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BlendEquationSeparateCall(%p, %s (0x%x), %s (0x%x))", c, GetEnumString(modeRGB), modeRGB, GetEnumString(modeAlpha), modeAlpha);
  return _api->glBlendEquationSeparate(modeRGB, modeAlpha);
}


void BlendFuncCall(const GlesContext* c, GLenum sfactor, GLenum dfactor) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BlendFuncCall(%p, %s (0x%x), %s (0x%x))", c, GetEnumString(sfactor), sfactor, GetEnumString(dfactor), dfactor);
  return _api->glBlendFunc(sfactor, dfactor);
}


void BlendFuncSeparateCall(const GlesContext* c, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BlendFuncSeparateCall(%p, %s (0x%x), %s (0x%x), %s (0x%x), %s (0x%x))", c, GetEnumString(srcRGB), srcRGB, GetEnumString(dstRGB), dstRGB, GetEnumString(srcAlpha), srcAlpha, GetEnumString(dstAlpha), dstAlpha);
  return _api->glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}


void BufferDataCall(const GlesContext* c, GLenum target, GLsizeiptr size, const void* data, GLenum usage) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BufferDataCall(%p, %s (0x%x), %ld, %p, %s (0x%x))", c, GetEnumString(target), target, size, data, GetEnumString(usage), usage);
  return _api->glBufferData(target, size, data, usage);
}


void BufferSubDataCall(const GlesContext* c, GLenum target, GLintptr offset, GLsizeiptr size, const void* data) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("BufferSubDataCall(%p, %s (0x%x), %ld, %ld, %p)", c, GetEnumString(target), target, offset, size, data);
  return _api->glBufferSubData(target, offset, size, data);
}


GLenum CheckFramebufferStatusCall(const GlesContext* c, GLenum target) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CheckFramebufferStatusCall(%p, %s (0x%x))", c, GetEnumString(target), target);
  return _api->glCheckFramebufferStatus(target);
}


void ClearCall(const GlesContext* c, GLbitfield mask) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ClearCall(%p, 0x%x)", c, mask);
  return _api->glClear(mask);
}


void ClearColorCall(const GlesContext* c, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ClearColorCall(%p, %f, %f, %f, %f)", c, red, green, blue, alpha);
  return _api->glClearColor(red, green, blue, alpha);
}


void ClearDepthfCall(const GlesContext* c, GLclampf depth) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ClearDepthfCall(%p, %f)", c, depth);
  return _api->glClearDepth((GLclampd)depth);
}


void ClearStencilCall(const GlesContext* c, GLint s) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ClearStencilCall(%p, %d)", c, s);
  return _api->glClearStencil(s);
}


void ColorMaskCall(const GlesContext* c, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ColorMaskCall(%p, %d, %d, %d, %d)", c, red, green, blue, alpha);
  return _api->glColorMask(red, green, blue, alpha);
}


void CompileShaderCall(const GlesContext* c, GLuint shader) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CompileShaderCall(%p, %u)", c, shader);
  return _api->glCompileShader(shader);
}


void CompressedTexImage2DCall(const GlesContext* c, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CompressedTexImage2DCall(%p, %s (0x%x), %d, %s (0x%x), %zd, %zd, %d, %zd, %p)", c, GetEnumString(target), target, level, GetEnumString(internalformat), internalformat, width, height, border, imageSize, data);
  return _api->glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}


void CompressedTexSubImage2DCall(const GlesContext* c, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CompressedTexSubImage2DCall(%p, %s (0x%x), %d, %d, %d, %zd, %zd, %s (0x%x), %zd, %p)", c, GetEnumString(target), target, level, xoffset, yoffset, width, height, GetEnumString(format), format, imageSize, data);
  return _api->glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}


void CopyTexImage2DCall(const GlesContext* c, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CopyTexImage2DCall(%p, %s (0x%x), %d, %s (0x%x), %d, %d, %zd, %zd, %d)", c, GetEnumString(target), target, level, GetEnumString(internalformat), internalformat, x, y, width, height, border);
  return _api->glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}


void CopyTexSubImage2DCall(const GlesContext* c, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CopyTexSubImage2DCall(%p, %s (0x%x), %d, %d, %d, %d, %d, %zd, %zd)", c, GetEnumString(target), target, level, xoffset, yoffset, x, y, width, height);
  return _api->glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}


GLuint CreateProgramCall(const GlesContext* c) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CreateProgramCall(%p)", c);
  return _api->glCreateProgram();
}


GLuint CreateShaderCall(const GlesContext* c, GLenum type) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CreateShaderCall(%p, %s (0x%x))", c, GetEnumString(type), type);
  return _api->glCreateShader(type);
}


void CullFaceCall(const GlesContext* c, GLenum mode) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("CullFaceCall(%p, %s (0x%x))", c, GetEnumString(mode), mode);
  return _api->glCullFace(mode);
}


void DeleteBuffersCall(const GlesContext* c, GLsizei n, const GLuint* buffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteBuffersCall(%p, %zd, %p)", c, n, buffers);
  return _api->glDeleteBuffers(n, buffers);
}


void DeleteFramebuffersCall(const GlesContext* c, GLsizei n, const GLuint* framebuffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteFramebuffersCall(%p, %zd, %p)", c, n, framebuffers);
  return _api->glDeleteFramebuffers(n, framebuffers);
}


void DeleteProgramCall(const GlesContext* c, GLuint program) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteProgramCall(%p, %u)", c, program);
  return _api->glDeleteProgram(program);
}


void DeleteRenderbuffersCall(const GlesContext* c, GLsizei n, const GLuint* renderbuffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteRenderbuffersCall(%p, %zd, %p)", c, n, renderbuffers);
  return _api->glDeleteRenderbuffers(n, renderbuffers);
}


void DeleteShaderCall(const GlesContext* c, GLuint shader) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteShaderCall(%p, %u)", c, shader);
  return _api->glDeleteShader(shader);
}


void DeleteTexturesCall(const GlesContext* c, GLsizei n, const GLuint* textures) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DeleteTexturesCall(%p, %zd, %p)", c, n, textures);
  return _api->glDeleteTextures(n, textures);
}


void DepthFuncCall(const GlesContext* c, GLenum func) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DepthFuncCall(%p, %s (0x%x))", c, GetEnumString(func), func);
  return _api->glDepthFunc(func);
}


void DepthMaskCall(const GlesContext* c, GLboolean flag) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DepthMaskCall(%p, %d)", c, flag);
  return _api->glDepthMask(flag);
}


void DepthRangefCall(const GlesContext* c, GLclampf zNear, GLclampf zFar) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DepthRangefCall(%p, %f, %f)", c, zNear, zFar);
  return _api->glDepthRange((GLclampd)zNear, (GLclampd)zFar);
}


void DetachShaderCall(const GlesContext* c, GLuint program, GLuint shader) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DetachShaderCall(%p, %u, %u)", c, program, shader);
  return _api->glDetachShader(program, shader);
}


void DisableCall(const GlesContext* c, GLenum cap) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DisableCall(%p, %s (0x%x))", c, GetEnumString(cap), cap);
  return _api->glDisable(cap);
}


void DisableVertexAttribArrayCall(const GlesContext* c, GLuint index) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DisableVertexAttribArrayCall(%p, %u)", c, index);
  return _api->glDisableVertexAttribArray(index);
}


void DrawArraysCall(const GlesContext* c, GLenum mode, GLint first, GLsizei count) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DrawArraysCall(%p, %s (0x%x), %d, %zd)", c, GetEnumString(mode), mode, first, count);
  return _api->glDrawArrays(mode, first, count);
}


void DrawElementsCall(const GlesContext* c, GLenum mode, GLsizei count, GLenum type, const void* indices) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("DrawElementsCall(%p, %s (0x%x), %zd, %s (0x%x), %p)", c, GetEnumString(mode), mode, count, GetEnumString(type), type, indices);
  return _api->glDrawElements(mode, count, type, indices);
}

void EGLImageTargetTexture2DOESCall(const GlesContext* c, GLenum target, GLeglImageOES buffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
#ifdef DEBUG
  DPRINT("EGLImageTargetTexture2DOESCall(%p, %s (0x%x), %p)", c, GetEnumString(target), target, buffer);
#endif
  return _api->glEGLImageTargetTexture2DOES(target, buffer);
}

void EnableCall(const GlesContext* c, GLenum cap) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("EnableCall(%p, %s (0x%x))", c, GetEnumString(cap), cap);
  return _api->glEnable(cap);
}


void EnableVertexAttribArrayCall(const GlesContext* c, GLuint index) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("EnableVertexAttribArrayCall(%p, %u)", c, index);
  return _api->glEnableVertexAttribArray(index);
}


void FinishCall(const GlesContext* c) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("FinishCall(%p)", c);
  return _api->glFinish();
}


void FlushCall(const GlesContext* c) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("FlushCall(%p)", c);
  return _api->glFlush();
}


void FramebufferRenderbufferCall(const GlesContext* c, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("FramebufferRenderbufferCall(%p, %s (0x%x), %s (0x%x), %s (0x%x), %u)", c, GetEnumString(target), target, GetEnumString(attachment), attachment, GetEnumString(renderbuffertarget), renderbuffertarget, renderbuffer);
  return _api->glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}


void FramebufferTexture2DCall(const GlesContext* c, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("FramebufferTexture2DCall(%p, %s (0x%x), %s (0x%x), %s (0x%x), %u, %d)", c, GetEnumString(target), target, GetEnumString(attachment), attachment, GetEnumString(textarget), textarget, texture, level);
  return _api->glFramebufferTexture2D(target, attachment, textarget, texture, level);
}


void FrontFaceCall(const GlesContext* c, GLenum mode) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("FrontFaceCall(%p, %s (0x%x))", c, GetEnumString(mode), mode);
  return _api->glFrontFace(mode);
}


void GenBuffersCall(const GlesContext* c, GLsizei n, GLuint* buffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GenBuffersCall(%p, %zd, %p)", c, n, buffers);
  return _api->glGenBuffers(n, buffers);
}


void GenerateMipmapCall(const GlesContext* c, GLenum target) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GenerateMipmapCall(%p, %s (0x%x))", c, GetEnumString(target), target);
  return _api->glGenerateMipmap(target);
}


void GenFramebuffersCall(const GlesContext* c, GLsizei n, GLuint* framebuffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GenFramebuffersCall(%p, %zd, %p)", c, n, framebuffers);
  return _api->glGenFramebuffers(n, framebuffers);
}


void GenRenderbuffersCall(const GlesContext* c, GLsizei n, GLuint* renderbuffers) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GenRenderbuffersCall(%p, %zd, %p)", c, n, renderbuffers);
  return _api->glGenRenderbuffers(n, renderbuffers);
}


void GenTexturesCall(const GlesContext* c, GLsizei n, GLuint* textures) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GenTexturesCall(%p, %zd, %p)", c, n, textures);
  return _api->glGenTextures(n, textures);
}


void GetActiveAttribCall(const GlesContext* c, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetActiveAttribCall(%p, %u, %u, %zd, %p, %p, %p, %p)", c, program, index, bufsize, length, size, type, name);
  return _api->glGetActiveAttrib(program, index, bufsize, length, size, type, name);
}


void GetActiveUniformCall(const GlesContext* c, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetActiveUniformCall(%p, %u, %u, %zd, %p, %p, %p, %p)", c, program, index, bufsize, length, size, type, name);
  return _api->glGetActiveUniform(program, index, bufsize, length, size, type, name);
}


void GetAttachedShadersCall(const GlesContext* c, GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetAttachedShadersCall(%p, %u, %zd, %p, %p)", c, program, maxcount, count, shaders);
  return _api->glGetAttachedShaders(program, maxcount, count, shaders);
}


GLint GetAttribLocationCall(const GlesContext* c, GLuint program, const char* name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetAttribLocationCall(%p, %u, %p)", c, program, name);
  return _api->glGetAttribLocation(program, name);
}


void GetBooleanvCall(const GlesContext* c, GLenum pname, GLboolean* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetBooleanvCall(%p, %s (0x%x), %p)", c, GetEnumString(pname), pname, params);
  return _api->glGetBooleanv(pname, params);
}


void GetBufferParameterivCall(const GlesContext* c, GLenum target, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetBufferParameterivCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glGetBufferParameteriv(target, pname, params);
}


GLenum GetErrorCall(const GlesContext* c) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetErrorCall(%p)", c);
  return _api->glGetError();
}


void GetFloatvCall(const GlesContext* c, GLenum pname, GLfloat* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetFloatvCall(%p, %s (0x%x), %p)", c, GetEnumString(pname), pname, params);
  return _api->glGetFloatv(pname, params);
}


void GetIntegervCall(const GlesContext* c, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetIntegervCall(%p, %s (0x%x), %p)", c, GetEnumString(pname), pname, params);
  return _api->glGetIntegerv(pname, params);
}


void GetProgramivCall(const GlesContext* c, GLuint program, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetProgramivCall(%p, %u, %s (0x%x), %p)", c, program, GetEnumString(pname), pname, params);
  return _api->glGetProgramiv(program, pname, params);
}


void GetProgramInfoLogCall(const GlesContext* c, GLuint program, GLsizei bufsize, GLsizei* length, char* infolog) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetProgramInfoLogCall(%p, %u, %zd, %p, %p)", c, program, bufsize, length, infolog);
  return _api->glGetProgramInfoLog(program, bufsize, length, infolog);
}


void GetRenderbufferParameterivCall(const GlesContext* c, GLenum target, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetRenderbufferParameterivCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glGetRenderbufferParameteriv(target, pname, params);
}


void GetShaderivCall(const GlesContext* c, GLuint shader, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetShaderivCall(%p, %u, %s (0x%x), %p)", c, shader, GetEnumString(pname), pname, params);
  return _api->glGetShaderiv(shader, pname, params);
}


void GetShaderInfoLogCall(const GlesContext* c, GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetShaderInfoLogCall(%p, %u, %zd, %p, %p)", c, shader, bufsize, length, infolog);
  return _api->glGetShaderInfoLog(shader, bufsize, length, infolog);
}


void GetShaderPrecisionFormatCall(const GlesContext* c, GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetShaderPrecisionFormatCall(%p, %s (0x%x), %s (0x%x), %p, %p)", c, GetEnumString(shadertype), shadertype, GetEnumString(precisiontype), precisiontype, range, precision);
  return _api->glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}


void GetShaderSourceCall(const GlesContext* c, GLuint shader, GLsizei bufsize, GLsizei* length, char* source) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetShaderSourceCall(%p, %u, %zd, %p, %p)", c, shader, bufsize, length, source);
  return _api->glGetShaderSource(shader, bufsize, length, source);
}


const GLubyte* GetStringCall(const GlesContext* c, GLenum name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetStringCall(%p, %s (0x%x))", c, GetEnumString(name), name);
  return _api->glGetString(name);
}


void GetTexParameterfvCall(const GlesContext* c, GLenum target, GLenum pname, GLfloat* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetTexParameterfvCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glGetTexParameterfv(target, pname, params);
}


void GetTexParameterivCall(const GlesContext* c, GLenum target, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetTexParameterivCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glGetTexParameteriv(target, pname, params);
}


void GetUniformfvCall(const GlesContext* c, GLuint program, GLint location, GLfloat* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetUniformfvCall(%p, %u, %d, %p)", c, program, location, params);
  return _api->glGetUniformfv(program, location, params);
}


void GetUniformivCall(const GlesContext* c, GLuint program, GLint location, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetUniformivCall(%p, %u, %d, %p)", c, program, location, params);
  return _api->glGetUniformiv(program, location, params);
}


GLint GetUniformLocationCall(const GlesContext* c, GLuint program, const char* name) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetUniformLocationCall(%p, %u, %p)", c, program, name);
  return _api->glGetUniformLocation(program, name);
}


void GetVertexAttribfvCall(const GlesContext* c, GLuint index, GLenum pname, GLfloat* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetVertexAttribfvCall(%p, %u, %s (0x%x), %p)", c, index, GetEnumString(pname), pname, params);
  return _api->glGetVertexAttribfv(index, pname, params);
}


void GetVertexAttribivCall(const GlesContext* c, GLuint index, GLenum pname, GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetVertexAttribivCall(%p, %u, %s (0x%x), %p)", c, index, GetEnumString(pname), pname, params);
  return _api->glGetVertexAttribiv(index, pname, params);
}


void GetVertexAttribPointervCall(const GlesContext* c, GLuint index, GLenum pname, void** pointer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("GetVertexAttribPointervCall(%p, %u, %s (0x%x), %p)", c, index, GetEnumString(pname), pname, pointer);
  return _api->glGetVertexAttribPointerv(index, pname, pointer);
}


void HintCall(const GlesContext* c, GLenum target, GLenum mode) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("HintCall(%p, %s (0x%x), %s (0x%x))", c, GetEnumString(target), target, GetEnumString(mode), mode);
  return _api->glHint(target, mode);
}


GLboolean IsBufferCall(const GlesContext* c, GLuint buffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsBufferCall(%p, %u)", c, buffer);
  return _api->glIsBuffer(buffer);
}


GLboolean IsEnabledCall(const GlesContext* c, GLenum cap) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsEnabledCall(%p, %s (0x%x))", c, GetEnumString(cap), cap);
  return _api->glIsEnabled(cap);
}


GLboolean IsProgramCall(const GlesContext* c, GLuint program) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsProgramCall(%p, %u)", c, program);
  return _api->glIsProgram(program);
}


GLboolean IsRenderbufferCall(const GlesContext* c, GLuint renderbuffer) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsRenderbufferCall(%p, %u)", c, renderbuffer);
  return _api->glIsRenderbuffer(renderbuffer);
}


GLboolean IsShaderCall(const GlesContext* c, GLuint shader) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsShaderCall(%p, %u)", c, shader);
  return _api->glIsShader(shader);
}


GLboolean IsTextureCall(const GlesContext* c, GLuint texture) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("IsTextureCall(%p, %u)", c, texture);
  return _api->glIsTexture(texture);
}


void LineWidthCall(const GlesContext* c, GLfloat width) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("LineWidthCall(%p, %f)", c, width);
  return _api->glLineWidth(width);
}


void LinkProgramCall(const GlesContext* c, GLuint program) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("LinkProgramCall(%p, %u)", c, program);
  return _api->glLinkProgram(program);
}


void PixelStoreiCall(const GlesContext* c, GLenum pname, GLint param) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("PixelStoreiCall(%p, %s (0x%x), %d)", c, GetEnumString(pname), pname, param);
  return _api->glPixelStorei(pname, param);
}


void PolygonOffsetCall(const GlesContext* c, GLfloat factor, GLfloat units) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("PolygonOffsetCall(%p, %f, %f)", c, factor, units);
  return _api->glPolygonOffset(factor, units);
}


void ReadPixelsCall(const GlesContext* c, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ReadPixelsCall(%p, %d, %d, %zd, %zd, %s (0x%x), %s (0x%x), %p)", c, x, y, width, height, GetEnumString(format), format, GetEnumString(type), type, pixels);
  return _api->glReadPixels(x, y, width, height, format, type, pixels);
}


void ReleaseShaderCompilerCall(const GlesContext* c) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ReleaseShaderCompilerCall(%p)", c);
  return _api->glReleaseShaderCompiler();
}


void RenderbufferStorageCall(const GlesContext* c, GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("RenderbufferStorageCall(%p, %s (0x%x), %s (0x%x), %zd, %zd)", c, GetEnumString(target), target, GetEnumString(internalformat), internalformat, width, height);
  return _api->glRenderbufferStorage(target, internalformat, width, height);
}


void SampleCoverageCall(const GlesContext* c, GLclampf value, GLboolean invert) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("SampleCoverageCall(%p, %f, %d)", c, value, invert);
  return _api->glSampleCoverage(value, invert);
}


void ScissorCall(const GlesContext* c, GLint x, GLint y, GLsizei width, GLsizei height) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ScissorCall(%p, %d, %d, %zd, %zd)", c, x, y, width, height);
  return _api->glScissor(x, y, width, height);
}


void ShaderBinaryCall(const GlesContext* c, GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ShaderBinaryCall(%p, %zd, %p, %s (0x%x), %p, %zd)", c, n, shaders, GetEnumString(binaryformat), binaryformat, binary, length);
  return _api->glShaderBinary(n, shaders, binaryformat, binary, length);
}


void ShaderSourceCall(const GlesContext* c, GLuint shader, GLsizei count, const char** str, const GLint* length) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ShaderSourceCall(%p, %u, %zd, %p, %p)", c, shader, count, str, length);
  return _api->glShaderSource(shader, count, str, length);
}


void StencilFuncCall(const GlesContext* c, GLenum func, GLint ref, GLuint mask) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilFuncCall(%p, %s (0x%x), %d, %u)", c, GetEnumString(func), func, ref, mask);
  return _api->glStencilFunc(func, ref, mask);
}


void StencilFuncSeparateCall(const GlesContext* c, GLenum face, GLenum func, GLint ref, GLuint mask) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilFuncSeparateCall(%p, %s (0x%x), %s (0x%x), %d, %u)", c, GetEnumString(face), face, GetEnumString(func), func, ref, mask);
  return _api->glStencilFuncSeparate(face, func, ref, mask);
}


void StencilMaskCall(const GlesContext* c, GLuint mask) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilMaskCall(%p, %u)", c, mask);
  return _api->glStencilMask(mask);
}


void StencilMaskSeparateCall(const GlesContext* c, GLenum face, GLuint mask) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilMaskSeparateCall(%p, %s (0x%x), %u)", c, GetEnumString(face), face, mask);
  return _api->glStencilMaskSeparate(face, mask);
}


void StencilOpCall(const GlesContext* c, GLenum fail, GLenum zfail, GLenum zpass) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilOpCall(%p, %s (0x%x), %s (0x%x), %s (0x%x))", c, GetEnumString(fail), fail, GetEnumString(zfail), zfail, GetEnumString(zpass), zpass);
  return _api->glStencilOp(fail, zfail, zpass);
}


void StencilOpSeparateCall(const GlesContext* c, GLenum face, GLenum fail, GLenum zfail, GLenum zpass) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("StencilOpSeparateCall(%p, %s (0x%x), %s (0x%x), %s (0x%x), %s (0x%x))", c, GetEnumString(face), face, GetEnumString(fail), fail, GetEnumString(zfail), zfail, GetEnumString(zpass), zpass);
  return _api->glStencilOpSeparate(face, fail, zfail, zpass);
}


void TexImage2DCall(const GlesContext* c, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexImage2DCall(%p, %s (0x%x), %d, %d, %zd, %zd, %d, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, level, internalformat, width, height, border, GetEnumString(format), format, GetEnumString(type), type, pixels);
  return _api->glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}


void TexParameterfCall(const GlesContext* c, GLenum target, GLenum pname, GLfloat param) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexParameterfCall(%p, %s (0x%x), %s (0x%x), %f)", c, GetEnumString(target), target, GetEnumString(pname), pname, param);
  return _api->glTexParameterf(target, pname, param);
}


void TexParameterfvCall(const GlesContext* c, GLenum target, GLenum pname, const GLfloat* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexParameterfvCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glTexParameterfv(target, pname, params);
}


void TexParameteriCall(const GlesContext* c, GLenum target, GLenum pname, GLint param) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexParameteriCall(%p, %s (0x%x), %s (0x%x), %d)", c, GetEnumString(target), target, GetEnumString(pname), pname, param);
  return _api->glTexParameteri(target, pname, param);
}


void TexParameterivCall(const GlesContext* c, GLenum target, GLenum pname, const GLint* params) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexParameterivCall(%p, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, GetEnumString(pname), pname, params);
  return _api->glTexParameteriv(target, pname, params);
}


void TexSubImage2DCall(const GlesContext* c, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("TexSubImage2DCall(%p, %s (0x%x), %d, %d, %d, %zd, %zd, %s (0x%x), %s (0x%x), %p)", c, GetEnumString(target), target, level, xoffset, yoffset, width, height, GetEnumString(format), format, GetEnumString(type), type, pixels);
  return _api->glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}


void Uniform1fCall(const GlesContext* c, GLint location, GLfloat x) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform1fCall(%p, %d, %f)", c, location, x);
  return _api->glUniform1f(location, x);
}


void Uniform1fvCall(const GlesContext* c, GLint location, GLsizei count, const GLfloat* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform1fvCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform1fv(location, count, v);
}


void Uniform1iCall(const GlesContext* c, GLint location, GLint x) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform1iCall(%p, %d, %d)", c, location, x);
  return _api->glUniform1i(location, x);
}


void Uniform1ivCall(const GlesContext* c, GLint location, GLsizei count, const GLint* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform1ivCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform1iv(location, count, v);
}


void Uniform2fCall(const GlesContext* c, GLint location, GLfloat x, GLfloat y) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform2fCall(%p, %d, %f, %f)", c, location, x, y);
  return _api->glUniform2f(location, x, y);
}


void Uniform2fvCall(const GlesContext* c, GLint location, GLsizei count, const GLfloat* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform2fvCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform2fv(location, count, v);
}


void Uniform2iCall(const GlesContext* c, GLint location, GLint x, GLint y) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform2iCall(%p, %d, %d, %d)", c, location, x, y);
  return _api->glUniform2i(location, x, y);
}


void Uniform2ivCall(const GlesContext* c, GLint location, GLsizei count, const GLint* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform2ivCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform2iv(location, count, v);
}


void Uniform3fCall(const GlesContext* c, GLint location, GLfloat x, GLfloat y, GLfloat z) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform3fCall(%p, %d, %f, %f, %f)", c, location, x, y, z);
  return _api->glUniform3f(location, x, y, z);
}


void Uniform3fvCall(const GlesContext* c, GLint location, GLsizei count, const GLfloat* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform3fvCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform3fv(location, count, v);
}


void Uniform3iCall(const GlesContext* c, GLint location, GLint x, GLint y, GLint z) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform3iCall(%p, %d, %d, %d, %d)", c, location, x, y, z);
  return _api->glUniform3i(location, x, y, z);
}


void Uniform3ivCall(const GlesContext* c, GLint location, GLsizei count, const GLint* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform3ivCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform3iv(location, count, v);
}


void Uniform4fCall(const GlesContext* c, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform4fCall(%p, %d, %f, %f, %f, %f)", c, location, x, y, z, w);
  return _api->glUniform4f(location, x, y, z, w);
}


void Uniform4fvCall(const GlesContext* c, GLint location, GLsizei count, const GLfloat* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform4fvCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform4fv(location, count, v);
}


void Uniform4iCall(const GlesContext* c, GLint location, GLint x, GLint y, GLint z, GLint w) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform4iCall(%p, %d, %d, %d, %d, %d)", c, location, x, y, z, w);
  return _api->glUniform4i(location, x, y, z, w);
}


void Uniform4ivCall(const GlesContext* c, GLint location, GLsizei count, const GLint* v) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("Uniform4ivCall(%p, %d, %zd, %p)", c, location, count, v);
  return _api->glUniform4iv(location, count, v);
}


void UniformMatrix2fvCall(const GlesContext* c, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("UniformMatrix2fvCall(%p, %d, %zd, %d, %p)", c, location, count, transpose, value);
  return _api->glUniformMatrix2fv(location, count, transpose, value);
}


void UniformMatrix3fvCall(const GlesContext* c, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("UniformMatrix3fvCall(%p, %d, %zd, %d, %p)", c, location, count, transpose, value);
  return _api->glUniformMatrix3fv(location, count, transpose, value);
}


void UniformMatrix4fvCall(const GlesContext* c, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("UniformMatrix4fvCall(%p, %d, %zd, %d, %p)", c, location, count, transpose, value);
  return _api->glUniformMatrix4fv(location, count, transpose, value);
}


void UseProgramCall(const GlesContext* c, GLuint program) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("UseProgramCall(%p, %u)", c, program);
  return _api->glUseProgram(program);
}


void ValidateProgramCall(const GlesContext* c, GLuint program) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ValidateProgramCall(%p, %u)", c, program);
  return _api->glValidateProgram(program);
}


void VertexAttrib1fCall(const GlesContext* c, GLuint indx, GLfloat x) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib1fCall(%p, %u, %f)", c, indx, x);
  return _api->glVertexAttrib1f(indx, x);
}


void VertexAttrib1fvCall(const GlesContext* c, GLuint indx, const GLfloat* values) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib1fvCall(%p, %u, %p)", c, indx, values);
  return _api->glVertexAttrib1fv(indx, values);
}


void VertexAttrib2fCall(const GlesContext* c, GLuint indx, GLfloat x, GLfloat y) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib2fCall(%p, %u, %f, %f)", c, indx, x, y);
  return _api->glVertexAttrib2f(indx, x, y);
}


void VertexAttrib2fvCall(const GlesContext* c, GLuint indx, const GLfloat* values) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib2fvCall(%p, %u, %p)", c, indx, values);
  return _api->glVertexAttrib2fv(indx, values);
}


void VertexAttrib3fCall(const GlesContext* c, GLuint indx, GLfloat x, GLfloat y, GLfloat z) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib3fCall(%p, %u, %f, %f, %f)", c, indx, x, y, z);
  return _api->glVertexAttrib3f(indx, x, y, z);
}


void VertexAttrib3fvCall(const GlesContext* c, GLuint indx, const GLfloat* values) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib3fvCall(%p, %u, %p)", c, indx, values);
  return _api->glVertexAttrib3fv(indx, values);
}


void VertexAttrib4fCall(const GlesContext* c, GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib4fCall(%p, %u, %f, %f, %f, %f)", c, indx, x, y, z, w);
  return _api->glVertexAttrib4f(indx, x, y, z, w);
}


void VertexAttrib4fvCall(const GlesContext* c, GLuint indx, const GLfloat* values) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttrib4fvCall(%p, %u, %p)", c, indx, values);
  return _api->glVertexAttrib4fv(indx, values);
}


void VertexAttribPointerCall(const GlesContext* c, GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("VertexAttribPointerCall(%p, %u, %d, %s (0x%x), %d, %zd, %p)", c, indx, size, GetEnumString(type), type, normalized, stride, ptr);
  return _api->glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
}


void ViewportCall(const GlesContext* c, GLint x, GLint y, GLsizei width, GLsizei height) {
  emugl::ContextGPU* context = static_cast<emugl::ContextGPU*>(c->Impl());
  ContextAutoLock lock(context);
  const GraphicsApis* angle_apis =
      static_cast<const GraphicsApis*>(c->Apis());
  const ANGLE_GLES2* _api =
      static_cast<const ANGLE_GLES2*>(angle_apis->angle);
  DPRINT("ViewportCall(%p, %d, %d, %zd, %zd)", c, x, y, width, height);
  return _api->glViewport(x, y, width, height);
}

